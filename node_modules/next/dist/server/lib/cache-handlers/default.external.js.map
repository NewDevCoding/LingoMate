{"version":3,"sources":["../../../../src/server/lib/cache-handlers/default.external.ts"],"sourcesContent":["/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  areTagsExpired,\n  areTagsStale,\n  tagsManifest,\n  type TagManifestEntry,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\n// LRU cache default to max 50 MB but in future track\nconst memoryCache = new LRUCache<PrivateCacheEntry>(\n  50 * 1024 * 1024,\n  (entry) => entry.size\n)\nconst pendingSets = new Map<string, Promise<void>>()\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'DefaultCacheHandler:')\n  : undefined\n\nconst DefaultCacheHandler: CacheHandler = {\n  async get(cacheKey) {\n    const pendingPromise = pendingSets.get(cacheKey)\n\n    if (pendingPromise) {\n      debug?.('get', cacheKey, 'pending')\n      await pendingPromise\n    }\n\n    const privateEntry = memoryCache.get(cacheKey)\n\n    if (!privateEntry) {\n      debug?.('get', cacheKey, 'not found')\n      return undefined\n    }\n\n    const entry = privateEntry.entry\n    if (\n      performance.timeOrigin + performance.now() >\n      entry.timestamp + entry.revalidate * 1000\n    ) {\n      // In-memory caches should expire after revalidate time because it is\n      // unlikely that a new entry will be able to be used before it is dropped\n      // from the cache.\n      debug?.('get', cacheKey, 'expired')\n\n      return undefined\n    }\n\n    let revalidate = entry.revalidate\n\n    if (areTagsExpired(entry.tags, entry.timestamp)) {\n      debug?.('get', cacheKey, 'had expired tag')\n      return undefined\n    }\n\n    if (areTagsStale(entry.tags, entry.timestamp)) {\n      debug?.('get', cacheKey, 'had stale tag')\n      revalidate = -1\n    }\n\n    const [returnStream, newSaved] = entry.value.tee()\n    entry.value = newSaved\n\n    debug?.('get', cacheKey, 'found', {\n      tags: entry.tags,\n      timestamp: entry.timestamp,\n      expire: entry.expire,\n      revalidate,\n    })\n\n    return {\n      ...entry,\n      revalidate,\n      value: returnStream,\n    }\n  },\n\n  async set(cacheKey, pendingEntry) {\n    debug?.('set', cacheKey, 'start')\n\n    let resolvePending: () => void = () => {}\n    const pendingPromise = new Promise<void>((resolve) => {\n      resolvePending = resolve\n    })\n    pendingSets.set(cacheKey, pendingPromise)\n\n    const entry = await pendingEntry\n\n    let size = 0\n\n    try {\n      const [value, clonedValue] = entry.value.tee()\n      entry.value = value\n      const reader = clonedValue.getReader()\n\n      for (let chunk; !(chunk = await reader.read()).done; ) {\n        size += Buffer.from(chunk.value).byteLength\n      }\n\n      memoryCache.set(cacheKey, {\n        entry,\n        isErrored: false,\n        errorRetryCount: 0,\n        size,\n      })\n\n      debug?.('set', cacheKey, 'done')\n    } catch (err) {\n      // TODO: store partial buffer with error after we retry 3 times\n      debug?.('set', cacheKey, 'failed', err)\n    } finally {\n      resolvePending()\n      pendingSets.delete(cacheKey)\n    }\n  },\n\n  async refreshTags() {\n    // Nothing to do for an in-memory cache handler.\n  },\n\n  async getExpiration(tags) {\n    const expirations = tags.map((tag) => {\n      const entry = tagsManifest.get(tag)\n      if (!entry) return 0\n      // Return the most recent timestamp (either expired or stale)\n      return entry.expired || 0\n    })\n\n    const expiration = Math.max(...expirations, 0)\n\n    debug?.('getExpiration', { tags, expiration })\n\n    return expiration\n  },\n\n  async updateTags(tags, durations) {\n    const now = Math.round(performance.timeOrigin + performance.now())\n    debug?.('updateTags', { tags, timestamp: now })\n\n    for (const tag of tags) {\n      // TODO: update file-system-cache?\n      const existingEntry = tagsManifest.get(tag) || {}\n\n      if (durations) {\n        // Use provided durations directly\n        const updates: TagManifestEntry = { ...existingEntry }\n\n        // mark as stale immediately\n        updates.stale = now\n\n        if (durations.expire !== undefined) {\n          updates.expired = now + durations.expire * 1000 // Convert seconds to ms\n        }\n\n        tagsManifest.set(tag, updates)\n      } else {\n        // Update expired field for immediate expiration (default behavior when no durations provided)\n        tagsManifest.set(tag, { ...existingEntry, expired: now })\n      }\n    }\n  },\n}\n\nexport default DefaultCacheHandler\n"],"names":["memoryCache","LRUCache","entry","size","pendingSets","Map","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","console","bind","undefined","DefaultCacheHandler","get","cacheKey","pendingPromise","privateEntry","performance","timeOrigin","now","timestamp","revalidate","areTagsExpired","tags","areTagsStale","returnStream","newSaved","value","tee","expire","set","pendingEntry","resolvePending","Promise","resolve","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","err","delete","refreshTags","getExpiration","expirations","map","tag","tagsManifest","expired","expiration","Math","max","updateTags","durations","round","existingEntry","updates","stale"],"mappings":"AAAA;;;;;;;CAOC;;;;+BA0LD;;;eAAA;;;0BAxLyB;sCAOlB;AAsBP,qDAAqD;AACrD,MAAMA,cAAc,IAAIC,kBAAQ,CAC9B,KAAK,OAAO,MACZ,CAACC,QAAUA,MAAMC,IAAI;AAEvB,MAAMC,cAAc,IAAIC;AAExB,MAAMC,QAAQC,QAAQC,GAAG,CAACC,wBAAwB,GAC9CC,QAAQJ,KAAK,CAACK,IAAI,CAACD,SAAS,0BAC5BE;AAEJ,MAAMC,sBAAoC;IACxC,MAAMC,KAAIC,QAAQ;QAChB,MAAMC,iBAAiBZ,YAAYU,GAAG,CAACC;QAEvC,IAAIC,gBAAgB;YAClBV,yBAAAA,MAAQ,OAAOS,UAAU;YACzB,MAAMC;QACR;QAEA,MAAMC,eAAejB,YAAYc,GAAG,CAACC;QAErC,IAAI,CAACE,cAAc;YACjBX,yBAAAA,MAAQ,OAAOS,UAAU;YACzB,OAAOH;QACT;QAEA,MAAMV,QAAQe,aAAaf,KAAK;QAChC,IACEgB,YAAYC,UAAU,GAAGD,YAAYE,GAAG,KACxClB,MAAMmB,SAAS,GAAGnB,MAAMoB,UAAU,GAAG,MACrC;YACA,qEAAqE;YACrE,yEAAyE;YACzE,kBAAkB;YAClBhB,yBAAAA,MAAQ,OAAOS,UAAU;YAEzB,OAAOH;QACT;QAEA,IAAIU,aAAapB,MAAMoB,UAAU;QAEjC,IAAIC,IAAAA,oCAAc,EAACrB,MAAMsB,IAAI,EAAEtB,MAAMmB,SAAS,GAAG;YAC/Cf,yBAAAA,MAAQ,OAAOS,UAAU;YACzB,OAAOH;QACT;QAEA,IAAIa,IAAAA,kCAAY,EAACvB,MAAMsB,IAAI,EAAEtB,MAAMmB,SAAS,GAAG;YAC7Cf,yBAAAA,MAAQ,OAAOS,UAAU;YACzBO,aAAa,CAAC;QAChB;QAEA,MAAM,CAACI,cAAcC,SAAS,GAAGzB,MAAM0B,KAAK,CAACC,GAAG;QAChD3B,MAAM0B,KAAK,GAAGD;QAEdrB,yBAAAA,MAAQ,OAAOS,UAAU,SAAS;YAChCS,MAAMtB,MAAMsB,IAAI;YAChBH,WAAWnB,MAAMmB,SAAS;YAC1BS,QAAQ5B,MAAM4B,MAAM;YACpBR;QACF;QAEA,OAAO;YACL,GAAGpB,KAAK;YACRoB;YACAM,OAAOF;QACT;IACF;IAEA,MAAMK,KAAIhB,QAAQ,EAAEiB,YAAY;QAC9B1B,yBAAAA,MAAQ,OAAOS,UAAU;QAEzB,IAAIkB,iBAA6B,KAAO;QACxC,MAAMjB,iBAAiB,IAAIkB,QAAc,CAACC;YACxCF,iBAAiBE;QACnB;QACA/B,YAAY2B,GAAG,CAAChB,UAAUC;QAE1B,MAAMd,QAAQ,MAAM8B;QAEpB,IAAI7B,OAAO;QAEX,IAAI;YACF,MAAM,CAACyB,OAAOQ,YAAY,GAAGlC,MAAM0B,KAAK,CAACC,GAAG;YAC5C3B,MAAM0B,KAAK,GAAGA;YACd,MAAMS,SAASD,YAAYE,SAAS;YAEpC,IAAK,IAAIC,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMF,OAAOG,IAAI,EAAC,EAAGC,IAAI,EAAI;gBACrDtC,QAAQuC,OAAOC,IAAI,CAACJ,MAAMX,KAAK,EAAEgB,UAAU;YAC7C;YAEA5C,YAAY+B,GAAG,CAAChB,UAAU;gBACxBb;gBACA2C,WAAW;gBACXC,iBAAiB;gBACjB3C;YACF;YAEAG,yBAAAA,MAAQ,OAAOS,UAAU;QAC3B,EAAE,OAAOgC,KAAK;YACZ,+DAA+D;YAC/DzC,yBAAAA,MAAQ,OAAOS,UAAU,UAAUgC;QACrC,SAAU;YACRd;YACA7B,YAAY4C,MAAM,CAACjC;QACrB;IACF;IAEA,MAAMkC;IACJ,gDAAgD;IAClD;IAEA,MAAMC,eAAc1B,IAAI;QACtB,MAAM2B,cAAc3B,KAAK4B,GAAG,CAAC,CAACC;YAC5B,MAAMnD,QAAQoD,kCAAY,CAACxC,GAAG,CAACuC;YAC/B,IAAI,CAACnD,OAAO,OAAO;YACnB,6DAA6D;YAC7D,OAAOA,MAAMqD,OAAO,IAAI;QAC1B;QAEA,MAAMC,aAAaC,KAAKC,GAAG,IAAIP,aAAa;QAE5C7C,yBAAAA,MAAQ,iBAAiB;YAAEkB;YAAMgC;QAAW;QAE5C,OAAOA;IACT;IAEA,MAAMG,YAAWnC,IAAI,EAAEoC,SAAS;QAC9B,MAAMxC,MAAMqC,KAAKI,KAAK,CAAC3C,YAAYC,UAAU,GAAGD,YAAYE,GAAG;QAC/Dd,yBAAAA,MAAQ,cAAc;YAAEkB;YAAMH,WAAWD;QAAI;QAE7C,KAAK,MAAMiC,OAAO7B,KAAM;YACtB,kCAAkC;YAClC,MAAMsC,gBAAgBR,kCAAY,CAACxC,GAAG,CAACuC,QAAQ,CAAC;YAEhD,IAAIO,WAAW;gBACb,kCAAkC;gBAClC,MAAMG,UAA4B;oBAAE,GAAGD,aAAa;gBAAC;gBAErD,4BAA4B;gBAC5BC,QAAQC,KAAK,GAAG5C;gBAEhB,IAAIwC,UAAU9B,MAAM,KAAKlB,WAAW;oBAClCmD,QAAQR,OAAO,GAAGnC,MAAMwC,UAAU9B,MAAM,GAAG,KAAK,wBAAwB;;gBAC1E;gBAEAwB,kCAAY,CAACvB,GAAG,CAACsB,KAAKU;YACxB,OAAO;gBACL,8FAA8F;gBAC9FT,kCAAY,CAACvB,GAAG,CAACsB,KAAK;oBAAE,GAAGS,aAAa;oBAAEP,SAASnC;gBAAI;YACzD;QACF;IACF;AACF;MAEA,WAAeP","ignoreList":[0]}