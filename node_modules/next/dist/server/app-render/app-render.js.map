{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type { RenderOpts, PreloadCallbacks } from './types'\nimport type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  Segment,\n  CacheNodeSeedData,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from '../../shared/lib/app-router-types'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernRuntime,\n  RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  ClientReferenceManifest,\n  ManifestNode,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HASH_COOKIE,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n} from '../../client/components/app-router-headers'\nimport { createMetadataContext } from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport { dynamicParamTypes } from './get-short-dynamic-param-type'\nimport { getSegmentParam } from '../../shared/lib/router/utils/get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport {\n  getServerModuleMap,\n  setReferenceManifestsSingleton,\n} from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  DynamicHTMLPreludeState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createRenderInBrowserAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  PreludeState,\n  consumeDynamicAccess,\n  type DynamicAccess,\n  logDisallowedDynamicError,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../client/components/app-router-instance'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { OpaqueFallbackRouteParams } from '../request/fallback-params'\nimport {\n  prerenderAndAbortInSequentialTasksWithStages,\n  processPrelude,\n} from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { consoleAsyncStorage } from './console-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport { HTML_CONTENT_TYPE_HEADER, INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\nimport { getPreviouslyRevalidatedTags } from '../server-utils'\nimport { executeRevalidates } from '../revalidation-utils'\nimport {\n  trackPendingChunkLoad,\n  trackPendingImport,\n  trackPendingModules,\n} from './module-loading/track-module-loading.external'\nimport { isReactLargeShellError } from './react-large-shell-error'\nimport type { GlobalErrorComponent } from '../../client/components/builtin/global-error'\nimport { normalizeConventionFilePath } from './segment-explorer-path'\nimport { getRequestMeta } from '../request-meta'\nimport {\n  getDynamicParam,\n  interpolateParallelRouteParams,\n} from '../../shared/lib/router/utils/get-dynamic-param'\nimport type { ExperimentalConfig } from '../config-shared'\nimport type { Params } from '../request/params'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\nimport { ImageConfigContext } from '../../shared/lib/image-config-context.shared-runtime'\nimport { imageConfigDefault } from '../../shared/lib/image-config'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => DynamicParam | null\n\nexport type DynamicParam = {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n}\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isPossibleServerAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  htmlRequestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n  /**\n   * For now, the implicit tags are common for the whole route. If we ever start\n   * rendering/revalidating segments independently, they need to move to the\n   * work unit store.\n   */\n  implicitTags: ImplicitTags\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n  readonly previewModeId: string | undefined\n}\n\nconst flightDataPathHeadKey = 'h'\nconst getFlightViewportKey = (requestId: string) => requestId + 'v'\nconst getFlightMetadataKey = (requestId: string) => requestId + 'm'\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRuntimePrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n  readonly previouslyRevalidatedTags: string[]\n  readonly requestId: string | undefined\n  readonly htmlRequestId: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  // runtime prefetch requests are *not* treated as prefetch requests\n  // (TODO: this is confusing, we should refactor this to express this better)\n  const isPrefetchRequest =\n    isDevWarmupRequest || headers[NEXT_ROUTER_PREFETCH_HEADER] === '1'\n\n  const isRuntimePrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '2'\n\n  const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest = isDevWarmupRequest || headers[RSC_HEADER] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(headers[NEXT_ROUTER_STATE_TREE_HEADER])\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n    headers,\n    options.previewModeId\n  )\n\n  let requestId: string | undefined\n  let htmlRequestId: string | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    // The request IDs are only used in development mode to send debug\n    // information to the matching client (identified by the HTML request ID\n    // that was sent to the client with the HTML document) for the current\n    // request (identified by the request ID, as defined by the client).\n\n    requestId =\n      typeof headers[NEXT_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_REQUEST_ID_HEADER]\n        : undefined\n\n    htmlRequestId =\n      typeof headers[NEXT_HTML_REQUEST_ID_HEADER] === 'string'\n        ? headers[NEXT_HTML_REQUEST_ID_HEADER]\n        : undefined\n  }\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n    previouslyRevalidatedTags,\n    requestId,\n    htmlRequestId,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  const components = loaderTree[2]\n  const hasGlobalNotFound = !!components['global-not-found']\n  const notFoundTreeComponents: LoaderTree[2] = hasGlobalNotFound\n    ? {\n        layout: components['global-not-found']!,\n        page: [() => null, 'next/dist/client/components/builtin/empty-stub'],\n      }\n    : {\n        page: components['not-found'],\n      }\n\n  return [\n    '',\n    {\n      children: [PAGE_SEGMENT_KEY, {}, notFoundTreeComponents],\n    },\n    // When global-not-found is present, skip layout from components\n    hasGlobalNotFound ? components : {},\n  ]\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n    const segmentKey = segmentParam.param\n    const dynamicParamType = dynamicParamTypes[segmentParam.type]\n    return getDynamicParam(\n      interpolatedParams,\n      segmentKey,\n      dynamicParamType,\n      fallbackRouteParams\n    )\n  }\n}\n\nfunction NonIndex({\n  pagePath,\n  statusCode,\n  isPossibleServerAction,\n}: {\n  pagePath: string\n  statusCode: number | undefined\n  isPossibleServerAction: boolean\n}) {\n  const is404Page = pagePath === '/404'\n  const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  // TODO: is this correct if `isPossibleServerAction` is a false positive?\n  if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `next-router-state-tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n      createMetadataComponents,\n    },\n    getDynamicParamFromSegment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n      tree: loaderTree,\n      parsedQuery: query,\n      pathname: url.pathname,\n      metadataContext: createMetadataContext(ctx.renderOpts),\n      getDynamicParamFromSegment,\n      workStore,\n      serveStreamingMetadata,\n    })\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            {/* noindex needs to be blocking */}\n            <NonIndex\n              pagePath={ctx.pagePath}\n              statusCode={ctx.res.statusCode}\n              isPossibleServerAction={ctx.isPossibleServerAction}\n            />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <Viewport key={getFlightViewportKey(requestId)} />\n            <Metadata key={getFlightMetadataKey(requestId)} />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        preloadCallbacks,\n        MetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const {\n    clientReferenceManifest,\n    componentMod,\n    htmlRequestId,\n    renderOpts,\n    requestId,\n    workStore,\n  } = ctx\n\n  const {\n    dev = false,\n    onInstrumentationRequestError,\n    setReactDebugChannel,\n  } = renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during cacheComponents development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  const debugChannel = setReactDebugChannel && createDebugChannel()\n\n  if (debugChannel) {\n    setReactDebugChannel(debugChannel.clientSide, htmlRequestId, requestId)\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    componentMod.renderToReadableStream,\n    RSCPayload,\n    clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n      filterStackFrame,\n      debugChannel: debugChannel?.serverSide,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: workStore.fetchMetrics,\n  })\n}\n\nasync function generateRuntimePrefetchResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  requestStore: RequestStore\n): Promise<RenderResult> {\n  const { workStore } = ctx\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      // TODO(runtime-ppr): should we use a different value?\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    false,\n    onFlightDataRenderError\n  )\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const generatePayload = () => generateDynamicRSCPayload(ctx, undefined)\n\n  const {\n    componentMod: {\n      routeModule: {\n        userland: { loaderTree },\n      },\n    },\n    getDynamicParamFromSegment,\n  } = ctx\n  const rootParams = getRootParams(loaderTree, getDynamicParamFromSegment)\n\n  // We need to share caches between the prospective prerender and the final prerender,\n  // but we're not going to persist this anywhere.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  // We're not resuming an existing render.\n  const renderResumeDataCache = null\n\n  await prospectiveRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode\n  )\n\n  const response = await finalRuntimeServerPrerender(\n    ctx,\n    generatePayload,\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    rootParams,\n    requestStore.headers,\n    requestStore.cookies,\n    requestStore.draftMode,\n    onError\n  )\n\n  applyMetadataFromPrerenderResult(response, metadata, workStore)\n  metadata.fetchMetrics = ctx.workStore.fetchMetrics\n\n  if (response.isPartial) {\n    res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n  }\n\n  return new FlightRenderResult(response.result.prelude, metadata)\n}\n\nasync function prospectiveRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode']\n) {\n  const { implicitTags, renderOpts, workStore } = ctx\n\n  const { clientReferenceManifest, ComponentMod } = renderOpts\n\n  assertClientReferenceManifest(clientReferenceManifest)\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  // The cacheSignal helps us track whether caches are still filling or we are ready\n  // to cut the render off.\n  const cacheSignal = new CacheSignal()\n\n  const initialServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    // During the initial prerender we need to track all cache reads to ensure\n    // we render long enough to fill every cache it is possible to visit during\n    // the final prerender.\n    cacheSignal,\n    // We only need to track dynamic accesses during the final prerender.\n    dynamicTracking: null,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    renderResumeDataCache,\n    prerenderResumeDataCache,\n    hmrRefreshHash: undefined,\n    captureOwnerStack: undefined,\n    // We only need task sequencing in the final prerender.\n    runtimeStagePromise: null,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const initialServerPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getPayload\n  )\n\n  const pendingInitialServerResult = workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    ComponentMod.prerender,\n    initialServerPayload,\n    clientReferenceManifest.clientModules,\n    {\n      filterStackFrame,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (initialServerPrerenderController.signal.aborted) {\n          // The render aborted before this error was handled which indicates\n          // the error is caused by unfinished components within the render\n          return\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          printDebugThrownValueForProspectiveRender(err, workStore.route)\n        }\n      },\n      // we don't care to track postpones during the prospective render because we need\n      // to always do a final render anyway\n      onPostpone: undefined,\n      // We don't want to stop rendering until the cacheSignal is complete so we pass\n      // a different signal to this render call than is used by dynamic APIs to signify\n      // transitioning out of the prerender environment\n      signal: initialServerRenderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling and for async imports to resolve\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  if (workStore.invalidDynamicUsageError) {\n    throw workStore.invalidDynamicUsageError\n  }\n\n  try {\n    return await createReactServerPrerenderResult(pendingInitialServerResult)\n  } catch (err) {\n    if (\n      initialServerRenderController.signal.aborted ||\n      initialServerPrerenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, workStore.route)\n    }\n    return null\n  }\n}\n\nasync function finalRuntimeServerPrerender(\n  ctx: AppRenderContext,\n  getPayload: () => any,\n  prerenderResumeDataCache: PrerenderResumeDataCache | null,\n  renderResumeDataCache: RenderResumeDataCache | null,\n  rootParams: Params,\n  headers: PrerenderStoreModernRuntime['headers'],\n  cookies: PrerenderStoreModernRuntime['cookies'],\n  draftMode: PrerenderStoreModernRuntime['draftMode'],\n  onError: (err: unknown) => string | undefined\n) {\n  const { implicitTags, renderOpts } = ctx\n\n  const {\n    clientReferenceManifest,\n    ComponentMod,\n    experimental,\n    isDebugDynamicAccesses,\n  } = renderOpts\n\n  assertClientReferenceManifest(clientReferenceManifest)\n\n  const selectStaleTime = createSelectStaleTime(experimental)\n\n  let serverIsDynamic = false\n  const finalServerController = new AbortController()\n\n  const serverDynamicTracking = createDynamicTrackingState(\n    isDebugDynamicAccesses\n  )\n\n  const { promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } =\n    createPromiseWithResolvers<void>()\n\n  const finalServerPrerenderStore: PrerenderStoreModernRuntime = {\n    type: 'prerender-runtime',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // All caches we could read must already be filled so no tracking is necessary\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    // Runtime prefetches are never cached server-side, only client-side,\n    // so we set `expire` and `revalidate` to their minimum values just in case.\n    revalidate: 1,\n    expire: 0,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache,\n    hmrRefreshHash: undefined,\n    captureOwnerStack: undefined,\n    // Used to separate the \"Static\" stage from the \"Runtime\" stage.\n    runtimeStagePromise,\n    // These are not present in regular prerenders, but allowed in a runtime prerender.\n    headers,\n    cookies,\n    draftMode,\n  }\n\n  const finalRSCPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getPayload\n  )\n\n  let prerenderIsPending = true\n  const result = await prerenderAndAbortInSequentialTasksWithStages(\n    async () => {\n      // Static stage\n      const prerenderResult = await workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.prerender,\n        finalRSCPayload,\n        clientReferenceManifest.clientModules,\n        {\n          filterStackFrame,\n          onError,\n          signal: finalServerController.signal,\n        }\n      )\n      prerenderIsPending = false\n      return prerenderResult\n    },\n    () => {\n      // Advance to the runtime stage.\n      //\n      // We make runtime APIs hang during the first task (above), and unblock them in the following task (here).\n      // This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).\n      // We know that they don't contain any incorrect sync IO, because that'd have caused a build error.\n      // After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),\n      // we'll abort, but we'll produce at least as much output as a static prerender would.\n      resolveBlockedRuntimeAPIs()\n    },\n    () => {\n      // Abort.\n      if (finalServerController.signal.aborted) {\n        // If the server controller is already aborted we must have called something\n        // that required aborting the prerender synchronously such as with new Date()\n        serverIsDynamic = true\n        return\n      }\n\n      if (prerenderIsPending) {\n        // If prerenderIsPending then we have blocked for longer than a Task and we assume\n        // there is something unfinished.\n        serverIsDynamic = true\n      }\n      finalServerController.abort()\n    }\n  )\n\n  return {\n    result,\n    // TODO(runtime-ppr): do we need to produce a digest map here?\n    // digestErrorsMap: ...,\n    dynamicAccess: serverDynamicTracking,\n    isPartial: serverIsDynamic,\n    collectedRevalidate: finalServerPrerenderStore.revalidate,\n    collectedExpire: finalServerPrerenderStore.expire,\n    collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n    collectedTags: finalServerPrerenderStore.tags,\n  }\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext\n): Promise<RenderResult> {\n  const {\n    clientReferenceManifest,\n    componentMod: ComponentMod,\n    getDynamicParamFromSegment,\n    implicitTags,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const {\n    allowEmptyStaticShell = false,\n    dev,\n    onInstrumentationRequestError,\n  } = renderOpts\n\n  if (!dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  const rootParams = getRootParams(\n    ComponentMod.routeModule.userland.loaderTree,\n    getDynamicParamFromSegment\n  )\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  // We're doing a dev warmup, so we should create a new resume data cache so\n  // we can fill it.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const renderController = new AbortController()\n  const prerenderController = new AbortController()\n  const reactController = new AbortController()\n  const cacheSignal = new CacheSignal()\n\n  const prerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: renderController.signal,\n    controller: prerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash: req.cookies[NEXT_HMR_REFRESH_HASH_COOKIE],\n    captureOwnerStack: ComponentMod.captureOwnerStack,\n    // warmup is a dev only feature and no fallback params are used in the\n    // primary render which is static. We only use a prerender store here to\n    // allow the warmup to halt on Request data APIs and fetches.\n    fallbackRouteParams: null,\n  }\n\n  const rscPayload = await workUnitAsyncStorage.run(\n    prerenderStore,\n    generateDynamicRSCPayload,\n    ctx\n  )\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  workUnitAsyncStorage.run(\n    prerenderStore,\n    ComponentMod.renderToReadableStream,\n    rscPayload,\n    clientReferenceManifest.clientModules,\n    {\n      filterStackFrame,\n      onError,\n      signal: renderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling and for async imports to resolve\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n\n  // We unset the cache so any late over-run renders aren't able to write into this cache\n  prerenderStore.prerenderResumeDataCache = null\n  // Abort the render\n  reactController.abort()\n  renderController.abort()\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: workStore.fetchMetrics,\n    renderResumeDataCache: createRenderResumeDataCache(\n      prerenderResumeDataCache\n    ),\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: { createMetadataComponents },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const hasGlobalNotFound = !!tree[2]['global-not-found']\n\n  const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n    tree,\n    // When it's using global-not-found, metadata errorType is undefined, which will retrieve the\n    // metadata from the page.\n    // When it's using not-found, metadata errorType is 'not-found', which will retrieve the\n    // metadata from the not-found.js boundary.\n    // TODO: remove this condition and keep it undefined when global-not-found is stabilized.\n    errorType: is404 && !hasGlobalNotFound ? 'not-found' : undefined,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    MetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      <Viewport />\n      <Metadata />\n      {/* This meta tag is for next/font which is still required to be blocking. */}\n      {appUsingSizeAdjustment ? (\n        <meta name=\"next-size-adjust\" content=\"\" />\n      ) : null}\n    </React.Fragment>\n  )\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    componentMod: { createMetadataComponents },\n    url,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const { Viewport, Metadata } = createMetadataComponents({\n    tree,\n    parsedQuery: query,\n    pathname: url.pathname,\n    metadataContext: createMetadataContext(ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    workStore,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      <Viewport />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n      <Metadata />\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        {process.env.NODE_ENV !== 'production' && err ? (\n          <template\n            data-next-error-message={err.message}\n            data-next-error-digest={'digest' in err ? err.digest : ''}\n            data-next-error-stack={err.stack}\n          />\n        ) : null}\n      </body>\n    </html>,\n    {},\n    null,\n    false,\n    false, // We don't currently support runtime prefetching for error pages.\n  ]\n\n  const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n    tree,\n    ctx\n  )\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\nfunction assertClientReferenceManifest(\n  clientReferenceManifest: RenderOpts['clientReferenceManifest']\n): asserts clientReferenceManifest is NonNullable<\n  RenderOpts['clientReferenceManifest']\n> {\n  if (!clientReferenceManifest) {\n    throw new InvariantError('Expected clientReferenceManifest to be defined.')\n  }\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  reactDebugStream,\n  preinitScripts,\n  clientReferenceManifest,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  reactDebugStream: ReadableStream<Uint8Array> | undefined\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  images: RenderOpts['images']\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      reactDebugStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n        <ServerInsertedHTMLProvider>\n          <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n        </ServerInsertedHTMLProvider>\n      </ImageConfigContext.Provider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp<T>({\n  reactServerStream,\n  reactDebugStream,\n  preinitScripts,\n  clientReferenceManifest,\n  ServerInsertedHTMLProvider,\n  nonce,\n  images,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  reactDebugStream: ReadableStream<Uint8Array> | undefined\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n  images: RenderOpts['images']\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      reactDebugStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  return (\n    <ImageConfigContext.Provider value={images ?? imageConfigDefault}>\n      <ServerInsertedHTMLProvider>\n        <AppRouter actionQueue={actionQueue} globalErrorState={response.G} />\n      </ServerInsertedHTMLProvider>\n    </ImageConfigContext.Provider>\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  postponedState: PostponedState | null,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext,\n  interpolatedParams: Params,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    clientReferenceManifest,\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n    experimental,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we track calls to `loadChunk` and `require`. This allows us\n    // to treat chunk/module loading with similar semantics as cache reads to avoid\n    // module loading from causing a prerender to abort too early.\n\n    const shouldTrackModuleLoading = () => {\n      if (!renderOpts.experimental.cacheComponents) {\n        return false\n      }\n      if (renderOpts.dev) {\n        return true\n      }\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      if (!workUnitStore) {\n        return false\n      }\n\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-runtime':\n        case 'cache':\n        case 'private-cache':\n          return true\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'unstable-cache':\n          return false\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    const __next_require__: typeof instrumented.require = (...args) => {\n      const exportsOrPromise = instrumented.require(...args)\n      if (shouldTrackModuleLoading()) {\n        // requiring an async module returns a promise.\n        trackPendingImport(exportsOrPromise)\n      }\n      return exportsOrPromise\n    }\n    // @ts-expect-error\n    globalThis.__next_require__ = __next_require__\n\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      if (shouldTrackModuleLoading()) {\n        trackPendingChunkLoad(loadingChunk)\n      }\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    renderOpts.setIsrStatus &&\n    !experimental.cacheComponents\n  ) {\n    // Reset the ISR status at start of request.\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus(\n      pathname,\n      // Only pages using the Node runtime can use ISR, Edge is always dynamic.\n      process.env.NEXT_RUNTIME === 'edge' ? false : undefined\n    )\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    res.onClose(() => {\n      // We stop tracking fetch metrics when the response closes, since we\n      // report them at that time.\n      workStore.shouldTrackFetchMetrics = false\n    })\n\n    req.originalRequest.on('end', () => {\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {\n    statusCode: isNotFoundPath ? 404 : undefined,\n  }\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  assertClientReferenceManifest(clientReferenceManifest)\n\n  const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n\n  setReferenceManifestsSingleton({\n    page: workStore.page,\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const {\n    routeModule: {\n      userland: { loaderTree },\n    },\n    taintObjectReference,\n  } = ComponentMod\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to Client Components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const { isStaticGeneration } = workStore\n\n  let requestId: string\n  let htmlRequestId: string\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRuntimePrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  if (parsedRequestHeaders.requestId) {\n    // If the client has provided a request ID (in development mode), we use it.\n    requestId = parsedRequestHeaders.requestId\n  } else {\n    // Otherwise we generate a new request ID.\n    if (isStaticGeneration) {\n      requestId = Buffer.from(\n        await crypto.subtle.digest('SHA-1', Buffer.from(req.url))\n      ).toString('hex')\n    } else if (process.env.NEXT_RUNTIME === 'edge') {\n      requestId = crypto.randomUUID()\n    } else {\n      requestId = (\n        require('next/dist/compiled/nanoid') as typeof import('next/dist/compiled/nanoid')\n      ).nanoid()\n    }\n  }\n\n  // If the client has provided an HTML request ID, we use it to associate the\n  // request with the HTML document from which it originated, which is used to\n  // send debug information to the associated WebSocket client. Otherwise, this\n  // is the request for the HTML document, so we use the request ID also as the\n  // HTML request ID.\n  htmlRequestId = parsedRequestHeaders.htmlRequestId || requestId\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    interpolatedParams,\n    fallbackRouteParams\n  )\n\n  const isPossibleActionRequest = getIsPossibleServerAction(req)\n\n  const implicitTags = await getImplicitTags(\n    workStore.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isPossibleServerAction: isPossibleActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    htmlRequestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n    implicitTags,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      loaderTree,\n      fallbackRouteParams\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (workStore.invalidDynamicUsageError) {\n      logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n      throw new StaticGenBailoutError()\n    }\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    applyMetadataFromPrerenderResult(response, metadata, workStore)\n\n    if (response.renderResumeDataCache) {\n      metadata.renderResumeDataCache = response.renderResumeDataCache\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.renderResumeDataCache ??\n      postponedState?.renderResumeDataCache ??\n      null\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const devValidatingFallbackParams =\n      getRequestMeta(req, 'devValidatingFallbackParams') || null\n    const requestStore = createRequestStoreForRender(\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache,\n      devValidatingFallbackParams\n    )\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      !experimental.cacheComponents &&\n      // Only pages using the Node runtime can use ISR, so we only need to\n      // update the status for those.\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        const isStatic = !requestStore.usedDynamic && !workStore.forceDynamic\n        setIsrStatus(pathname, isStatic)\n      })\n    }\n\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      if (isRuntimePrefetchRequest) {\n        return generateRuntimePrefetchResult(req, res, ctx, requestStore)\n      } else {\n        return generateDynamicFlightRenderResult(req, ctx, requestStore)\n      }\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isPossibleActionRequest) {\n      // For action requests, we don't want to use the resume data cache.\n      requestStore.renderResumeDataCache = null\n\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n        metadata,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          metadata.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            notFoundLoaderTree,\n            formState,\n            postponedState,\n            metadata,\n            devValidatingFallbackParams\n          )\n\n          return new RenderResult(stream, {\n            metadata,\n            contentType: HTML_CONTENT_TYPE_HEADER,\n          })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n\n      // Restore the resume data cache\n      requestStore.renderResumeDataCache = renderResumeDataCache\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n      contentType: HTML_CONTENT_TYPE_HEADER,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      loaderTree,\n      formState,\n      postponedState,\n      metadata,\n      devValidatingFallbackParams\n    )\n\n    // Invalid dynamic usages should only error the request in development.\n    // In production, it's better to produce a result.\n    // (the dynamic error will still be thrown inside the component tree, but it's catchable by error boundaries)\n    if (workStore.invalidDynamicUsageError && workStore.dev) {\n      throw workStore.invalidDynamicUsageError\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  isDevWarmup: boolean,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  isDevWarmup,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n    previewModeId: renderOpts.previewProps?.previewModeId,\n  })\n\n  const { isPrefetchRequest, previouslyRevalidatedTags, nonce } =\n    parsedRequestHeaders\n\n  let interpolatedParams: Params\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      interpolatedParams\n    )\n  } else {\n    interpolatedParams = interpolateParallelRouteParams(\n      renderOpts.ComponentMod.routeModule.userland.loaderTree,\n      renderOpts.params ?? {},\n      pagePath,\n      fallbackRouteParams\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.renderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    renderOpts,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n    previouslyRevalidatedTags,\n    nonce,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    postponedState,\n    serverComponentsHmrCache,\n    sharedContext,\n    interpolatedParams,\n    fallbackRouteParams\n  )\n}\n\nfunction applyMetadataFromPrerenderResult(\n  response: Pick<\n    PrerenderToStreamResult,\n    | 'collectedExpire'\n    | 'collectedRevalidate'\n    | 'collectedStale'\n    | 'collectedTags'\n  >,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore\n) {\n  if (response.collectedTags) {\n    metadata.fetchTags = response.collectedTags.join(',')\n  }\n\n  // Let the client router know how long to keep the cached entry around.\n  const staleHeader = String(response.collectedStale)\n  metadata.headers ??= {}\n  metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n  // If force static is specifically set to false, we should not revalidate\n  // the page.\n  if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n    metadata.cacheControl = { revalidate: 0, expire: undefined }\n  } else {\n    // Copy the cache control value onto the render result metadata.\n    metadata.cacheControl = {\n      revalidate:\n        response.collectedRevalidate >= INFINITE_CACHE\n          ? false\n          : response.collectedRevalidate,\n      expire:\n        response.collectedExpire >= INFINITE_CACHE\n          ? undefined\n          : response.collectedExpire,\n    }\n  }\n\n  // provide bailout info for debugging\n  if (metadata.cacheControl.revalidate === 0) {\n    metadata.staticBailoutInfo = {\n      description: workStore.dynamicUsageDescription,\n      stack: workStore.dynamicUsageStack,\n    }\n  }\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null,\n  metadata: AppPageRenderResultMetadata,\n  devValidatingFallbackParams: OpaqueFallbackRouteParams | null\n): Promise<ReadableStream<Uint8Array>> {\n  const { assetPrefix, htmlRequestId, nonce, pagePath, renderOpts, requestId } =\n    ctx\n\n  const {\n    basePath,\n    buildManifest,\n    clientReferenceManifest,\n    ComponentMod,\n    crossOrigin,\n    dev = false,\n    experimental,\n    nextExport = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    setReactDebugChannel,\n    shouldWaitOnAllReady,\n    subresourceIntegrityManifest,\n    supportsDynamicResponse,\n  } = renderOpts\n\n  assertClientReferenceManifest(clientReferenceManifest)\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  // In development mode, set the request ID as a global variable, before the\n  // bootstrap script is executed, which depends on it during hydration.\n  const bootstrapScriptContent =\n    process.env.NODE_ENV !== 'production'\n      ? `self.__next_r=${JSON.stringify(requestId)}`\n      : undefined\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n  let reactDebugStream: ReadableStream<Uint8Array> | undefined\n\n  const setHeader = res.setHeader.bind(res)\n  const appendHeader = res.appendHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into cacheComponents\n      experimental.cacheComponents\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during cacheComponents development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const debugChannel = setReactDebugChannel && createDebugChannel()\n\n      if (debugChannel) {\n        const [readableSsr, readableBrowser] =\n          debugChannel.clientSide.readable.tee()\n\n        reactDebugStream = readableSsr\n\n        setReactDebugChannel(\n          { readable: readableBrowser },\n          htmlRequestId,\n          requestId\n        )\n      }\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n              filterStackFrame,\n              debugChannel: debugChannel?.serverSide,\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      consoleAsyncStorage.run(\n        { dim: true },\n        spawnDynamicValidationInDev,\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        requestStore,\n        devValidatingFallbackParams\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const debugChannel = setReactDebugChannel && createDebugChannel()\n\n      if (debugChannel) {\n        const [readableSsr, readableBrowser] =\n          debugChannel.clientSide.readable.tee()\n\n        reactDebugStream = readableSsr\n\n        setReactDebugChannel(\n          { readable: readableBrowser },\n          htmlRequestId,\n          requestId\n        )\n      }\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            filterStackFrame,\n            onError: serverComponentsErrorHandler,\n            debugChannel: debugChannel?.serverSide,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const { postponed, preludeState } =\n          getPostponedFromState(postponedState)\n        const resume = (\n          require('react-dom/server') as typeof import('react-dom/server')\n        ).resume\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            reactDebugStream={reactDebugStream}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          postponed,\n          { onError: htmlRendererErrorHandler, nonce }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n          // to avoid injecting RSC data too early.\n          // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n          // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n          delayDataUntilFirstHtmlChunk:\n            preludeState === DynamicHTMLPreludeState.Empty,\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = (\n      require('react-dom/server') as typeof import('react-dom/server')\n    ).renderToReadableStream\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        reactDebugStream={reactDebugStream}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        nonce={nonce}\n        images={ctx.renderOpts.images}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            appendHeader(key, value)\n          })\n        },\n        maxHeadersLength: reactMaxHeadersLength,\n        bootstrapScriptContent,\n        bootstrapScripts: [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML =\n      supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n      buildId: ctx.workStore.buildId,\n      getServerInsertedHTML,\n      getServerInsertedMetadata,\n      validateRootLayout: dev,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      metadata.statusCode = res.statusCode\n\n      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n      metadata.statusCode = res.statusCode\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      buildManifest,\n      assetPrefix,\n      crossOrigin,\n      subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        filterStackFrame,\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer:\n            require('react-dom/server') as typeof import('react-dom/server'),\n          element: (\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              reactDebugStream={undefined}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />\n          ),\n          streamOptions: {\n            nonce,\n            bootstrapScriptContent,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n        buildId: ctx.workStore.buildId,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        getServerInsertedMetadata,\n        validateRootLayout: dev,\n      })\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createDebugChannel():\n  | {\n      serverSide: { readable?: ReadableStream; writable: WritableStream }\n      clientSide: { readable: ReadableStream; writable?: WritableStream }\n    }\n  | undefined {\n  if (process.env.NODE_ENV === 'production') {\n    return undefined\n  }\n\n  let readableController: ReadableStreamDefaultController | undefined\n\n  const clientSideReadable = new ReadableStream<Uint8Array>({\n    start(controller) {\n      readableController = controller\n    },\n  })\n\n  return {\n    serverSide: {\n      writable: new WritableStream<Uint8Array>({\n        write(chunk) {\n          readableController?.enqueue(chunk)\n        },\n        close() {\n          readableController?.close()\n        },\n        abort(err) {\n          readableController?.error(err)\n        },\n      }),\n    },\n    clientSide: {\n      readable: clientSideReadable,\n    },\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\n/**\n * This function is a fork of prerenderToStream cacheComponents branch.\n * While it doesn't return a stream we want it to have identical\n * prerender semantics to prerenderToStream and should update it\n * in conjunction with any changes to that function.\n */\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  requestStore: RequestStore,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): Promise<void> {\n  const {\n    componentMod: ComponentMod,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const { allowEmptyStaticShell = false } = renderOpts\n\n  // These values are placeholder values for this validating render\n  // that are provided during the actual prerenderToStream.\n  const preinitScripts = () => {}\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n\n  const rootParams = getRootParams(\n    ComponentMod.routeModule.userland.loaderTree,\n    getDynamicParamFromSegment\n  )\n\n  const hmrRefreshHash = requestStore.cookies.get(\n    NEXT_HMR_REFRESH_HASH_COOKIE\n  )?.value\n\n  // The prerender controller represents the lifetime of the prerender. It will\n  // be aborted when a task is complete or a synchronously aborting API is\n  // called. Notably, during prospective prerenders, this does not actually\n  // terminate the prerender itself, which will continue until all caches are\n  // filled.\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller is used to abort the React prerender.\n  const initialServerReactController = new AbortController()\n\n  // This controller represents the lifetime of the React prerender. Its signal\n  // can be used for any I/O operation to abort the I/O and/or to reject, when\n  // prerendering aborts. This includes our own hanging promises for accessing\n  // request data, and for fetch calls. It might be replaced in the future by\n  // React.cacheSignal(). It's aborted after the React controller, so that no\n  // pending I/O can register abort listeners that are called before React's\n  // abort listener is called. This ensures that pending I/O is not rejected too\n  // early when aborting the prerender. Notably, during the prospective\n  // prerender, it is different from the prerender controller because we don't\n  // want to end the React prerender until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  // The cacheSignal helps us track whether caches are still filling or we are\n  // ready to cut the render off.\n  const cacheSignal = new CacheSignal()\n\n  const captureOwnerStackClient = React.captureOwnerStack\n  const captureOwnerStackServer = ComponentMod.captureOwnerStack\n\n  // The resume data cache here should use a fresh instance as it's\n  // performing a fresh prerender. If we get to implementing the\n  // prerendering of an already prerendered page, we should use the passed\n  // resume data cache instead.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  const initialServerPayloadPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n    // various request data APIs bind to this controller to reject after completion.\n    renderSignal: initialServerRenderController.signal,\n    // When we generate the RSC payload we might abort this controller due to sync IO\n    // but we don't actually care about sync IO in this phase so we use a throw away controller\n    // that isn't connected to anything\n    controller: new AbortController(),\n    // During the initial prerender we need to track all cache reads to ensure\n    // we render long enough to fill every cache it is possible to visit during\n    // the final prerender.\n    cacheSignal,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    captureOwnerStack: captureOwnerStackServer,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const initialServerPayload = await workUnitAsyncStorage.run(\n    initialServerPayloadPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const initialServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    // During the initial prerender we need to track all cache reads to ensure\n    // we render long enough to fill every cache it is possible to visit during\n    // the final prerender.\n    cacheSignal,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    captureOwnerStack: captureOwnerStackServer,\n  }\n\n  const pendingInitialServerResult = workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    ComponentMod.prerender,\n    initialServerPayload,\n    clientReferenceManifest.clientModules,\n    {\n      filterStackFrame,\n      onError: (err) => {\n        const digest = getDigestForWellKnownError(err)\n\n        if (digest) {\n          return digest\n        }\n\n        if (isReactLargeShellError(err)) {\n          // TODO: Aggregate\n          console.error(err)\n          return undefined\n        }\n\n        if (initialServerPrerenderController.signal.aborted) {\n          // The render aborted before this error was handled which indicates\n          // the error is caused by unfinished components within the render\n          return\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          printDebugThrownValueForProspectiveRender(err, workStore.route)\n        }\n      },\n      // we don't care to track postpones during the prospective render because we need\n      // to always do a final render anyway\n      onPostpone: undefined,\n      // We don't want to stop rendering until the cacheSignal is complete so we pass\n      // a different signal to this render call than is used by dynamic APIs to signify\n      // transitioning out of the prerender environment\n      signal: initialServerReactController.signal,\n    }\n  )\n\n  // The listener to abort our own render controller must be added after React\n  // has added its listener, to ensure that pending I/O is not aborted/rejected\n  // too early.\n  initialServerReactController.signal.addEventListener(\n    'abort',\n    () => {\n      initialServerRenderController.abort()\n    },\n    { once: true }\n  )\n\n  // Wait for all caches to be finished filling and for async imports to resolve\n  trackPendingModules(cacheSignal)\n  await cacheSignal.cacheReady()\n\n  initialServerReactController.abort()\n\n  // We don't need to continue the prerender process if we already\n  // detected invalid dynamic usage in the initial prerender phase.\n  const { invalidDynamicUsageError } = workStore\n  if (invalidDynamicUsageError) {\n    resolveValidation(\n      <LogSafely\n        fn={() => {\n          console.error(invalidDynamicUsageError)\n        }}\n      />\n    )\n    return\n  }\n\n  let initialServerResult\n  try {\n    initialServerResult = await createReactServerPrerenderResult(\n      pendingInitialServerResult\n    )\n  } catch (err) {\n    if (\n      initialServerReactController.signal.aborted ||\n      initialServerPrerenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, workStore.route)\n    }\n  }\n\n  if (initialServerResult) {\n    const initialClientPrerenderController = new AbortController()\n    const initialClientReactController = new AbortController()\n    const initialClientRenderController = new AbortController()\n\n    const initialClientPrerenderStore: PrerenderStore = {\n      type: 'prerender-client',\n      phase: 'render',\n      rootParams,\n      fallbackRouteParams,\n      implicitTags,\n      renderSignal: initialClientRenderController.signal,\n      controller: initialClientPrerenderController,\n      // For HTML Generation the only cache tracked activity\n      // is module loading, which has it's own cache signal\n      cacheSignal: null,\n      dynamicTracking: null,\n      allowEmptyStaticShell,\n      revalidate: INFINITE_CACHE,\n      expire: INFINITE_CACHE,\n      stale: INFINITE_CACHE,\n      tags: [...implicitTags.tags],\n      prerenderResumeDataCache,\n      renderResumeDataCache: null,\n      hmrRefreshHash: undefined,\n      captureOwnerStack: captureOwnerStackClient,\n    }\n\n    const prerender = (\n      require('react-dom/static') as typeof import('react-dom/static')\n    ).prerender\n    const pendingInitialClientResult = workUnitAsyncStorage.run(\n      initialClientPrerenderStore,\n      prerender,\n      <App\n        reactServerStream={initialServerResult.asUnclosingStream()}\n        reactDebugStream={undefined}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        nonce={nonce}\n        images={ctx.renderOpts.images}\n      />,\n      {\n        signal: initialClientReactController.signal,\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (isReactLargeShellError(err)) {\n            // TODO: Aggregate\n            console.error(err)\n            return undefined\n          }\n\n          if (initialClientReactController.signal.aborted) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        },\n        // We don't need bootstrap scripts in this prerender\n        // bootstrapScripts: [bootstrapScript],\n      }\n    )\n\n    // The listener to abort our own render controller must be added after React\n    // has added its listener, to ensure that pending I/O is not\n    // aborted/rejected too early.\n    initialClientReactController.signal.addEventListener(\n      'abort',\n      () => {\n        initialClientRenderController.abort()\n      },\n      { once: true }\n    )\n\n    pendingInitialClientResult.catch((err) => {\n      if (\n        initialClientReactController.signal.aborted ||\n        isPrerenderInterruptedError(err)\n      ) {\n        // These are expected errors that might error the prerender. we ignore them.\n      } else if (\n        process.env.NEXT_DEBUG_BUILD ||\n        process.env.__NEXT_VERBOSE_LOGGING\n      ) {\n        // We don't normally log these errors because we are going to retry anyway but\n        // it can be useful for debugging Next.js itself to get visibility here when needed\n        printDebugThrownValueForProspectiveRender(err, workStore.route)\n      }\n    })\n\n    // This is mostly needed for dynamic `import()`s in client components.\n    // Promises passed to client were already awaited above (assuming that they came from cached functions)\n    trackPendingModules(cacheSignal)\n    await cacheSignal.cacheReady()\n    initialClientReactController.abort()\n  }\n\n  const finalServerReactController = new AbortController()\n  const finalServerRenderController = new AbortController()\n\n  const finalServerPayloadPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n    // various request data APIs bind to this controller to reject after completion.\n    renderSignal: finalServerRenderController.signal,\n    // When we generate the RSC payload we might abort this controller due to sync IO\n    // but we don't actually care about sync IO in this phase so we use a throw away controller\n    // that isn't connected to anything\n    controller: new AbortController(),\n    // All caches we could read must already be filled so no tracking is necessary\n    cacheSignal: null,\n    dynamicTracking: null,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    captureOwnerStack: captureOwnerStackServer,\n  }\n\n  const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n    finalServerPayloadPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const serverDynamicTracking = createDynamicTrackingState(\n    false // isDebugDynamicAccesses\n  )\n\n  const finalServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: finalServerRenderController.signal,\n    controller: finalServerReactController,\n    // All caches we could read must already be filled so no tracking is necessary\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    captureOwnerStack: captureOwnerStackServer,\n  }\n\n  const reactServerResult = await createReactServerPrerenderResult(\n    prerenderAndAbortInSequentialTasks(\n      async () => {\n        const pendingPrerenderResult = workUnitAsyncStorage.run(\n          // The store to scope\n          finalServerPrerenderStore,\n          // The function to run\n          ComponentMod.prerender,\n          // ... the arguments for the function to run\n          finalAttemptRSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            filterStackFrame,\n            onError: (err: unknown) => {\n              if (\n                finalServerReactController.signal.aborted &&\n                isPrerenderInterruptedError(err)\n              ) {\n                return err.digest\n              }\n\n              if (isReactLargeShellError(err)) {\n                // TODO: Aggregate\n                console.error(err)\n                return undefined\n              }\n\n              return getDigestForWellKnownError(err)\n            },\n            signal: finalServerReactController.signal,\n          }\n        )\n\n        // The listener to abort our own render controller must be added after\n        // React has added its listener, to ensure that pending I/O is not\n        // aborted/rejected too early.\n        finalServerReactController.signal.addEventListener(\n          'abort',\n          () => {\n            finalServerRenderController.abort()\n          },\n          { once: true }\n        )\n\n        return pendingPrerenderResult\n      },\n      () => {\n        finalServerReactController.abort()\n      }\n    )\n  )\n\n  const clientDynamicTracking = createDynamicTrackingState(\n    false //isDebugDynamicAccesses\n  )\n  const finalClientReactController = new AbortController()\n  const finalClientRenderController = new AbortController()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender-client',\n    phase: 'render',\n    rootParams,\n    fallbackRouteParams,\n    implicitTags,\n    renderSignal: finalClientRenderController.signal,\n    controller: finalClientReactController,\n    // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    allowEmptyStaticShell,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [...implicitTags.tags],\n    prerenderResumeDataCache,\n    renderResumeDataCache: null,\n    hmrRefreshHash,\n    captureOwnerStack: captureOwnerStackClient,\n  }\n\n  let dynamicValidation = createDynamicValidationState()\n\n  try {\n    const prerender = (\n      require('react-dom/static') as typeof import('react-dom/static')\n    ).prerender\n    let { prelude: unprocessedPrelude } =\n      await prerenderAndAbortInSequentialTasks(\n        () => {\n          const pendingFinalClientResult = workUnitAsyncStorage.run(\n            finalClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={reactServerResult.asUnclosingStream()}\n              reactDebugStream={undefined}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            {\n              signal: finalClientReactController.signal,\n              onError: (err: unknown, errorInfo: ErrorInfo) => {\n                if (\n                  isPrerenderInterruptedError(err) ||\n                  finalClientReactController.signal.aborted\n                ) {\n                  const componentStack = errorInfo.componentStack\n                  if (typeof componentStack === 'string') {\n                    trackAllowedDynamicAccess(\n                      workStore,\n                      componentStack,\n                      dynamicValidation,\n                      clientDynamicTracking\n                    )\n                  }\n                  return\n                }\n\n                if (isReactLargeShellError(err)) {\n                  // TODO: Aggregate\n                  console.error(err)\n                  return undefined\n                }\n\n                return getDigestForWellKnownError(err)\n              },\n              // We don't need bootstrap scripts in this prerender\n              // bootstrapScripts: [bootstrapScript],\n            }\n          )\n\n          // The listener to abort our own render controller must be added after\n          // React has added its listener, to ensure that pending I/O is not\n          // aborted/rejected too early.\n          finalClientReactController.signal.addEventListener(\n            'abort',\n            () => {\n              finalClientRenderController.abort()\n            },\n            { once: true }\n          )\n\n          return pendingFinalClientResult\n        },\n        () => {\n          finalClientReactController.abort()\n        }\n      )\n\n    const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)\n    resolveValidation(\n      <LogSafely\n        fn={throwIfDisallowedDynamic.bind(\n          null,\n          workStore,\n          preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n          dynamicValidation,\n          serverDynamicTracking\n        )}\n      />\n    )\n  } catch (thrownValue) {\n    // Even if the root errors we still want to report any cache components errors\n    // that were discovered before the root errored.\n\n    let loggingFunction = throwIfDisallowedDynamic.bind(\n      null,\n      workStore,\n      PreludeState.Errored,\n      dynamicValidation,\n      serverDynamicTracking\n    )\n\n    if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      const originalLoggingFunction = loggingFunction\n      loggingFunction = () => {\n        console.error(\n          'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.'\n        )\n        console.error(thrownValue)\n        originalLoggingFunction()\n      }\n    }\n\n    resolveValidation(<LogSafely fn={loggingFunction} />)\n  }\n}\n\nasync function LogSafely({ fn }: { fn: () => unknown }) {\n  try {\n    await fn()\n  } catch {}\n  return null\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  tree: LoaderTree,\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const {\n    assetPrefix,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    pagePath,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  const {\n    allowEmptyStaticShell = false,\n    basePath,\n    buildManifest,\n    clientReferenceManifest,\n    ComponentMod,\n    crossOrigin,\n    dev = false,\n    experimental,\n    isDebugDynamicAccesses,\n    nextExport = false,\n    onInstrumentationRequestError,\n    page,\n    reactMaxHeadersLength,\n    subresourceIntegrityManifest,\n  } = renderOpts\n\n  assertClientReferenceManifest(clientReferenceManifest)\n\n  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const getServerInsertedMetadata = createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: subresourceIntegrityManifest?.[polyfill],\n        crossOrigin,\n        noModule: true,\n        nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    crossOrigin,\n    subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    dev,\n    nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult: null | ReactServerPrerenderResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  const selectStaleTime = createSelectStaleTime(experimental)\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (experimental.cacheComponents) {\n      /**\n       * cacheComponents with PPR\n       *\n       * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n       * Once we have settled all cache reads we restart the render and abort after a single Task.\n       *\n       * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n       * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n       * and a synchronous abort might prevent us from filling all caches.\n       *\n       * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n       * and the reactServerIsDynamic value to determine how to treat the resulting render\n       */\n\n      // The prerender controller represents the lifetime of the prerender. It\n      // will be aborted when a task is complete or a synchronously aborting API\n      // is called. Notably, during prospective prerenders, this does not\n      // actually terminate the prerender itself, which will continue until all\n      // caches are filled.\n      const initialServerPrerenderController = new AbortController()\n\n      // This controller is used to abort the React prerender.\n      const initialServerReactController = new AbortController()\n\n      // This controller represents the lifetime of the React prerender. Its\n      // signal can be used for any I/O operation to abort the I/O and/or to\n      // reject, when prerendering aborts. This includes our own hanging\n      // promises for accessing request data, and for fetch calls. It might be\n      // replaced in the future by React.cacheSignal(). It's aborted after the\n      // React controller, so that no pending I/O can register abort listeners\n      // that are called before React's abort listener is called. This ensures\n      // that pending I/O is not rejected too early when aborting the prerender.\n      // Notably, during the prospective prerender, it is different from the\n      // prerender controller because we don't want to end the React prerender\n      // until all caches are filled.\n      const initialServerRenderController = new AbortController()\n\n      // The cacheSignal helps us track whether caches are still filling or we are ready\n      // to cut the render off.\n      const cacheSignal = new CacheSignal()\n\n      let resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n      let renderResumeDataCache: RenderResumeDataCache | null = null\n      let prerenderResumeDataCache: PrerenderResumeDataCache | null = null\n\n      if (renderOpts.renderResumeDataCache) {\n        // If a prefilled immutable render resume data cache is provided, e.g.\n        // when prerendering an optional fallback shell after having prerendered\n        // pages with defined params, we use this instead of a prerender resume\n        // data cache.\n        resumeDataCache = renderResumeDataCache =\n          renderOpts.renderResumeDataCache\n      } else {\n        // Otherwise we create a new mutable prerender resume data cache.\n        resumeDataCache = prerenderResumeDataCache =\n          createPrerenderResumeDataCache()\n      }\n\n      const initialServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: initialServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        captureOwnerStack: undefined, // Not available in production.\n      }\n\n      // We're not going to use the result of this render because the only time it could be used\n      // is if it completes in a microtask and that's likely very rare for any non-trivial app\n      const initialServerPayload = await workUnitAsyncStorage.run(\n        initialServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: initialServerRenderController.signal,\n        controller: initialServerPrerenderController,\n        // During the initial prerender we need to track all cache reads to ensure\n        // we render long enough to fill every cache it is possible to visit during\n        // the final prerender.\n        cacheSignal,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        captureOwnerStack: undefined, // Not available in production.\n      })\n\n      const pendingInitialServerResult = workUnitAsyncStorage.run(\n        initialServerPrerenderStore,\n        ComponentMod.prerender,\n        initialServerPayload,\n        clientReferenceManifest.clientModules,\n        {\n          filterStackFrame,\n          onError: (err) => {\n            const digest = getDigestForWellKnownError(err)\n\n            if (digest) {\n              return digest\n            }\n\n            if (isReactLargeShellError(err)) {\n              // TODO: Aggregate\n              console.error(err)\n              return undefined\n            }\n\n            if (initialServerPrerenderController.signal.aborted) {\n              // The render aborted before this error was handled which indicates\n              // the error is caused by unfinished components within the render\n              return\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              printDebugThrownValueForProspectiveRender(err, workStore.route)\n            }\n          },\n          // we don't care to track postpones during the prospective render because we need\n          // to always do a final render anyway\n          onPostpone: undefined,\n          // We don't want to stop rendering until the cacheSignal is complete so we pass\n          // a different signal to this render call than is used by dynamic APIs to signify\n          // transitioning out of the prerender environment\n          signal: initialServerReactController.signal,\n        }\n      )\n\n      // The listener to abort our own render controller must be added after\n      // React has added its listener, to ensure that pending I/O is not\n      // aborted/rejected too early.\n      initialServerReactController.signal.addEventListener(\n        'abort',\n        () => {\n          initialServerRenderController.abort()\n          initialServerPrerenderController.abort()\n        },\n        { once: true }\n      )\n\n      // Wait for all caches to be finished filling and for async imports to resolve\n      trackPendingModules(cacheSignal)\n      await cacheSignal.cacheReady()\n\n      initialServerReactController.abort()\n\n      // We don't need to continue the prerender process if we already\n      // detected invalid dynamic usage in the initial prerender phase.\n      if (workStore.invalidDynamicUsageError) {\n        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n        throw new StaticGenBailoutError()\n      }\n\n      let initialServerResult\n      try {\n        initialServerResult = await createReactServerPrerenderResult(\n          pendingInitialServerResult\n        )\n      } catch (err) {\n        if (\n          initialServerReactController.signal.aborted ||\n          initialServerPrerenderController.signal.aborted\n        ) {\n          // These are expected errors that might error the prerender. we ignore them.\n        } else if (\n          process.env.NEXT_DEBUG_BUILD ||\n          process.env.__NEXT_VERBOSE_LOGGING\n        ) {\n          // We don't normally log these errors because we are going to retry anyway but\n          // it can be useful for debugging Next.js itself to get visibility here when needed\n          printDebugThrownValueForProspectiveRender(err, workStore.route)\n        }\n      }\n\n      if (initialServerResult) {\n        const initialClientPrerenderController = new AbortController()\n        const initialClientReactController = new AbortController()\n        const initialClientRenderController = new AbortController()\n\n        const initialClientPrerenderStore: PrerenderStore = {\n          type: 'prerender-client',\n          phase: 'render',\n          rootParams,\n          fallbackRouteParams,\n          implicitTags,\n          renderSignal: initialClientRenderController.signal,\n          controller: initialClientPrerenderController,\n          // For HTML Generation the only cache tracked activity\n          // is module loading, which has it's own cache signal\n          cacheSignal: null,\n          dynamicTracking: null,\n          allowEmptyStaticShell,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          renderResumeDataCache,\n          hmrRefreshHash: undefined,\n          captureOwnerStack: undefined, // Not available in production.\n        }\n\n        const prerender = (\n          require('react-dom/static') as typeof import('react-dom/static')\n        ).prerender\n        const pendingInitialClientResult = workUnitAsyncStorage.run(\n          initialClientPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={initialServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            signal: initialClientReactController.signal,\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (isReactLargeShellError(err)) {\n                // TODO: Aggregate\n                console.error(err)\n                return undefined\n              }\n\n              if (initialClientReactController.signal.aborted) {\n                // These are expected errors that might error the prerender. we ignore them.\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                // We don't normally log these errors because we are going to retry anyway but\n                // it can be useful for debugging Next.js itself to get visibility here when needed\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            },\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n\n        // The listener to abort our own render controller must be added after\n        // React has added its listener, to ensure that pending I/O is not\n        // aborted/rejected too early.\n        initialClientReactController.signal.addEventListener(\n          'abort',\n          () => {\n            initialClientRenderController.abort()\n          },\n          { once: true }\n        )\n\n        pendingInitialClientResult.catch((err) => {\n          if (\n            initialClientReactController.signal.aborted ||\n            isPrerenderInterruptedError(err)\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        })\n\n        // This is mostly needed for dynamic `import()`s in client components.\n        // Promises passed to client were already awaited above (assuming that they came from cached functions)\n        trackPendingModules(cacheSignal)\n        await cacheSignal.cacheReady()\n        initialClientReactController.abort()\n      }\n\n      const finalServerReactController = new AbortController()\n      const finalServerRenderController = new AbortController()\n\n      const finalServerPayloadPrerenderStore: PrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n        // various request data APIs bind to this controller to reject after completion.\n        renderSignal: finalServerRenderController.signal,\n        // When we generate the RSC payload we might abort this controller due to sync IO\n        // but we don't actually care about sync IO in this phase so we use a throw away controller\n        // that isn't connected to anything\n        controller: new AbortController(),\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: null,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        captureOwnerStack: undefined, // Not available in production.\n      }\n\n      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n        finalServerPayloadPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const serverDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n      let serverIsDynamic = false\n\n      const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalServerRenderController.signal,\n        controller: finalServerReactController,\n        // All caches we could read must already be filled so no tracking is necessary\n        cacheSignal: null,\n        dynamicTracking: serverDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        captureOwnerStack: undefined, // Not available in production.\n      })\n\n      let prerenderIsPending = true\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResult(\n          prerenderAndAbortInSequentialTasks(\n            async () => {\n              const pendingPrerenderResult = workUnitAsyncStorage.run(\n                // The store to scope\n                finalServerPrerenderStore,\n                // The function to run\n                ComponentMod.prerender,\n                // ... the arguments for the function to run\n                finalAttemptRSCPayload,\n                clientReferenceManifest.clientModules,\n                {\n                  filterStackFrame,\n                  onError: (err: unknown) => {\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerReactController.signal,\n                }\n              )\n\n              // The listener to abort our own render controller must be added\n              // after React has added its listener, to ensure that pending I/O\n              // is not aborted/rejected too early.\n              finalServerReactController.signal.addEventListener(\n                'abort',\n                () => {\n                  finalServerRenderController.abort()\n                },\n                { once: true }\n              )\n\n              const prerenderResult = await pendingPrerenderResult\n              prerenderIsPending = false\n\n              return prerenderResult\n            },\n            () => {\n              if (finalServerReactController.signal.aborted) {\n                // If the server controller is already aborted we must have called something\n                // that required aborting the prerender synchronously such as with new Date()\n                serverIsDynamic = true\n                return\n              }\n\n              if (prerenderIsPending) {\n                // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                // there is something unfinished.\n                serverIsDynamic = true\n              }\n\n              finalServerReactController.abort()\n            }\n          )\n        ))\n\n      const clientDynamicTracking = createDynamicTrackingState(\n        isDebugDynamicAccesses\n      )\n\n      const finalClientReactController = new AbortController()\n      const finalClientRenderController = new AbortController()\n\n      const finalClientPrerenderStore: PrerenderStore = {\n        type: 'prerender-client',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        renderSignal: finalClientRenderController.signal,\n        controller: finalClientReactController,\n        // No APIs require a cacheSignal through the workUnitStore during the HTML prerender\n        cacheSignal: null,\n        dynamicTracking: clientDynamicTracking,\n        allowEmptyStaticShell,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n        renderResumeDataCache,\n        hmrRefreshHash: undefined,\n        captureOwnerStack: undefined, // Not available in production.\n      }\n\n      let dynamicValidation = createDynamicValidationState()\n\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      let { prelude: unprocessedPrelude, postponed } =\n        await prerenderAndAbortInSequentialTasks(\n          () => {\n            const pendingFinalClientResult = workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                reactDebugStream={undefined}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={nonce}\n                images={ctx.renderOpts.images}\n              />,\n              {\n                signal: finalClientReactController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientReactController.signal.aborted\n                  ) {\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore,\n                        componentStack,\n                        dynamicValidation,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            )\n\n            // The listener to abort our own render controller must be added\n            // after React has added its listener, to ensure that pending I/O is\n            // not aborted/rejected too early.\n            finalClientReactController.signal.addEventListener(\n              'abort',\n              () => {\n                finalClientRenderController.abort()\n              },\n              { once: true }\n            )\n\n            return pendingFinalClientResult\n          },\n          () => {\n            finalClientReactController.abort()\n          }\n        )\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      // If we've disabled throwing on empty static shell, then we don't need to\n      // track any dynamic access that occurs above the suspense boundary because\n      // we'll do so in the route shell.\n      if (!allowEmptyStaticShell) {\n        throwIfDisallowedDynamic(\n          workStore,\n          preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n          dynamicValidation,\n          serverDynamicTracking\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n      metadata.flightData = flightData\n      metadata.segmentData = await collectSegmentData(\n        flightData,\n        finalServerPrerenderStore,\n        ComponentMod,\n        renderOpts\n      )\n\n      // If there are fallback route params, the RSC data is inherently dynamic\n      // today because it's encoded into the flight router state. Until we can\n      // move the fallback route params out of the flight router state, we need\n      // to always perform a dynamic resume after the static prerender.\n      const hasFallbackRouteParams =\n        fallbackRouteParams && fallbackRouteParams.size > 0\n\n      if (serverIsDynamic || hasFallbackRouteParams) {\n        // Dynamic case\n        // We will always need to perform a \"resume\" render of some kind when this route is accessed\n        // because the RSC data itself is dynamic. We determine if there are any HTML holes or not\n        // but generally this is a \"partial\" prerender in that there will be a per-request compute\n        // concatenated to the static shell.\n        if (postponed != null) {\n          // Dynamic HTML case\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            resumeDataCache,\n            experimental.cacheComponents\n          )\n        } else {\n          // Dynamic Data case\n          metadata.postponed = await getDynamicDataPostponedState(\n            resumeDataCache,\n            experimental.cacheComponents\n          )\n        }\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),\n        }\n      } else {\n        // Static case\n        // We will not perform resumption per request. The result can be served statically to the requestor\n        // and if there was anything dynamic it will only be rendered in the browser.\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n          renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),\n        }\n      }\n    } else if (experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(isDebugDynamicAccesses)\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        fallbackRouteParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      }\n      const prerender = (\n        require('react-dom/static') as typeof import('react-dom/static')\n      ).prerender\n      const { prelude: unprocessedPrelude, postponed } =\n        await workUnitAsyncStorage.run(\n          ssrPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={reactServerResult.asUnclosingStream()}\n            reactDebugStream={undefined}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={nonce}\n            images={ctx.renderOpts.images}\n          />,\n          {\n            onError: htmlRendererErrorHandler,\n            onHeaders: (headers: Headers) => {\n              headers.forEach((value, key) => {\n                appendHeader(key, value)\n              })\n            },\n            maxHeadersLength: reactMaxHeadersLength,\n            bootstrapScripts: [bootstrapScript],\n          }\n        )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const { prelude, preludeIsEmpty } =\n        await processPrelude(unprocessedPrelude)\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            preludeIsEmpty\n              ? DynamicHTMLPreludeState.Empty\n              : DynamicHTMLPreludeState.Full,\n            fallbackRouteParams,\n            prerenderResumeDataCache,\n            experimental.cacheComponents\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache,\n            experimental.cacheComponents\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache,\n          experimental.cacheComponents\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = (\n            require('react-dom/server') as typeof import('react-dom/server')\n          ).resume\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              reactDebugStream={undefined}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createRenderInBrowserAbortSignal(),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            isBuildTimePrerendering:\n              ctx.workStore.isBuildTimePrerendering === true,\n            buildId: ctx.workStore.buildId,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              filterStackFrame,\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = (\n        require('react-dom/server') as typeof import('react-dom/server')\n      ).renderToReadableStream\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          reactDebugStream={undefined}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={nonce}\n          images={ctx.renderOpts.images}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: selectStaleTime(prerenderLegacyStore.stale),\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n      metadata.statusCode = res.statusCode\n\n      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n      metadata.statusCode = res.statusCode\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      buildManifest,\n      assetPrefix,\n      crossOrigin,\n      subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        filterStackFrame,\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      // TODO we should use the same prerender semantics that we initially rendered\n      // with in this case too. The only reason why this is ok atm is because it's essentially\n      // an empty page and no user code runs.\n      const fizzStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer:\n            require('react-dom/server') as typeof import('react-dom/server'),\n          element: (\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              reactDebugStream={undefined}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={nonce}\n              images={ctx.renderOpts.images}\n            />\n          ),\n          streamOptions: {\n            nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts\n        )\n      }\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream = reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          isBuildTimePrerendering:\n            ctx.workStore.isBuildTimePrerendering === true,\n          buildId: ctx.workStore.buildId,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout: dev,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale: selectStaleTime(\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE\n        ),\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<{\n  GlobalError: GlobalErrorComponent\n  styles: React.ReactNode | undefined\n}> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  const GlobalErrorComponent: GlobalErrorComponent =\n    ctx.componentMod.GlobalError\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n  if (ctx.renderOpts.dev) {\n    const dir =\n      (process.env.NEXT_RUNTIME === 'edge'\n        ? process.env.__NEXT_EDGE_PROJECT_DIR\n        : ctx.renderOpts.dir) || ''\n\n    const globalErrorModulePath = normalizeConventionFilePath(\n      dir,\n      globalErrorModule?.[1]\n    )\n    if (globalErrorModulePath) {\n      const SegmentViewNode = ctx.componentMod.SegmentViewNode\n      globalErrorStyles = (\n        // This will be rendered next to GlobalError component under ErrorBoundary,\n        // it requires a key to avoid React warning about duplicate keys.\n        <SegmentViewNode\n          key=\"ge-svn\"\n          type=\"global-error\"\n          pagePath={globalErrorModulePath}\n        >\n          {globalErrorStyles}\n        </SegmentViewNode>\n      )\n    }\n  }\n\n  return {\n    GlobalError: GlobalErrorComponent,\n    styles: globalErrorStyles,\n  }\n}\n\nfunction createSelectStaleTime(experimental: ExperimentalConfig) {\n  return (stale: number) =>\n    stale === INFINITE_CACHE &&\n    typeof experimental.staleTimes?.static === 'number'\n      ? experimental.staleTimes.static\n      : stale\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const clientReferenceManifest = renderOpts.clientReferenceManifest\n  if (\n    !clientReferenceManifest ||\n    // Do not generate per-segment data unless the experimental Segment Cache\n    // flag is enabled.\n    //\n    // We also skip generating segment data if flag is set to \"client-only\",\n    // rather than true. (The \"client-only\" option only affects the behavior of\n    // the client-side implementation; per-segment prefetches are intentionally\n    // disabled in that configuration).\n    renderOpts.experimental.clientSegmentCache !== true\n  ) {\n    return\n  }\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  const selectStaleTime = createSelectStaleTime(renderOpts.experimental)\n  const staleTime = selectStaleTime(prerenderStore.stale)\n  return await ComponentMod.collectSegmentData(\n    renderOpts.experimental.clientParamParsing,\n    fullPageDataBuffer,\n    staleTime,\n    clientReferenceManifest.clientModules as ManifestNode,\n    serverConsumerManifest\n  )\n}\n"],"names":["renderToHTMLOrFlight","flightDataPathHeadKey","getFlightViewportKey","requestId","getFlightMetadataKey","filterStackFrame","process","env","NODE_ENV","require","filterStackFrameDEV","undefined","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","NEXT_ROUTER_PREFETCH_HEADER","isRuntimePrefetchRequest","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","isRSCRequest","RSC_HEADER","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE_HEADER","isRouteTreePrefetchRequest","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","csp","nonce","getScriptNonceFromHeader","previouslyRevalidatedTags","getPreviouslyRevalidatedTags","previewModeId","htmlRequestId","NEXT_REQUEST_ID_HEADER","NEXT_HTML_REQUEST_ID_HEADER","createNotFoundLoaderTree","loaderTree","components","hasGlobalNotFound","notFoundTreeComponents","layout","page","children","PAGE_SEGMENT_KEY","makeGetDynamicParamFromSegment","interpolatedParams","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","getSegmentParam","segmentKey","param","dynamicParamType","dynamicParamTypes","type","getDynamicParam","NonIndex","pagePath","statusCode","isPossibleServerAction","is404Page","isInvalidStatusCode","meta","name","content","generateDynamicRSCPayload","ctx","flightData","componentMod","routeModule","userland","createMetadataComponents","query","workStore","url","serveStreamingMetadata","renderOpts","skipFlight","preloadCallbacks","Viewport","Metadata","MetadataOutlet","tree","parsedQuery","pathname","metadataContext","createMetadataContext","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","rscHead","React","Fragment","res","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","map","path","slice","actionResult","a","f","b","sharedContext","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","getRevalidateReason","generateDynamicFlightRenderResult","req","requestStore","clientReferenceManifest","dev","onInstrumentationRequestError","setReactDebugChannel","onFlightDataRenderError","err","onError","createFlightReactServerErrorHandler","RSCPayload","workUnitAsyncStorage","run","debugChannel","createDebugChannel","clientSide","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","serverSide","FlightRenderResult","fetchMetrics","generateRuntimePrefetchResult","metadata","generatePayload","rootParams","getRootParams","prerenderResumeDataCache","createPrerenderResumeDataCache","renderResumeDataCache","prospectiveRuntimeServerPrerender","cookies","draftMode","response","finalRuntimeServerPrerender","applyMetadataFromPrerenderResult","isPartial","setHeader","NEXT_DID_POSTPONE_HEADER","result","prelude","getPayload","implicitTags","ComponentMod","assertClientReferenceManifest","initialServerPrerenderController","AbortController","initialServerRenderController","cacheSignal","CacheSignal","initialServerPrerenderStore","phase","renderSignal","signal","controller","dynamicTracking","revalidate","expire","stale","INFINITE_CACHE","tags","hmrRefreshHash","captureOwnerStack","runtimeStagePromise","initialServerPayload","pendingInitialServerResult","prerender","digest","getDigestForWellKnownError","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","printDebugThrownValueForProspectiveRender","route","onPostpone","trackPendingModules","cacheReady","abort","invalidDynamicUsageError","createReactServerPrerenderResult","experimental","isDebugDynamicAccesses","selectStaleTime","createSelectStaleTime","serverIsDynamic","finalServerController","serverDynamicTracking","createDynamicTrackingState","promise","resolve","resolveBlockedRuntimeAPIs","createPromiseWithResolvers","finalServerPrerenderStore","finalRSCPayload","prerenderIsPending","prerenderAndAbortInSequentialTasksWithStages","prerenderResult","dynamicAccess","collectedRevalidate","collectedExpire","collectedStale","collectedTags","warmupDevRender","allowEmptyStaticShell","InvariantError","renderController","prerenderController","reactController","prerenderStore","NEXT_HMR_REFRESH_HASH_COOKIE","rscPayload","createRenderResumeDataCache","prepareInitialCanonicalUrl","search","split","getRSCPayload","is404","missingSlots","appUsingSizeAdjustment","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","createComponentTree","authInterrupts","varyHeader","getHeader","couldBeIntercepted","includes","NEXT_URL","initialHead","GlobalError","styles","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","c","i","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","ssrError","isError","Error","html","id","head","body","template","data-next-error-message","message","data-next-error-digest","data-next-error-stack","stack","App","reactServerStream","reactDebugStream","preinitScripts","ServerInsertedHTMLProvider","images","use","useFlightStream","initialState","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","Map","location","prerendered","actionQueue","createMutableActionQueue","HeadManagerContext","Provider","value","appDir","ImageConfigContext","imageConfigDefault","AppRouter","globalErrorState","ErrorApp","renderToHTMLOrFlightImpl","parsedRequestHeaders","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","nextFontManifest","serverActions","assetPrefix","enableTainting","__next_app__","instrumented","wrapClientComponentLoader","shouldTrackModuleLoading","cacheComponents","workUnitStore","getStore","__next_require__","args","exportsOrPromise","trackPendingImport","globalThis","__next_chunk_load__","loadingChunk","loadChunk","trackPendingChunkLoad","setIsrStatus","URL","NEXT_RUNTIME","isNodeNextRequest","onClose","shouldTrackFetchMetrics","originalRequest","on","metrics","getClientComponentLoaderMetrics","reset","getTracer","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","appUsingSizeAdjust","serverModuleMap","createServerModuleMap","setReferenceManifestsSingleton","patchFetch","taintObjectReference","stripInternalQueries","Buffer","from","crypto","subtle","toString","randomUUID","nanoid","isPossibleActionRequest","getIsPossibleServerAction","getImplicitTags","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","AppRenderSpan","getBodyResult","spanName","prerenderToStream","accessedDynamicData","warn","access","formatDynamicAPIAccesses","logDisallowedDynamicError","StaticGenBailoutError","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","length","find","isUserLandError","contentType","HTML_CONTENT_TYPE_HEADER","pendingRevalidates","pendingRevalidateWrites","pendingRevalidatedTags","pendingPromise","executeRevalidates","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","waitUntil","RenderResult","streamToString","stream","devValidatingFallbackParams","getRequestMeta","createRequestStoreForRender","onUpdateCookies","previewProps","isStatic","usedDynamic","forceDynamic","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","handleAction","generateFlight","notFoundLoaderTree","assignMetadata","parseRelativeUrl","interpolateParallelRouteParams","params","parsePostponedState","createWorkStore","definition","workAsyncStorage","fetchTags","join","staleHeader","String","NEXT_ROUTER_STALE_TIME_HEADER","forceStatic","cacheControl","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","basePath","buildManifest","crossOrigin","nextExport","reactMaxHeadersLength","shouldWaitOnAllReady","subresourceIntegrityManifest","supportsDynamicResponse","renderServerInsertedHTML","createServerInsertedHTML","getServerInsertedMetadata","createServerInsertedMetadata","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","noModule","bootstrapScript","getRequiredScripts","bootstrapScriptContent","JSON","stringify","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","createHTMLReactServerErrorHandler","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","createHTMLErrorHandler","reactServerResult","bind","appendHeader","resolveValidation","validationOutlet","createValidationOutlet","_validation","readableSsr","readableBrowser","readable","tee","scheduleInSequentialTasks","prerenderPhase","environmentName","consoleAsyncStorage","dim","spawnDynamicValidationInDev","ReactServerResult","waitAtLeastOneReactRenderTask","DynamicState","DATA","inlinedReactServerDataStream","createInlinedDataReadableStream","chainStreams","createDocumentClosingStream","preludeState","getPostponedFromState","resume","htmlStream","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","continueDynamicHTMLResume","delayDataUntilFirstHtmlChunk","DynamicHTMLPreludeState","Empty","inlinedDataStream","consume","onHeaders","key","maxHeadersLength","bootstrapScripts","generateStaticHTML","continueFizzStream","isBuildTimePrerendering","validateRootLayout","isStaticGenBailoutError","shouldBailoutToCSR","isBailoutToCSRError","getStackWithoutErrorMessage","error","reason","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isRedirectError","getRedirectStatusCodeFromError","redirectUrl","addPathPrefix","getURLFromRedirectError","Headers","appendMutableCookies","mutableCookies","Array","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","has","errorServerStream","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","readableController","clientSideReadable","ReadableStream","start","writable","WritableStream","write","chunk","enqueue","close","outlet","Promise","isNotFound","get","initialServerReactController","captureOwnerStackClient","captureOwnerStackServer","initialServerPayloadPrerenderStore","isReactLargeShellError","addEventListener","once","LogSafely","fn","initialServerResult","initialClientPrerenderController","initialClientReactController","initialClientRenderController","initialClientPrerenderStore","pendingInitialClientResult","asUnclosingStream","catch","isPrerenderInterruptedError","finalServerReactController","finalServerRenderController","finalServerPayloadPrerenderStore","finalAttemptRSCPayload","prerenderAndAbortInSequentialTasks","pendingPrerenderResult","clientDynamicTracking","finalClientReactController","finalClientRenderController","finalClientPrerenderStore","dynamicValidation","createDynamicValidationState","unprocessedPrelude","pendingFinalClientResult","errorInfo","componentStack","trackAllowedDynamicAccess","preludeIsEmpty","processPrelude","throwIfDisallowedDynamic","PreludeState","Full","thrownValue","loggingFunction","Errored","originalLoggingFunction","shouldGenerateStaticFlightData","reactServerPrerenderResult","setMetadataHeader","isArray","item","resumeDataCache","streamToBuffer","asStream","segmentData","collectSegmentData","hasFallbackRouteParams","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","consumeDynamicAccess","foreverStream","resumeStream","parse","createRenderInBrowserAbortSignal","continueStaticPrerender","consumeAsStream","reactServerPrerenderStore","createReactServerPrerenderResultFromRender","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","isDynamicServerError","flightStream","modules","globalErrorModule","parseLoaderTree","GlobalErrorComponent","createComponentStylesAndScripts","filePath","getComponent","dir","__NEXT_EDGE_PROJECT_DIR","globalErrorModulePath","normalizeConventionFilePath","SegmentViewNode","staleTimes","static","fullPageDataBuffer","clientSegmentCache","isEdgeRuntime","serverConsumerManifest","moduleLoading","moduleMap","edgeRscModuleMapping","rscModuleMapping","getServerModuleMap","staleTime","clientParamParsing"],"mappings":"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","ignoreList":[0]}