/**
 * MCP tool for retrieving browser error state.
 *
 * This tool demonstrates server-to-browser communication in Next.js dev mode.
 * It leverages the existing HMR infrastructure rather than creating new channels.
 *
 * Flow:
 *   MCP client → server generates request ID → HMR message to browser →
 *   browser queries error overlay state → HMR response back → server performs source mapping →
 *   formatted output.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleErrorStateResponse: null,
    registerGetErrorsTool: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleErrorStateResponse: function() {
        return handleErrorStateResponse;
    },
    registerGetErrorsTool: function() {
        return registerGetErrorsTool;
    }
});
const _hotreloadertypes = require("../../dev/hot-reloader-types");
const _formaterrors = require("./utils/format-errors");
const _browsercommunication = require("./utils/browser-communication");
function registerGetErrorsTool(server, sendHmrMessage, getActiveConnectionCount) {
    server.registerTool('get_errors', {
        description: 'Get the current error state of the app when rendered in the browser, including any build or runtime errors with source-mapped stack traces',
        inputSchema: {}
    }, async (_request)=>{
        try {
            const connectionCount = getActiveConnectionCount();
            if (connectionCount === 0) {
                return {
                    content: [
                        {
                            type: 'text',
                            text: 'No browser sessions connected. Please open your application in a browser to retrieve error state.'
                        }
                    ]
                };
            }
            const responses = await (0, _browsercommunication.createBrowserRequest)(_hotreloadertypes.HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE, sendHmrMessage, getActiveConnectionCount, _browsercommunication.DEFAULT_BROWSER_REQUEST_TIMEOUT_MS);
            const errorsByUrl = new Map();
            for (const response of responses){
                if (response.data) {
                    errorsByUrl.set(response.url, response.data);
                }
            }
            const hasErrors = Array.from(errorsByUrl.values()).some((state)=>state.errors.length > 0 || !!state.buildError);
            if (!hasErrors) {
                return {
                    content: [
                        {
                            type: 'text',
                            text: responses.length === 0 ? 'No browser sessions responded.' : `No errors detected in ${responses.length} browser session(s).`
                        }
                    ]
                };
            }
            const output = await (0, _formaterrors.formatErrors)(errorsByUrl);
            return {
                content: [
                    {
                        type: 'text',
                        text: output
                    }
                ]
            };
        } catch (error) {
            return {
                content: [
                    {
                        type: 'text',
                        text: `Error: ${error instanceof Error ? error.message : String(error)}`
                    }
                ]
            };
        }
    });
}
function handleErrorStateResponse(requestId, errorState, url) {
    (0, _browsercommunication.handleBrowserPageResponse)(requestId, errorState, url || '');
}

//# sourceMappingURL=get-errors.js.map