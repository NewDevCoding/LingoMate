{"version":3,"sources":["../../../../../src/server/mcp/tools/utils/format-errors.ts"],"sourcesContent":["import type { OverlayState } from '../../../../next-devtools/dev-overlay/shared'\nimport type { SupportedErrorEvent } from '../../../../next-devtools/dev-overlay/container/runtime-error/render-error'\nimport { getErrorSource } from '../../../../shared/lib/error-source'\nimport type {\n  OriginalStackFramesRequest,\n  OriginalStackFramesResponse,\n} from '../../../../next-devtools/server/shared'\n\ntype StackFrameForFormatting = {\n  file: string | null\n  methodName: string\n  line1: number | null\n  column1: number | null\n}\n\ntype StackFrameResolver = (\n  request: OriginalStackFramesRequest\n) => Promise<OriginalStackFramesResponse>\n\n// Dependency injection for stack frame resolver\nlet stackFrameResolver: StackFrameResolver | undefined\n\nexport function setStackFrameResolver(fn: StackFrameResolver) {\n  stackFrameResolver = fn\n}\n\nasync function resolveStackFrames(\n  request: OriginalStackFramesRequest\n): Promise<OriginalStackFramesResponse> {\n  if (!stackFrameResolver) {\n    throw new Error(\n      'Stack frame resolver not initialized. This is a bug in Next.js.'\n    )\n  }\n  return stackFrameResolver(request)\n}\n\nconst formatStackFrame = (frame: StackFrameForFormatting): string => {\n  const file = frame.file || '<unknown>'\n  const method = frame.methodName || '<anonymous>'\n  const { line1: line, column1: column } = frame\n  return line && column\n    ? `  at ${method} (${file}:${line}:${column})`\n    : line\n      ? `  at ${method} (${file}:${line})`\n      : `  at ${method} (${file})`\n}\n\nconst formatErrorFrames = async (\n  frames: readonly StackFrameForFormatting[],\n  context: {\n    isServer: boolean\n    isEdgeServer: boolean\n    isAppDirectory: boolean\n  }\n): Promise<string> => {\n  try {\n    const resolvedFrames = await resolveStackFrames({\n      frames: frames.map((frame) => ({\n        file: frame.file || null,\n        methodName: frame.methodName || '<anonymous>',\n        arguments: [],\n        line1: frame.line1 || null,\n        column1: frame.column1 || null,\n      })),\n      isServer: context.isServer,\n      isEdgeServer: context.isEdgeServer,\n      isAppDirectory: context.isAppDirectory,\n    })\n\n    return (\n      resolvedFrames\n        .filter(\n          (resolvedFrame) =>\n            !(\n              resolvedFrame.status === 'fulfilled' &&\n              resolvedFrame.value.originalStackFrame?.ignored\n            )\n        )\n        .map((resolvedFrame, j) =>\n          resolvedFrame.status === 'fulfilled' &&\n          resolvedFrame.value.originalStackFrame\n            ? formatStackFrame(resolvedFrame.value.originalStackFrame)\n            : formatStackFrame(frames[j])\n        )\n        .join('\\n') + '\\n'\n    )\n  } catch {\n    return frames.map(formatStackFrame).join('\\n') + '\\n'\n  }\n}\n\nasync function formatRuntimeError(\n  errors: readonly SupportedErrorEvent[],\n  isAppDirectory: boolean\n): Promise<string> {\n  const formatError = async (\n    error: SupportedErrorEvent,\n    index: number\n  ): Promise<string> => {\n    const errorHeader = `\\n#### Error ${index + 1} (Type: ${error.type})\\n\\n`\n    const errorName = error.error?.name || 'Error'\n    const errorMsg = error.error?.message || 'Unknown error'\n    const errorMessage = `**${errorName}**: ${errorMsg}\\n\\n`\n\n    if (!error.frames?.length) {\n      const stack = error.error?.stack || ''\n      return (\n        errorHeader + errorMessage + (stack ? `\\`\\`\\`\\n${stack}\\n\\`\\`\\`\\n` : '')\n      )\n    }\n\n    const errorSource = getErrorSource(error.error)\n    const frames = await formatErrorFrames(error.frames, {\n      isServer: errorSource === 'server',\n      isEdgeServer: errorSource === 'edge-server',\n      isAppDirectory,\n    })\n\n    return errorHeader + errorMessage + `\\`\\`\\`\\n${frames}\\`\\`\\`\\n`\n  }\n\n  const formattedErrors = await Promise.all(errors.map(formatError))\n  return '### Runtime Errors\\n' + formattedErrors.join('\\n---\\n')\n}\n\nexport async function formatErrors(\n  errorsByUrl: Map<string, OverlayState>\n): Promise<string> {\n  let output = `# Found errors in ${errorsByUrl.size} browser session(s)\\n\\n`\n\n  for (const [url, overlayState] of errorsByUrl) {\n    const totalErrorCount =\n      overlayState.errors.length + (overlayState.buildError ? 1 : 0)\n\n    if (totalErrorCount === 0) continue\n\n    let displayUrl = url\n    try {\n      const urlObj = new URL(url)\n      displayUrl = urlObj.pathname + urlObj.search + urlObj.hash\n    } catch {\n      // If URL parsing fails, use the original URL\n    }\n\n    output += `## Session: ${displayUrl}\\n\\n`\n    output += `**${totalErrorCount} error(s) found**\\n\\n`\n\n    // Build errors\n    if (overlayState.buildError) {\n      output += '### Build Error\\n\\n'\n      output += '```\\n'\n      output += overlayState.buildError\n      output += '\\n```\\n\\n'\n    }\n\n    // Runtime errors with source-mapped stack traces\n    if (overlayState.errors.length > 0) {\n      const runtimeErrors = await formatRuntimeError(\n        overlayState.errors,\n        overlayState.routerType === 'app'\n      )\n      output += runtimeErrors\n      output += '\\n'\n    }\n\n    output += '---\\n\\n'\n  }\n\n  return output.trim()\n}\n"],"names":["formatErrors","setStackFrameResolver","stackFrameResolver","fn","resolveStackFrames","request","Error","formatStackFrame","frame","file","method","methodName","line1","line","column1","column","formatErrorFrames","frames","context","resolvedFrames","map","arguments","isServer","isEdgeServer","isAppDirectory","filter","resolvedFrame","status","value","originalStackFrame","ignored","j","join","formatRuntimeError","errors","formatError","error","index","errorHeader","type","errorName","name","errorMsg","message","errorMessage","length","stack","errorSource","getErrorSource","formattedErrors","Promise","all","errorsByUrl","output","size","url","overlayState","totalErrorCount","buildError","displayUrl","urlObj","URL","pathname","search","hash","runtimeErrors","routerType","trim"],"mappings":"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","ignoreList":[0]}