{"version":3,"sources":["../../../../src/server/mcp/tools/get-errors.ts"],"sourcesContent":["/**\n * MCP tool for retrieving browser error state.\n *\n * This tool demonstrates server-to-browser communication in Next.js dev mode.\n * It leverages the existing HMR infrastructure rather than creating new channels.\n *\n * Flow:\n *   MCP client → server generates request ID → HMR message to browser →\n *   browser queries error overlay state → HMR response back → server performs source mapping →\n *   formatted output.\n */\nimport type { McpServer } from 'next/dist/compiled/@modelcontextprotocol/sdk/server/mcp'\nimport type { OverlayState } from '../../../next-devtools/dev-overlay/shared'\nimport {\n  HMR_MESSAGE_SENT_TO_BROWSER,\n  type HmrMessageSentToBrowser,\n} from '../../dev/hot-reloader-types'\nimport { formatErrors } from './utils/format-errors'\nimport {\n  createBrowserRequest,\n  handleBrowserPageResponse,\n  DEFAULT_BROWSER_REQUEST_TIMEOUT_MS,\n} from './utils/browser-communication'\n\nexport function registerGetErrorsTool(\n  server: McpServer,\n  sendHmrMessage: (message: HmrMessageSentToBrowser) => void,\n  getActiveConnectionCount: () => number\n) {\n  server.registerTool(\n    'get_errors',\n    {\n      description:\n        'Get the current error state of the app when rendered in the browser, including any build or runtime errors with source-mapped stack traces',\n      inputSchema: {},\n    },\n    async (_request) => {\n      try {\n        const connectionCount = getActiveConnectionCount()\n        if (connectionCount === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'No browser sessions connected. Please open your application in a browser to retrieve error state.',\n              },\n            ],\n          }\n        }\n\n        const responses = await createBrowserRequest<OverlayState>(\n          HMR_MESSAGE_SENT_TO_BROWSER.REQUEST_CURRENT_ERROR_STATE,\n          sendHmrMessage,\n          getActiveConnectionCount,\n          DEFAULT_BROWSER_REQUEST_TIMEOUT_MS\n        )\n\n        const errorsByUrl = new Map<string, OverlayState>()\n        for (const response of responses) {\n          if (response.data) {\n            errorsByUrl.set(response.url, response.data)\n          }\n        }\n\n        const hasErrors = Array.from(errorsByUrl.values()).some(\n          (state) => state.errors.length > 0 || !!state.buildError\n        )\n\n        if (!hasErrors) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text:\n                  responses.length === 0\n                    ? 'No browser sessions responded.'\n                    : `No errors detected in ${responses.length} browser session(s).`,\n              },\n            ],\n          }\n        }\n\n        const output = await formatErrors(errorsByUrl)\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: output,\n            },\n          ],\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n        }\n      }\n    }\n  )\n}\n\n// Browser will first receive an HMR message from server to send back its error state.\n// The actual state is sent back in a subsequent HMR message, which is handled by this function\n// on the server.\nexport function handleErrorStateResponse(\n  requestId: string,\n  errorState: OverlayState | null,\n  url: string | undefined\n) {\n  handleBrowserPageResponse<OverlayState | null>(\n    requestId,\n    errorState,\n    url || ''\n  )\n}\n"],"names":["handleErrorStateResponse","registerGetErrorsTool","server","sendHmrMessage","getActiveConnectionCount","registerTool","description","inputSchema","_request","connectionCount","content","type","text","responses","createBrowserRequest","HMR_MESSAGE_SENT_TO_BROWSER","REQUEST_CURRENT_ERROR_STATE","DEFAULT_BROWSER_REQUEST_TIMEOUT_MS","errorsByUrl","Map","response","data","set","url","hasErrors","Array","from","values","some","state","errors","length","buildError","output","formatErrors","error","Error","message","String","requestId","errorState","handleBrowserPageResponse"],"mappings":"AAAA;;;;;;;;;;CAUC;;;;;;;;;;;;;;;IAmGeA,wBAAwB;eAAxBA;;IArFAC,qBAAqB;eAArBA;;;kCART;8BACsB;sCAKtB;AAEA,SAASA,sBACdC,MAAiB,EACjBC,cAA0D,EAC1DC,wBAAsC;IAEtCF,OAAOG,YAAY,CACjB,cACA;QACEC,aACE;QACFC,aAAa,CAAC;IAChB,GACA,OAAOC;QACL,IAAI;YACF,MAAMC,kBAAkBL;YACxB,IAAIK,oBAAoB,GAAG;gBACzB,OAAO;oBACLC,SAAS;wBACP;4BACEC,MAAM;4BACNC,MAAM;wBACR;qBACD;gBACH;YACF;YAEA,MAAMC,YAAY,MAAMC,IAAAA,0CAAoB,EAC1CC,6CAA2B,CAACC,2BAA2B,EACvDb,gBACAC,0BACAa,wDAAkC;YAGpC,MAAMC,cAAc,IAAIC;YACxB,KAAK,MAAMC,YAAYP,UAAW;gBAChC,IAAIO,SAASC,IAAI,EAAE;oBACjBH,YAAYI,GAAG,CAACF,SAASG,GAAG,EAAEH,SAASC,IAAI;gBAC7C;YACF;YAEA,MAAMG,YAAYC,MAAMC,IAAI,CAACR,YAAYS,MAAM,IAAIC,IAAI,CACrD,CAACC,QAAUA,MAAMC,MAAM,CAACC,MAAM,GAAG,KAAK,CAAC,CAACF,MAAMG,UAAU;YAG1D,IAAI,CAACR,WAAW;gBACd,OAAO;oBACLd,SAAS;wBACP;4BACEC,MAAM;4BACNC,MACEC,UAAUkB,MAAM,KAAK,IACjB,mCACA,CAAC,sBAAsB,EAAElB,UAAUkB,MAAM,CAAC,oBAAoB,CAAC;wBACvE;qBACD;gBACH;YACF;YAEA,MAAME,SAAS,MAAMC,IAAAA,0BAAY,EAAChB;YAElC,OAAO;gBACLR,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAMqB;oBACR;iBACD;YACH;QACF,EAAE,OAAOE,OAAO;YACd,OAAO;gBACLzB,SAAS;oBACP;wBACEC,MAAM;wBACNC,MAAM,CAAC,OAAO,EAAEuB,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH,QAAQ;oBAC1E;iBACD;YACH;QACF;IACF;AAEJ;AAKO,SAASnC,yBACduC,SAAiB,EACjBC,UAA+B,EAC/BjB,GAAuB;IAEvBkB,IAAAA,+CAAyB,EACvBF,WACAC,YACAjB,OAAO;AAEX","ignoreList":[0]}