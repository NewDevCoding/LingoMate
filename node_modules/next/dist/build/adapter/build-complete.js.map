{"version":3,"sources":["../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { MiddlewareMatcher } from '../analysis/get-page-static-info'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  ManifestRoute,\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestHeaderRoute,\n  ManifestRewriteRoute,\n  ManifestRedirectRoute,\n  FunctionsConfigManifest,\n} from '..'\n\nimport {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC\n       */\n      filePath: string\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState?: string\n    }\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: MiddlewareMatcher[]\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: MiddlewareMatcher[]\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routes: {\n      headers: Array<ManifestHeaderRoute>\n      redirects: Array<ManifestRedirectRoute>\n      rewrites: {\n        beforeFiles: Array<ManifestRewriteRoute>\n        afterFiles: Array<ManifestRewriteRoute>\n        fallback: Array<ManifestRewriteRoute>\n      }\n      dynamicRoutes: ReadonlyArray<ManifestRoute>\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n      ...(outputs.middleware ? [outputs.middleware] : []),\n    ]) {\n      output.pathname = addPathPrefix(output.pathname, config.basePath)\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  routesManifest,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  distDir: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json')\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.page.startsWith('app/')\n        const isAppPage = isAppPrefix && page.page.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.page.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          pathname: isAppPrefix ? normalizeAppPath(page.name) : page.name,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            ...(type === AdapterOutputType.MIDDLEWARE\n              ? {\n                  matchers: page.matchers,\n                }\n              : {}),\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.join(\n            path.relative(tracingRoot, distDir),\n            file\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          handleFile(item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = item.filePath\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(\n          pagesDistDir,\n          `${normalizePagePath(page)}.js`\n        )\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n              outputs.staticFiles.push({\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE'])\n            }\n          } else {\n            outputs.staticFiles.push({\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE'])\n          }\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n          if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n            Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n          }\n          return {} as Record<string, string>\n        })\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n        } else {\n          outputs.pagesApi.push(output)\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace)\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers: functionConfig.matchers,\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n            return {} as Record<string, string>\n          })\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: {\n          postponed?: string\n          segmentPaths?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const segmentsDir = path.join(\n            appDistDir,\n            `${route}${prefetchSegmentDirSuffix}`\n          )\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(\n                appDistDir,\n                route + prefetchSegmentDirSuffix,\n                segmentPath\n              ) + prefetchSegmentSuffix\n\n            const fallbackPathname = path.join(\n              segmentsDir,\n              segmentPath + prefetchSegmentSuffix\n            )\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            if (keyLower !== key) {\n              const value = meta.headers[key]\n              delete meta.headers[key]\n              meta.headers[keyLower] = value\n            }\n          }\n        }\n\n        return meta\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          prefetchDataRoute,\n          dataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(srcRoute)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${route === '/' ? 'index' : route}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          filePath = path.join(pagesDistDir, '404.html')\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && config.experimental.ppr\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  initialStatus,\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate: initialRevalidate || 1,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (dataRoute) {\n          let dataFilePath = path.join(\n            pagesDistDir,\n            `${route === '/' ? 'index' : route}.json`\n          )\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              prefetchDataRoute &&\n                renderingMode === RenderingMode.PARTIALLY_STATIC\n                ? prefetchDataRoute\n                : dataRoute\n            )\n          }\n\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: isNotFoundTrue\n              ? undefined\n              : {\n                  ...initialOutput.fallback,\n                  initialHeaders: {\n                    ...initialOutput.fallback?.initialHeaders,\n                    'content-type': isAppPage\n                      ? rscContentTypeHeader\n                      : JSON_CONTENT_TYPE_HEADER,\n                  },\n                  filePath: dataFilePath,\n                },\n          })\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta)\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n          groupId: prerenderGroupId,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  initialStatus: fallbackStatus,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate || 1,\n                }\n              : undefined,\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (isAppPage) {\n          await handleAppMeta(dynamicRoute, initialOutput, meta)\n        }\n\n        if (dataRoute) {\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: undefined,\n          })\n        }\n        prerenderGroupId += 1\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    try {\n      await adapterMod.onBuildComplete({\n        routes: {\n          dynamicRoutes: routesManifest.dynamicRoutes,\n          rewrites: routesManifest.rewrites,\n          redirects: routesManifest.redirects,\n          headers: routesManifest.headers,\n        },\n        outputs,\n\n        config,\n        distDir,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["handleBuildComplete","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","middleware","pathname","addPathPrefix","dir","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","routesManifest","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","interopDefault","pathToFileURL","require","resolve","href","onBuildComplete","Log","info","name","exportFiles","recursiveReadDir","file","endsWith","replace","startsWith","push","id","filePath","path","join","type","AdapterOutputType","STATIC_FILE","posix","sharedNodeAssets","fileOutputPath","relative","assets","handleTraceFiles","Object","assign","traceFilePath","traceData","JSON","parse","fs","readFile","traceFileDir","dirname","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","runtime","normalizeAppPath","find","item","wasmAssets","matchers","env","handleFile","originalPath","wasm","edgeFunctionHandlers","values","isMiddlewareFilename","functions","pagesDistDir","pageOutputMap","hasOwnProperty","route","normalizePagePath","pageFile","has","i18n","locale","locales","localePage","pageTraceFile","catch","err","code","warn","functionConfig","maxDuration","preferredRegion","regions","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","normalizeLocalePath","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","postponed","fallback","postponedState","segmentPaths","segmentsDir","segmentPath","outputSegmentPath","fallbackPathname","PRERENDER","parentOutputId","groupId","initialExpiration","initialRevalidate","initialHeaders","vary","prerenderGroupId","getAppRouteMeta","headers","key","keyLower","toLowerCase","value","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","prefetchDataRoute","dataRoute","renderingMode","allowHeader","experimentalBypassFor","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","dynamicRoutes","isDynamicRoute","pprChain","experimental","ppr","NEXT_RESUME_HEADER","undefined","HTML_CONTENT_TYPE_HEADER","bypassFor","bypassToken","preview","previewModeId","dataFilePath","RenderingMode","PARTIALLY_STATIC","JSON_CONTENT_TYPE_HEADER","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","rewrites","redirects","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}