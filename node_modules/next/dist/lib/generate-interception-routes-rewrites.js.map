{"version":3,"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n  INTERCEPTION_ROUTE_MARKERS,\n} from '../shared/lib/router/utils/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport {\n  getSegmentParam,\n  isCatchAll,\n} from '../shared/lib/router/utils/get-segment-param'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport { escapeStringRegexp } from '../shared/lib/escape-regexp'\n\n/**\n * Detects which interception marker is used in the app path\n */\nfunction getInterceptionMarker(\n  appPath: string\n): (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined {\n  for (const segment of appPath.split('/')) {\n    const marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      return marker\n    }\n  }\n  return undefined\n}\n\n/**\n * Generates a regex pattern that matches routes at the same level as the intercepting route.\n * For (.) same-level interception, we need to match:\n * - The intercepting route itself\n * - Any direct child of the intercepting route\n * But NOT deeper nested routes\n */\nfunction generateSameLevelHeaderRegex(\n  interceptingRoute: string,\n  reference: Record<string, string>\n): string {\n  // Build the pattern for matching the intercepting route and its direct children\n  const segments =\n    interceptingRoute === '/'\n      ? []\n      : interceptingRoute.split('/').filter(Boolean)\n\n  const patterns: string[] = []\n  const optionalIndices: number[] = []\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    const param = getSegmentParam(segment)\n    if (param) {\n      // Dynamic segment - use named capture group\n      // Use the reference mapping which has the correct param -> prefixedKey mapping\n      const prefixedKey = reference[param.param]\n      if (!prefixedKey) {\n        throw new InvariantError(\n          `No reference found for param: ${param.param} in reference: ${JSON.stringify(reference)}`\n        )\n      }\n\n      // Check if this is a catchall (repeat) parameter\n      if (isCatchAll(param.type)) {\n        patterns.push(`(?<${prefixedKey}>.+?)`)\n        // Track optional catchall segments so we can wrap them later\n        if (param.type === 'optional-catchall') {\n          optionalIndices.push(i)\n        }\n      } else {\n        patterns.push(`(?<${prefixedKey}>[^/]+?)`)\n      }\n    } else {\n      // Static segment\n      patterns.push(escapeStringRegexp(segment))\n    }\n  }\n\n  // Build the header regex, wrapping optional catchall segments\n  let pattern = ''\n  for (let i = 0; i < patterns.length; i++) {\n    if (optionalIndices.includes(i)) {\n      // Optional catchall: wrap the segment with its leading / in an optional group\n      pattern += `(?:/${patterns[i]})?`\n    } else {\n      pattern += `/${patterns[i]}`\n    }\n  }\n\n  // Match the pattern, optionally followed by a single segment, with optional trailing slash\n  // Note: Don't add ^ and $ anchors here - matchHas() will add them automatically\n  return `${pattern}(/[^/]+)?/?`\n}\n\n/**\n * Check if there's a catchall route sibling at the intercepting route level.\n * For example, if interceptingRoute is '/templates', this checks for\n * '/templates/[...catchAll]'.\n */\nfunction hasCatchallSiblingAtLevel(\n  appPaths: string[],\n  interceptingRoute: string\n): boolean {\n  const targetSegments =\n    interceptingRoute === '/'\n      ? []\n      : interceptingRoute.split('/').filter(Boolean)\n  const targetDepth = targetSegments.length\n\n  return appPaths.some((path) => {\n    const segments = path.split('/').filter(Boolean)\n\n    // Check if this path is at the same depth + 1 (parent segments + the catchall segment)\n    if (segments.length !== targetDepth + 1) {\n      return false\n    }\n\n    // Check if the first targetDepth segments match exactly\n    for (let i = 0; i < targetDepth; i++) {\n      // Skip interception routes\n      if (\n        INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n          segments[i].startsWith(marker)\n        )\n      ) {\n        return false\n      }\n\n      if (segments[i] !== targetSegments[i]) {\n        return false\n      }\n    }\n\n    // Check if the last segment is a catchall parameter\n    const lastSegment = segments[segments.length - 1]\n    const param = getSegmentParam(lastSegment)\n    return param !== null && isCatchAll(param.type)\n  })\n}\n\n/**\n * Generates the appropriate header regex based on the interception marker type.\n * @param marker The interception route marker (e.g., '(.)', '(..)'))\n * @param interceptingRoute The route that intercepts (e.g., '/templates')\n * @param headerReference The reference mapping from param names to prefixed keys\n * @param appPaths All app paths (used for catchall sibling detection)\n * @param defaultHeaderRegex The default regex to use if no marker-specific logic applies\n * @returns The header regex pattern to match against the Next-URL header\n */\nfunction generateInterceptionHeaderRegex(\n  marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n  interceptingRoute: string,\n  headerReference: Record<string, string>,\n  appPaths: string[],\n  defaultHeaderRegex: string\n): string {\n  // Generate the appropriate header regex based on the marker type\n  let headerRegex: string\n  if (marker === '(.)') {\n    // For same-level interception, match routes at the same level as the intercepting route\n    // Use header.reference which has the param -> prefixedKey mapping\n    headerRegex = generateSameLevelHeaderRegex(\n      interceptingRoute,\n      headerReference\n    )\n  } else if (marker === '(..)') {\n    // For parent-level interception, match routes at the intercepting route level\n    // Check if there's a catchall sibling at the intercepting route level\n    const hasCatchallSibling = hasCatchallSiblingAtLevel(\n      appPaths,\n      interceptingRoute\n    )\n\n    // Build regex pattern that handles dynamic segments correctly\n    const patterns: string[] = []\n    const optionalIndices: number[] = []\n\n    const segments = interceptingRoute.split('/').filter(Boolean)\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i]\n      const param = getSegmentParam(segment)\n      if (param) {\n        // Dynamic segment - use named capture group from header.reference\n        const key = headerReference[param.param]\n        if (!key) {\n          throw new InvariantError(\n            `No reference found for param: ${param.param} in reference: ${JSON.stringify(headerReference)}`\n          )\n        }\n\n        // Check if this is a catchall (repeat) parameter\n        if (isCatchAll(param.type)) {\n          patterns.push(`(?<${key}>.+?)`)\n          // Track optional catchall segments so we can wrap them later\n          if (param.type === 'optional-catchall') {\n            optionalIndices.push(i)\n          }\n        } else {\n          patterns.push(`(?<${key}>[^/]+?)`)\n        }\n      } else {\n        // Static segment\n        patterns.push(escapeStringRegexp(segment))\n      }\n    }\n\n    // Build the header regex, wrapping optional catchall segments\n    let headerPattern = ''\n    for (let i = 0; i < patterns.length; i++) {\n      if (optionalIndices.includes(i)) {\n        // Optional catchall: wrap the segment with its leading / in an optional group\n        headerPattern += `(?:/${patterns[i]})?`\n      } else {\n        headerPattern += `/${patterns[i]}`\n      }\n    }\n\n    // Note: Don't add ^ and $ anchors - matchHas() will add them automatically\n    // If there's a catchall sibling, match the level and its children (catchall paths)\n    // Otherwise, only match the exact level\n    headerRegex = `${headerPattern}${hasCatchallSibling ? '(/.+)?' : ''}`\n  } else {\n    // For other markers, use the default behavior (match exact intercepting route)\n    // Strip ^ and $ anchors since matchHas() will add them automatically\n    headerRegex = defaultHeaderRegex\n  }\n\n  return headerRegex\n}\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      // Detect which marker is being used\n      const marker = getInterceptionMarker(appPath)\n\n      // The Next-Url header does not contain the base path, so just use the\n      // intercepting route. We don't handle duplicate keys here with the\n      // backreferenceDuplicateKeys option because it's not a valid pathname\n      // with them in this case.\n      const header = getNamedRouteRegex(interceptingRoute, {\n        prefixRouteKeys: true,\n      })\n\n      // The source is the intercepted route with the base path, it's matched by\n      // the router. Generate this first to get the correct parameter prefixes.\n      // We don't handle duplicate keys here with the backreferenceDuplicateKeys\n      // option because it's not a valid pathname with them in this case.\n      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n        prefixRouteKeys: true,\n      })\n\n      // The destination should use the same parameter reference as the source\n      // so that parameter substitution works correctly. This ensures that when\n      // the router extracts params from the source, they can be substituted\n      // into the destination. We don't handle duplicate keys here with the\n      // backreferenceDuplicateKeys option because we don't use the regexp\n      // itself in this case, only the pathToRegexpPattern.\n      const destination = getNamedRouteRegex(basePath + appPath, {\n        prefixRouteKeys: true,\n        reference: source.reference,\n      })\n\n      // Generate the header regex based on the interception marker type\n      const headerRegex = generateInterceptionHeaderRegex(\n        marker,\n        interceptingRoute,\n        header.reference,\n        appPaths,\n        header.namedRegex.replace(/^\\^/, '').replace(/\\$$/, '')\n      )\n\n      rewrites.push({\n        source: source.pathToRegexpPattern,\n        destination: destination.pathToRegexpPattern,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: headerRegex,\n          },\n        ],\n        internal: true,\n        regex: source.namedRegex,\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: DeepReadonly<Rewrite>) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["generateInterceptionRoutesRewrites","isInterceptionRouteRewrite","getInterceptionMarker","appPath","segment","split","marker","INTERCEPTION_ROUTE_MARKERS","find","m","startsWith","undefined","generateSameLevelHeaderRegex","interceptingRoute","reference","segments","filter","Boolean","patterns","optionalIndices","i","length","param","getSegmentParam","prefixedKey","InvariantError","JSON","stringify","isCatchAll","type","push","escapeStringRegexp","pattern","includes","hasCatchallSiblingAtLevel","appPaths","targetSegments","targetDepth","some","path","lastSegment","generateInterceptionHeaderRegex","headerReference","defaultHeaderRegex","headerRegex","hasCatchallSibling","key","headerPattern","basePath","rewrites","isInterceptionRouteAppPath","interceptedRoute","extractInterceptionRouteInformation","header","getNamedRouteRegex","prefixRouteKeys","source","destination","namedRegex","replace","pathToRegexpPattern","has","NEXT_URL","value","internal","regex","route"],"mappings":"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","ignoreList":[0]}