{"version":3,"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n  INTERCEPTION_ROUTE_MARKERS,\n} from '../shared/lib/router/utils/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport {\n  getSegmentParam,\n  isCatchAll,\n} from '../shared/lib/router/utils/get-segment-param'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport { escapeStringRegexp } from '../shared/lib/escape-regexp'\n\n/**\n * Detects which interception marker is used in the app path\n */\nfunction getInterceptionMarker(\n  appPath: string\n): (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined {\n  for (const segment of appPath.split('/')) {\n    const marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      return marker\n    }\n  }\n  return undefined\n}\n\n/**\n * Generates a regex pattern that matches routes at the same level as the intercepting route.\n * For (.) same-level interception, we need to match:\n * - The intercepting route itself\n * - Any direct child of the intercepting route\n * But NOT deeper nested routes\n */\nfunction generateSameLevelHeaderRegex(\n  interceptingRoute: string,\n  reference: Record<string, string>\n): string {\n  // Build the pattern for matching the intercepting route and its direct children\n  const segments =\n    interceptingRoute === '/'\n      ? []\n      : interceptingRoute.split('/').filter(Boolean)\n\n  const patterns: string[] = []\n  const optionalIndices: number[] = []\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    const param = getSegmentParam(segment)\n    if (param) {\n      // Dynamic segment - use named capture group\n      // Use the reference mapping which has the correct param -> prefixedKey mapping\n      const prefixedKey = reference[param.param]\n      if (!prefixedKey) {\n        throw new InvariantError(\n          `No reference found for param: ${param.param} in reference: ${JSON.stringify(reference)}`\n        )\n      }\n\n      // Check if this is a catchall (repeat) parameter\n      if (isCatchAll(param.type)) {\n        patterns.push(`(?<${prefixedKey}>.+?)`)\n        // Track optional catchall segments so we can wrap them later\n        if (param.type === 'optional-catchall') {\n          optionalIndices.push(i)\n        }\n      } else {\n        patterns.push(`(?<${prefixedKey}>[^/]+?)`)\n      }\n    } else {\n      // Static segment\n      patterns.push(escapeStringRegexp(segment))\n    }\n  }\n\n  // Build the header regex, wrapping optional catchall segments\n  let pattern = ''\n  for (let i = 0; i < patterns.length; i++) {\n    if (optionalIndices.includes(i)) {\n      // Optional catchall: wrap the segment with its leading / in an optional group\n      pattern += `(?:/${patterns[i]})?`\n    } else {\n      pattern += `/${patterns[i]}`\n    }\n  }\n\n  // Match the pattern, optionally followed by a single segment, with optional trailing slash\n  // Note: Don't add ^ and $ anchors here - matchHas() will add them automatically\n  return `${pattern}(/[^/]+)?/?`\n}\n\n/**\n * Check if there's a catchall route sibling at the intercepting route level.\n * For example, if interceptingRoute is '/templates', this checks for\n * '/templates/[...catchAll]'.\n */\nfunction hasCatchallSiblingAtLevel(\n  appPaths: string[],\n  interceptingRoute: string\n): boolean {\n  const targetSegments =\n    interceptingRoute === '/'\n      ? []\n      : interceptingRoute.split('/').filter(Boolean)\n  const targetDepth = targetSegments.length\n\n  return appPaths.some((path) => {\n    const segments = path.split('/').filter(Boolean)\n\n    // Check if this path is at the same depth + 1 (parent segments + the catchall segment)\n    if (segments.length !== targetDepth + 1) {\n      return false\n    }\n\n    // Check if the first targetDepth segments match exactly\n    for (let i = 0; i < targetDepth; i++) {\n      // Skip interception routes\n      if (\n        INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n          segments[i].startsWith(marker)\n        )\n      ) {\n        return false\n      }\n\n      if (segments[i] !== targetSegments[i]) {\n        return false\n      }\n    }\n\n    // Check if the last segment is a catchall parameter\n    const lastSegment = segments[segments.length - 1]\n    const param = getSegmentParam(lastSegment)\n    return param !== null && isCatchAll(param.type)\n  })\n}\n\n/**\n * Generates the appropriate header regex based on the interception marker type.\n * @param marker The interception route marker (e.g., '(.)', '(..)'))\n * @param interceptingRoute The route that intercepts (e.g., '/templates')\n * @param headerReference The reference mapping from param names to prefixed keys\n * @param appPaths All app paths (used for catchall sibling detection)\n * @param defaultHeaderRegex The default regex to use if no marker-specific logic applies\n * @returns The header regex pattern to match against the Next-URL header\n */\nfunction generateInterceptionHeaderRegex(\n  marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n  interceptingRoute: string,\n  headerReference: Record<string, string>,\n  appPaths: string[],\n  defaultHeaderRegex: string\n): string {\n  // Generate the appropriate header regex based on the marker type\n  let headerRegex: string\n  if (marker === '(.)') {\n    // For same-level interception, match routes at the same level as the intercepting route\n    // Use header.reference which has the param -> prefixedKey mapping\n    headerRegex = generateSameLevelHeaderRegex(\n      interceptingRoute,\n      headerReference\n    )\n  } else if (marker === '(..)') {\n    // For parent-level interception, match routes at the intercepting route level\n    // Check if there's a catchall sibling at the intercepting route level\n    const hasCatchallSibling = hasCatchallSiblingAtLevel(\n      appPaths,\n      interceptingRoute\n    )\n\n    // Build regex pattern that handles dynamic segments correctly\n    const patterns: string[] = []\n    const optionalIndices: number[] = []\n\n    const segments = interceptingRoute.split('/').filter(Boolean)\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i]\n      const param = getSegmentParam(segment)\n      if (param) {\n        // Dynamic segment - use named capture group from header.reference\n        const key = headerReference[param.param]\n        if (!key) {\n          throw new InvariantError(\n            `No reference found for param: ${param.param} in reference: ${JSON.stringify(headerReference)}`\n          )\n        }\n\n        // Check if this is a catchall (repeat) parameter\n        if (isCatchAll(param.type)) {\n          patterns.push(`(?<${key}>.+?)`)\n          // Track optional catchall segments so we can wrap them later\n          if (param.type === 'optional-catchall') {\n            optionalIndices.push(i)\n          }\n        } else {\n          patterns.push(`(?<${key}>[^/]+?)`)\n        }\n      } else {\n        // Static segment\n        patterns.push(escapeStringRegexp(segment))\n      }\n    }\n\n    // Build the header regex, wrapping optional catchall segments\n    let headerPattern = ''\n    for (let i = 0; i < patterns.length; i++) {\n      if (optionalIndices.includes(i)) {\n        // Optional catchall: wrap the segment with its leading / in an optional group\n        headerPattern += `(?:/${patterns[i]})?`\n      } else {\n        headerPattern += `/${patterns[i]}`\n      }\n    }\n\n    // Note: Don't add ^ and $ anchors - matchHas() will add them automatically\n    // If there's a catchall sibling, match the level and its children (catchall paths)\n    // Otherwise, only match the exact level\n    headerRegex = `${headerPattern}${hasCatchallSibling ? '(/.+)?' : ''}`\n  } else {\n    // For other markers, use the default behavior (match exact intercepting route)\n    // Strip ^ and $ anchors since matchHas() will add them automatically\n    headerRegex = defaultHeaderRegex\n  }\n\n  return headerRegex\n}\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      // Detect which marker is being used\n      const marker = getInterceptionMarker(appPath)\n\n      // The Next-Url header does not contain the base path, so just use the\n      // intercepting route. We don't handle duplicate keys here with the\n      // backreferenceDuplicateKeys option because it's not a valid pathname\n      // with them in this case.\n      const header = getNamedRouteRegex(interceptingRoute, {\n        prefixRouteKeys: true,\n      })\n\n      // The source is the intercepted route with the base path, it's matched by\n      // the router. Generate this first to get the correct parameter prefixes.\n      // We don't handle duplicate keys here with the backreferenceDuplicateKeys\n      // option because it's not a valid pathname with them in this case.\n      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n        prefixRouteKeys: true,\n      })\n\n      // The destination should use the same parameter reference as the source\n      // so that parameter substitution works correctly. This ensures that when\n      // the router extracts params from the source, they can be substituted\n      // into the destination. We don't handle duplicate keys here with the\n      // backreferenceDuplicateKeys option because we don't use the regexp\n      // itself in this case, only the pathToRegexpPattern.\n      const destination = getNamedRouteRegex(basePath + appPath, {\n        prefixRouteKeys: true,\n        reference: source.reference,\n      })\n\n      // Generate the header regex based on the interception marker type\n      const headerRegex = generateInterceptionHeaderRegex(\n        marker,\n        interceptingRoute,\n        header.reference,\n        appPaths,\n        header.namedRegex.replace(/^\\^/, '').replace(/\\$$/, '')\n      )\n\n      rewrites.push({\n        source: source.pathToRegexpPattern,\n        destination: destination.pathToRegexpPattern,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: headerRegex,\n          },\n        ],\n        internal: true,\n        regex: source.namedRegex,\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: DeepReadonly<Rewrite>) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["NEXT_URL","extractInterceptionRouteInformation","isInterceptionRouteAppPath","INTERCEPTION_ROUTE_MARKERS","getNamedRouteRegex","getSegmentParam","isCatchAll","InvariantError","escapeStringRegexp","getInterceptionMarker","appPath","segment","split","marker","find","m","startsWith","undefined","generateSameLevelHeaderRegex","interceptingRoute","reference","segments","filter","Boolean","patterns","optionalIndices","i","length","param","prefixedKey","JSON","stringify","type","push","pattern","includes","hasCatchallSiblingAtLevel","appPaths","targetSegments","targetDepth","some","path","lastSegment","generateInterceptionHeaderRegex","headerReference","defaultHeaderRegex","headerRegex","hasCatchallSibling","key","headerPattern","generateInterceptionRoutesRewrites","basePath","rewrites","interceptedRoute","header","prefixRouteKeys","source","destination","namedRegex","replace","pathToRegexpPattern","has","value","internal","regex","isInterceptionRouteRewrite","route"],"mappings":"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","ignoreList":[0]}