{"version":3,"sources":["../../../src/build/adapter/build-complete.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { pathToFileURL } from 'url'\nimport * as Log from '../output/log'\nimport { isMiddlewareFilename } from '../utils'\nimport { RenderingMode } from '../rendering-mode'\nimport { interopDefault } from '../../lib/interop-default'\nimport type { RouteHas } from '../../lib/load-custom-routes'\nimport { recursiveReadDir } from '../../lib/recursive-readdir'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { Revalidate } from '../../server/lib/cache-control'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { MiddlewareMatcher } from '../analysis/get-page-static-info'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { AdapterOutputType, type PHASE_TYPE } from '../../shared/lib/constants'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n\nimport type {\n  MiddlewareManifest,\n  EdgeFunctionDefinition,\n} from '../webpack/plugins/middleware-plugin'\n\nimport type {\n  ManifestRoute,\n  RoutesManifest,\n  PrerenderManifest,\n  ManifestHeaderRoute,\n  ManifestRewriteRoute,\n  ManifestRedirectRoute,\n  FunctionsConfigManifest,\n} from '..'\n\nimport {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\nimport { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\n\ninterface SharedRouteFields {\n  /**\n   * id is the unique identifier of the output\n   */\n  id: string\n  /**\n   * filePath is the location on disk of the built entrypoint asset\n   */\n  filePath: string\n  /**\n   * pathname is the URL pathname the asset should be served at\n   */\n  pathname: string\n  /**\n   * runtime is which runtime the entrypoint is built for\n   */\n  runtime: 'nodejs' | 'edge'\n  /**\n   * assets are all necessary traced assets that could be\n   * loaded by the output to handle a request e.g. traced\n   * node_modules or necessary manifests for Next.js.\n   * The key is the relative path from the repo root and the value\n   * is the absolute path to the file\n   */\n  assets: Record<string, string>\n\n  /**\n   * wasmAssets are bundled wasm files with mapping of name\n   * to filePath on disk\n   */\n  wasmAssets?: Record<string, string>\n\n  /**\n   * config related to the route\n   */\n  config: {\n    /**\n     * maxDuration is a segment config to signal the max\n     * execution duration a route should be allowed before\n     * it's timed out\n     */\n    maxDuration?: number\n    /**\n     * preferredRegion is a segment config to signal deployment\n     * region preferences to the provider being used\n     */\n    preferredRegion?: string | string[]\n\n    /**\n     * env is the environment variables to expose, this is only\n     * populated for edge runtime currently\n     */\n    env?: Record<string, string>\n  }\n}\n\nexport interface AdapterOutput {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES: SharedRouteFields & {\n    type: AdapterOutputType.PAGES\n  }\n\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API: SharedRouteFields & {\n    type: AdapterOutputType.PAGES_API\n  }\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE: SharedRouteFields & {\n    type: AdapterOutputType.APP_PAGE\n  }\n\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE: SharedRouteFields & {\n    type: AdapterOutputType.APP_ROUTE\n  }\n\n  /**\n   * `PRERENDER` represents an ISR enabled route that might\n   * have a seeded cache entry or fallback generated during build\n   */\n  PRERENDER: {\n    id: string\n    pathname: string\n    type: AdapterOutputType.PRERENDER\n\n    /**\n     * For prerenders the parent output is the originating\n     * page that the prerender is created from\n     */\n    parentOutputId: string\n\n    /**\n     * groupId is the identifier for a group of prerenders that should be\n     * revalidated together\n     */\n    groupId: number\n\n    pprChain?: {\n      headers: Record<string, string>\n    }\n\n    /**\n     * fallback is initial cache data generated during build for a prerender\n     */\n    fallback?: {\n      /**\n       * path to the fallback file can be HTML/JSON/RSC\n       */\n      filePath: string\n      /**\n       * initialStatus is the status code that should be applied\n       * when serving the fallback\n       */\n      initialStatus?: number\n      /**\n       * initialHeaders are the headers that should be sent when\n       * serving the fallback\n       */\n      initialHeaders?: Record<string, string | string[]>\n      /**\n       * initial expiration is how long until the fallback entry\n       * is considered expired and no longer valid to serve\n       */\n      initialExpiration?: number\n      /**\n       * initial revalidate is how long until the fallback is\n       * considered stale and should be revalidated\n       */\n      initialRevalidate?: Revalidate\n\n      /**\n       * postponedState is the PPR state when it postponed and is used for resuming\n       */\n      postponedState?: string\n    }\n    /**\n     * config related to the route\n     */\n    config: {\n      /**\n       * allowQuery is the allowed query values to be passed\n       * to an ISR function and what should be considered for the cacheKey\n       * e.g. for /blog/[slug], \"slug\" is the only allowQuery\n       */\n      allowQuery?: string[]\n      /**\n       * allowHeader is the allowed headers to be passed to an\n       * ISR function to prevent accidentally poisoning the cache\n       * from leaking additional information that can impact the render\n       */\n      allowHeader?: string[]\n      /**\n       * bypass for is a list of has conditions the cache\n       * should be bypassed and invoked directly e.g. action header\n       */\n      bypassFor?: RouteHas[]\n      /**\n       * renderingMode signals PPR or not for a prerender\n       */\n      renderingMode?: RenderingMode\n\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: MiddlewareMatcher[]\n\n      /**\n       * bypassToken is the generated token that signals a prerender cache\n       * should be bypassed\n       */\n      bypassToken?: string\n    }\n  }\n\n  /**\n   * `STATIC_FILE` represents a static file (ie /_next/static) or a purely\n   * static HTML asset e.g. an automatically statically optimized page\n   * that does not use ISR\n   */\n  STATIC_FILE: {\n    id: string\n    filePath: string\n    pathname: string\n    type: AdapterOutputType.STATIC_FILE\n  }\n\n  /**\n   * `MIDDLEWARE` represents the middleware output if present\n   */\n  MIDDLEWARE: SharedRouteFields & {\n    type: AdapterOutputType.MIDDLEWARE\n    /**\n     * config related to the route\n     */\n    config: SharedRouteFields['config'] & {\n      /**\n       * matchers are the configured matchers for middleware\n       */\n      matchers?: MiddlewareMatcher[]\n    }\n  }\n}\n\nexport interface AdapterOutputs {\n  pages: Array<AdapterOutput['PAGES']>\n  middleware?: AdapterOutput['MIDDLEWARE']\n  appPages: Array<AdapterOutput['APP_PAGE']>\n  pagesApi: Array<AdapterOutput['PAGES_API']>\n  appRoutes: Array<AdapterOutput['APP_ROUTE']>\n  prerenders: Array<AdapterOutput['PRERENDER']>\n  staticFiles: Array<AdapterOutput['STATIC_FILE']>\n}\n\nexport interface NextAdapter {\n  name: string\n  /**\n   * modifyConfig is called for any CLI command that loads the next.config\n   * to only apply for specific commands the \"phase\" should be used\n   * @param config\n   * @param ctx\n   * @returns\n   */\n  modifyConfig?: (\n    config: NextConfigComplete,\n    ctx: {\n      phase: PHASE_TYPE\n    }\n  ) => Promise<NextConfigComplete> | NextConfigComplete\n  onBuildComplete?: (ctx: {\n    routes: {\n      headers: Array<ManifestHeaderRoute>\n      redirects: Array<ManifestRedirectRoute>\n      rewrites: {\n        beforeFiles: Array<ManifestRewriteRoute>\n        afterFiles: Array<ManifestRewriteRoute>\n        fallback: Array<ManifestRewriteRoute>\n      }\n      dynamicRoutes: ReadonlyArray<ManifestRoute>\n    }\n    outputs: AdapterOutputs\n    /**\n     * projectDir is the absolute directory the Next.js application is in\n     */\n    projectDir: string\n    /**\n     * repoRoot is the absolute path of the detected root of the repo\n     */\n    repoRoot: string\n    /**\n     * distDir is the absolute path to the dist directory\n     */\n    distDir: string\n    /**\n     * config is the loaded next.config (has modifyConfig applied)\n     */\n    config: NextConfigComplete\n    /**\n     * nextVersion is the current version of Next.js being used\n     */\n    nextVersion: string\n  }) => Promise<void> | void\n}\n\nfunction normalizePathnames(\n  config: NextConfigComplete,\n  outputs: AdapterOutputs\n) {\n  // normalize pathname field with basePath\n  if (config.basePath) {\n    for (const output of [\n      ...outputs.pages,\n      ...outputs.pagesApi,\n      ...outputs.appPages,\n      ...outputs.appRoutes,\n      ...outputs.prerenders,\n      ...outputs.staticFiles,\n      ...(outputs.middleware ? [outputs.middleware] : []),\n    ]) {\n      output.pathname = addPathPrefix(output.pathname, config.basePath)\n    }\n  }\n}\n\nexport async function handleBuildComplete({\n  dir,\n  config,\n  configOutDir,\n  distDir,\n  pageKeys,\n  tracingRoot,\n  adapterPath,\n  appPageKeys,\n  staticPages,\n  nextVersion,\n  hasStatic404,\n  routesManifest,\n  hasNodeMiddleware,\n  prerenderManifest,\n  middlewareManifest,\n  requiredServerFiles,\n  hasInstrumentationHook,\n  functionsConfigManifest,\n}: {\n  dir: string\n  distDir: string\n  configOutDir: string\n  adapterPath: string\n  tracingRoot: string\n  nextVersion: string\n  hasStatic404: boolean\n  staticPages: Set<string>\n  hasNodeMiddleware: boolean\n  config: NextConfigComplete\n  pageKeys: readonly string[]\n  requiredServerFiles: string[]\n  routesManifest: RoutesManifest\n  hasInstrumentationHook: boolean\n  prerenderManifest: PrerenderManifest\n  middlewareManifest: MiddlewareManifest\n  appPageKeys?: readonly string[] | undefined\n  functionsConfigManifest: FunctionsConfigManifest\n}) {\n  const adapterMod = interopDefault(\n    await import(pathToFileURL(require.resolve(adapterPath)).href)\n  ) as NextAdapter\n\n  if (typeof adapterMod.onBuildComplete === 'function') {\n    Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n\n    const outputs: AdapterOutputs = {\n      pages: [],\n      pagesApi: [],\n      appPages: [],\n      appRoutes: [],\n      prerenders: [],\n      staticFiles: [],\n    }\n\n    if (config.output === 'export') {\n      // collect export assets and provide as static files\n      const exportFiles = await recursiveReadDir(configOutDir)\n\n      for (const file of exportFiles) {\n        let pathname = (\n          file.endsWith('.html') ? file.replace(/\\.html$/, '') : file\n        ).replace(/\\\\/g, '/')\n\n        pathname = pathname.startsWith('/') ? pathname : `/${pathname}`\n\n        outputs.staticFiles.push({\n          id: file,\n          pathname,\n          filePath: path.join(configOutDir, file),\n          type: AdapterOutputType.STATIC_FILE,\n        } satisfies AdapterOutput['STATIC_FILE'])\n      }\n    } else {\n      const staticFiles = await recursiveReadDir(path.join(distDir, 'static'))\n\n      for (const file of staticFiles) {\n        const pathname = path.posix.join('/_next/static', file)\n        const filePath = path.join(distDir, 'static', file)\n        outputs.staticFiles.push({\n          type: AdapterOutputType.STATIC_FILE,\n          id: path.join('static', file),\n          pathname,\n          filePath,\n        })\n      }\n\n      const sharedNodeAssets: Record<string, string> = {}\n\n      for (const file of requiredServerFiles) {\n        // add to shared node assets\n        const filePath = path.join(dir, file)\n        const fileOutputPath = path.relative(tracingRoot, filePath)\n        sharedNodeAssets[fileOutputPath] = filePath\n      }\n\n      if (hasInstrumentationHook) {\n        const assets = await handleTraceFiles(\n          path.join(distDir, 'server', 'instrumentation.js.nft.json')\n        )\n        const fileOutputPath = path.relative(\n          tracingRoot,\n          path.join(distDir, 'server', 'instrumentation.js')\n        )\n        sharedNodeAssets[fileOutputPath] = path.join(\n          distDir,\n          'server',\n          'instrumentation.js'\n        )\n        Object.assign(sharedNodeAssets, assets)\n      }\n\n      async function handleTraceFiles(\n        traceFilePath: string\n      ): Promise<Record<string, string>> {\n        const assets: Record<string, string> = Object.assign(\n          {},\n          sharedNodeAssets\n        )\n        const traceData = JSON.parse(\n          await fs.readFile(traceFilePath, 'utf8')\n        ) as {\n          files: string[]\n        }\n        const traceFileDir = path.dirname(traceFilePath)\n\n        for (const relativeFile of traceData.files) {\n          const tracedFilePath = path.join(traceFileDir, relativeFile)\n          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n          assets[fileOutputPath] = tracedFilePath\n        }\n        return assets\n      }\n\n      async function handleEdgeFunction(\n        page: EdgeFunctionDefinition,\n        isMiddleware: boolean = false\n      ) {\n        let type: AdapterOutputType = AdapterOutputType.PAGES\n        const isAppPrefix = page.page.startsWith('app/')\n        const isAppPage = isAppPrefix && page.page.endsWith('/page')\n        const isAppRoute = isAppPrefix && page.page.endsWith('/route')\n        let currentOutputs: Array<\n          | AdapterOutput['PAGES']\n          | AdapterOutput['PAGES_API']\n          | AdapterOutput['APP_PAGE']\n          | AdapterOutput['APP_ROUTE']\n        > = outputs.pages\n\n        if (isMiddleware) {\n          type = AdapterOutputType.MIDDLEWARE\n        } else if (isAppPage) {\n          currentOutputs = outputs.appPages\n          type = AdapterOutputType.APP_PAGE\n        } else if (isAppRoute) {\n          currentOutputs = outputs.appRoutes\n          type = AdapterOutputType.APP_ROUTE\n        } else if (page.page.startsWith('/api')) {\n          currentOutputs = outputs.pagesApi\n          type = AdapterOutputType.PAGES_API\n        }\n\n        const output: Omit<AdapterOutput[typeof type], 'type'> & {\n          type: any\n        } = {\n          type,\n          id: page.name,\n          runtime: 'edge',\n          pathname: isAppPrefix ? normalizeAppPath(page.name) : page.name,\n          filePath: path.join(\n            distDir,\n            page.files.find(\n              (item) =>\n                item.startsWith('server/app') || item.startsWith('server/pages')\n            ) ||\n              // TODO: turbopack build doesn't name the main entry chunk\n              // identifiably so we don't know which to mark here but\n              // technically edge needs all chunks to load always so\n              // should this field even be provided?\n              page.files[0] ||\n              ''\n          ),\n          assets: {},\n          wasmAssets: {},\n          config: {\n            ...(type === AdapterOutputType.MIDDLEWARE\n              ? {\n                  matchers: page.matchers,\n                }\n              : {}),\n            env: page.env,\n          },\n        }\n\n        function handleFile(file: string) {\n          const originalPath = path.join(distDir, file)\n          const fileOutputPath = path.join(\n            path.relative(tracingRoot, distDir),\n            file\n          )\n          if (!output.assets) {\n            output.assets = {}\n          }\n          output.assets[fileOutputPath] = originalPath\n        }\n        for (const file of page.files) {\n          handleFile(file)\n        }\n        for (const item of [...(page.assets || [])]) {\n          handleFile(item.filePath)\n        }\n        for (const item of page.wasm || []) {\n          if (!output.wasmAssets) {\n            output.wasmAssets = {}\n          }\n          output.wasmAssets[item.name] = item.filePath\n        }\n\n        if (type === AdapterOutputType.MIDDLEWARE) {\n          outputs.middleware = output\n        } else {\n          currentOutputs.push(output)\n        }\n      }\n\n      const edgeFunctionHandlers: Promise<any>[] = []\n\n      for (const middleware of Object.values(middlewareManifest.middleware)) {\n        if (isMiddlewareFilename(middleware.name)) {\n          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n        }\n      }\n\n      for (const page of Object.values(middlewareManifest.functions)) {\n        edgeFunctionHandlers.push(handleEdgeFunction(page))\n      }\n      const pagesDistDir = path.join(distDir, 'server', 'pages')\n      const pageOutputMap: Record<\n        string,\n        AdapterOutput['PAGES'] | AdapterOutput['PAGES_API']\n      > = {}\n\n      for (const page of pageKeys) {\n        if (page === '/_app' || page === '/_document') {\n          continue\n        }\n\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n          continue\n        }\n\n        const route = normalizePagePath(page)\n        const pageFile = path.join(\n          pagesDistDir,\n          `${normalizePagePath(page)}.js`\n        )\n\n        // if it's an auto static optimized page it's just\n        // a static file\n        if (staticPages.has(page)) {\n          if (config.i18n) {\n            for (const locale of config.i18n.locales || []) {\n              const localePage =\n                page === '/' ? `/${locale}` : addPathPrefix(page, `/${locale}`)\n              outputs.staticFiles.push({\n                id: localePage,\n                pathname: localePage,\n                type: AdapterOutputType.STATIC_FILE,\n                filePath: path.join(\n                  pagesDistDir,\n                  `${normalizePagePath(localePage)}.html`\n                ),\n              } satisfies AdapterOutput['STATIC_FILE'])\n            }\n          } else {\n            outputs.staticFiles.push({\n              id: page,\n              pathname: route,\n              type: AdapterOutputType.STATIC_FILE,\n              filePath: pageFile.replace(/\\.js$/, '.html'),\n            } satisfies AdapterOutput['STATIC_FILE'])\n          }\n          continue\n        }\n\n        const pageTraceFile = `${pageFile}.nft.json`\n        const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n          if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n            Log.warn(`Failed to locate traced assets for ${pageFile}`, err)\n          }\n          return {} as Record<string, string>\n        })\n        const functionConfig = functionsConfigManifest.functions[route] || {}\n\n        const output: AdapterOutput['PAGES'] | AdapterOutput['PAGES_API'] = {\n          id: route,\n          type: page.startsWith('/api')\n            ? AdapterOutputType.PAGES_API\n            : AdapterOutputType.PAGES,\n          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n          pathname: route,\n          assets,\n          runtime: 'nodejs',\n          config: {\n            maxDuration: functionConfig.maxDuration,\n            preferredRegion: functionConfig.regions,\n          },\n        }\n        pageOutputMap[page] = output\n\n        if (output.type === AdapterOutputType.PAGES) {\n          outputs.pages.push(output)\n        } else {\n          outputs.pagesApi.push(output)\n        }\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n        const middlewareTrace = `${middlewareFile}.nft.json`\n        const assets = await handleTraceFiles(middlewareTrace)\n        const functionConfig =\n          functionsConfigManifest.functions['/_middleware'] || {}\n\n        outputs.middleware = {\n          pathname: '/_middleware',\n          id: '/_middleware',\n          assets,\n          type: AdapterOutputType.MIDDLEWARE,\n          runtime: 'nodejs',\n          filePath: middlewareFile,\n          config: {\n            matchers: functionConfig.matchers,\n          },\n        } satisfies AdapterOutput['MIDDLEWARE']\n      }\n      const appOutputMap: Record<\n        string,\n        AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE']\n      > = {}\n      const appDistDir = path.join(distDir, 'server', 'app')\n\n      if (appPageKeys) {\n        for (const page of appPageKeys) {\n          if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue\n          }\n          const normalizedPage = normalizeAppPath(page)\n          const pageFile = path.join(appDistDir, `${page}.js`)\n          const pageTraceFile = `${pageFile}.nft.json`\n          const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n            return {} as Record<string, string>\n          })\n          const functionConfig =\n            functionsConfigManifest.functions[normalizedPage] || {}\n\n          const output: AdapterOutput['APP_PAGE'] | AdapterOutput['APP_ROUTE'] =\n            {\n              pathname: normalizedPage,\n              id: normalizedPage,\n              assets,\n              type: page.endsWith('/route')\n                ? AdapterOutputType.APP_ROUTE\n                : AdapterOutputType.APP_PAGE,\n              runtime: 'nodejs',\n              filePath: pageFile,\n              config: {\n                maxDuration: functionConfig.maxDuration,\n                preferredRegion: functionConfig.regions,\n              },\n            }\n          appOutputMap[normalizedPage] = output\n\n          if (output.type === AdapterOutputType.APP_PAGE) {\n            outputs.appPages.push(output)\n          } else {\n            outputs.appRoutes.push(output)\n          }\n        }\n      }\n\n      const getParentOutput = (\n        srcRoute: string,\n        childRoute: string,\n        allowMissing?: boolean\n      ) => {\n        const normalizedSrcRoute = normalizeLocalePath(\n          srcRoute,\n          config.i18n?.locales || []\n        ).pathname\n        const parentOutput =\n          pageOutputMap[normalizedSrcRoute] || appOutputMap[normalizedSrcRoute]\n\n        if (!parentOutput && !allowMissing) {\n          console.error({\n            appOutputs: Object.keys(appOutputMap),\n            pageOutputs: Object.keys(pageOutputMap),\n          })\n          throw new Error(\n            `Invariant: failed to find source route ${srcRoute} for prerender ${childRoute}`\n          )\n        }\n        return parentOutput\n      }\n\n      const {\n        prefetchSegmentDirSuffix,\n        prefetchSegmentSuffix,\n        varyHeader,\n        didPostponeHeader,\n        contentTypeHeader: rscContentTypeHeader,\n      } = routesManifest.rsc\n\n      const handleAppMeta = async (\n        route: string,\n        initialOutput: AdapterOutput['PRERENDER'],\n        meta: {\n          postponed?: string\n          segmentPaths?: string[]\n        }\n      ) => {\n        if (meta.postponed && initialOutput.fallback) {\n          initialOutput.fallback.postponedState = meta.postponed\n        }\n\n        if (meta?.segmentPaths) {\n          const segmentsDir = path.join(\n            appDistDir,\n            `${route}${prefetchSegmentDirSuffix}`\n          )\n\n          for (const segmentPath of meta.segmentPaths) {\n            const outputSegmentPath =\n              path.join(\n                appDistDir,\n                route + prefetchSegmentDirSuffix,\n                segmentPath\n              ) + prefetchSegmentSuffix\n\n            const fallbackPathname = path.join(\n              segmentsDir,\n              segmentPath + prefetchSegmentSuffix\n            )\n\n            outputs.prerenders.push({\n              id: outputSegmentPath,\n              pathname: outputSegmentPath,\n              type: AdapterOutputType.PRERENDER,\n              parentOutputId: initialOutput.parentOutputId,\n              groupId: initialOutput.groupId,\n\n              config: {\n                ...initialOutput.config,\n              },\n\n              fallback: {\n                filePath: fallbackPathname,\n                initialExpiration: initialOutput.fallback?.initialExpiration,\n                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n\n                initialHeaders: {\n                  ...initialOutput.fallback?.initialHeaders,\n                  vary: varyHeader,\n                  'content-type': rscContentTypeHeader,\n                  [didPostponeHeader]: '2',\n                },\n              },\n            } satisfies AdapterOutput['PRERENDER'])\n          }\n        }\n      }\n\n      let prerenderGroupId = 1\n\n      type AppRouteMeta = {\n        segmentPaths?: string[]\n        postponed?: string\n        headers?: Record<string, string>\n        status?: number\n      }\n\n      const getAppRouteMeta = async (\n        route: string,\n        isAppPage: boolean\n      ): Promise<AppRouteMeta> => {\n        const meta: AppRouteMeta = isAppPage\n          ? JSON.parse(\n              await fs\n                .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n                .catch(() => '{}')\n            )\n          : {}\n\n        if (meta.headers) {\n          // normalize these for consistency\n          for (const key of Object.keys(meta.headers)) {\n            const keyLower = key.toLowerCase()\n            if (keyLower !== key) {\n              const value = meta.headers[key]\n              delete meta.headers[key]\n              meta.headers[keyLower] = value\n            }\n          }\n        }\n\n        return meta\n      }\n\n      for (const route in prerenderManifest.routes) {\n        const {\n          initialExpireSeconds: initialExpiration,\n          initialRevalidateSeconds: initialRevalidate,\n          initialHeaders,\n          initialStatus,\n          prefetchDataRoute,\n          dataRoute,\n          renderingMode,\n          allowHeader,\n          experimentalBypassFor,\n        } = prerenderManifest.routes[route]\n\n        const srcRoute = prerenderManifest.routes[route].srcRoute || route\n        const isAppPage =\n          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n\n        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n\n        let allowQuery: string[] | undefined\n        const routeKeys = routesManifest.dynamicRoutes.find(\n          (item) => item.page === srcRoute\n        )?.routeKeys\n\n        if (!isDynamicRoute(srcRoute)) {\n          // for non-dynamic routes we use an empty array since\n          // no query values bust the cache for non-dynamic prerenders\n          // prerendered paths also do not pass allowQuery as they match\n          // during handle: 'filesystem' so should not cache differently\n          // by query values\n          allowQuery = []\n        } else if (routeKeys) {\n          // if we have routeKeys in the routes-manifest we use those\n          // for allowQuery for dynamic routes\n          allowQuery = Object.values(routeKeys)\n        }\n\n        let filePath = path.join(\n          isAppPage ? appDistDir : pagesDistDir,\n          `${route === '/' ? 'index' : route}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n        )\n\n        // we use the static 404 for notFound: true if available\n        // if not we do a blocking invoke on first request\n        if (isNotFoundTrue && hasStatic404) {\n          filePath = path.join(pagesDistDir, '404.html')\n        }\n\n        const meta = await getAppRouteMeta(route, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: route,\n          type: AdapterOutputType.PRERENDER,\n          pathname: route,\n          parentOutputId:\n            srcRoute === '/_not-found'\n              ? srcRoute\n              : getParentOutput(srcRoute, route).id,\n          groupId: prerenderGroupId,\n\n          pprChain:\n            isAppPage && config.experimental.ppr\n              ? {\n                  headers: {\n                    [NEXT_RESUME_HEADER]: '1',\n                  },\n                }\n              : undefined,\n\n          fallback:\n            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n              ? {\n                  filePath,\n                  initialStatus,\n                  initialHeaders: {\n                    ...initialHeaders,\n                    vary: varyHeader,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                    ...meta.headers,\n                  },\n                  initialExpiration,\n                  initialRevalidate: initialRevalidate || 1,\n                }\n              : undefined,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (dataRoute) {\n          let dataFilePath = path.join(\n            pagesDistDir,\n            `${route === '/' ? 'index' : route}.json`\n          )\n\n          if (isAppPage) {\n            // When experimental PPR is enabled, we expect that the data\n            // that should be served as a part of the prerender should\n            // be from the prefetch data route. If this isn't enabled\n            // for ppr, the only way to get the data is from the data\n            // route.\n            dataFilePath = path.join(\n              appDistDir,\n              prefetchDataRoute &&\n                renderingMode === RenderingMode.PARTIALLY_STATIC\n                ? prefetchDataRoute\n                : dataRoute\n            )\n          }\n\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: isNotFoundTrue\n              ? undefined\n              : {\n                  ...initialOutput.fallback,\n                  initialHeaders: {\n                    ...initialOutput.fallback?.initialHeaders,\n                    'content-type': isAppPage\n                      ? rscContentTypeHeader\n                      : JSON_CONTENT_TYPE_HEADER,\n                  },\n                  filePath: dataFilePath,\n                },\n          })\n        }\n\n        if (isAppPage) {\n          await handleAppMeta(route, initialOutput, meta)\n        }\n        prerenderGroupId += 1\n      }\n\n      for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n        const {\n          fallback,\n          fallbackExpire,\n          fallbackRevalidate,\n          fallbackHeaders,\n          fallbackStatus,\n          allowHeader,\n          dataRoute,\n          renderingMode,\n          experimentalBypassFor,\n        } = prerenderManifest.dynamicRoutes[dynamicRoute]\n\n        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n\n        const allowQuery = Object.values(\n          routesManifest.dynamicRoutes.find(\n            (item) => item.page === dynamicRoute\n          )?.routeKeys || {}\n        )\n        const meta = await getAppRouteMeta(dynamicRoute, isAppPage)\n\n        const initialOutput: AdapterOutput['PRERENDER'] = {\n          id: dynamicRoute,\n          type: AdapterOutputType.PRERENDER,\n          pathname: dynamicRoute,\n          parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n          groupId: prerenderGroupId,\n          config: {\n            allowQuery,\n            allowHeader,\n            renderingMode,\n            bypassFor: experimentalBypassFor,\n            bypassToken: prerenderManifest.preview.previewModeId,\n          },\n          fallback:\n            typeof fallback === 'string'\n              ? {\n                  filePath: path.join(\n                    isAppPage ? appDistDir : pagesDistDir,\n                    // app router dynamic route fallbacks don't have the\n                    // extension so ensure it's added here\n                    fallback.endsWith('.html') ? fallback : `${fallback}.html`\n                  ),\n                  initialStatus: fallbackStatus,\n                  initialHeaders: {\n                    ...fallbackHeaders,\n                    'content-type': HTML_CONTENT_TYPE_HEADER,\n                  },\n                  initialExpiration: fallbackExpire,\n                  initialRevalidate: fallbackRevalidate || 1,\n                }\n              : undefined,\n        }\n        outputs.prerenders.push(initialOutput)\n\n        if (isAppPage) {\n          await handleAppMeta(dynamicRoute, initialOutput, meta)\n        }\n\n        if (dataRoute) {\n          outputs.prerenders.push({\n            ...initialOutput,\n            id: dataRoute,\n            pathname: dataRoute,\n            fallback: undefined,\n          })\n        }\n        prerenderGroupId += 1\n      }\n    }\n\n    normalizePathnames(config, outputs)\n\n    try {\n      await adapterMod.onBuildComplete({\n        routes: {\n          dynamicRoutes: routesManifest.dynamicRoutes,\n          rewrites: routesManifest.rewrites,\n          redirects: routesManifest.redirects,\n          headers: routesManifest.headers,\n        },\n        outputs,\n\n        config,\n        distDir,\n        nextVersion,\n        projectDir: dir,\n        repoRoot: tracingRoot,\n      })\n    } catch (err) {\n      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n      throw err\n    }\n  }\n}\n"],"names":["path","fs","pathToFileURL","Log","isMiddlewareFilename","RenderingMode","interopDefault","recursiveReadDir","isDynamicRoute","normalizeAppPath","AdapterOutputType","normalizePagePath","HTML_CONTENT_TYPE_HEADER","JSON_CONTENT_TYPE_HEADER","NEXT_RESUME_HEADER","normalizeLocalePath","addPathPrefix","normalizePathnames","config","outputs","basePath","output","pages","pagesApi","appPages","appRoutes","prerenders","staticFiles","middleware","pathname","handleBuildComplete","dir","configOutDir","distDir","pageKeys","tracingRoot","adapterPath","appPageKeys","staticPages","nextVersion","hasStatic404","routesManifest","hasNodeMiddleware","prerenderManifest","middlewareManifest","requiredServerFiles","hasInstrumentationHook","functionsConfigManifest","adapterMod","require","resolve","href","onBuildComplete","info","name","exportFiles","file","endsWith","replace","startsWith","push","id","filePath","join","type","STATIC_FILE","posix","sharedNodeAssets","fileOutputPath","relative","assets","handleTraceFiles","Object","assign","traceFilePath","traceData","JSON","parse","readFile","traceFileDir","dirname","relativeFile","files","tracedFilePath","handleEdgeFunction","page","isMiddleware","PAGES","isAppPrefix","isAppPage","isAppRoute","currentOutputs","MIDDLEWARE","APP_PAGE","APP_ROUTE","PAGES_API","runtime","find","item","wasmAssets","matchers","env","handleFile","originalPath","wasm","edgeFunctionHandlers","values","functions","pagesDistDir","pageOutputMap","hasOwnProperty","route","pageFile","has","i18n","locale","locales","localePage","pageTraceFile","catch","err","code","warn","functionConfig","maxDuration","preferredRegion","regions","middlewareFile","middlewareTrace","appOutputMap","appDistDir","normalizedPage","getParentOutput","srcRoute","childRoute","allowMissing","normalizedSrcRoute","parentOutput","console","error","appOutputs","keys","pageOutputs","Error","prefetchSegmentDirSuffix","prefetchSegmentSuffix","varyHeader","didPostponeHeader","contentTypeHeader","rscContentTypeHeader","rsc","handleAppMeta","initialOutput","meta","postponed","fallback","postponedState","segmentPaths","segmentsDir","segmentPath","outputSegmentPath","fallbackPathname","PRERENDER","parentOutputId","groupId","initialExpiration","initialRevalidate","initialHeaders","vary","prerenderGroupId","getAppRouteMeta","headers","key","keyLower","toLowerCase","value","routes","initialExpireSeconds","initialRevalidateSeconds","initialStatus","prefetchDataRoute","dataRoute","renderingMode","allowHeader","experimentalBypassFor","Boolean","isNotFoundTrue","notFoundRoutes","includes","allowQuery","routeKeys","dynamicRoutes","pprChain","experimental","ppr","undefined","bypassFor","bypassToken","preview","previewModeId","dataFilePath","PARTIALLY_STATIC","dynamicRoute","fallbackExpire","fallbackRevalidate","fallbackHeaders","fallbackStatus","rewrites","redirects","projectDir","repoRoot"],"mappings":"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","ignoreList":[0]}