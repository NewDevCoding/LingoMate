{"version":3,"sources":["../../src/build/index.ts"],"sourcesContent":["import type { PagesManifest } from './webpack/plugins/pages-manifest-plugin'\nimport type { ExportPathMap, NextConfigComplete } from '../server/config-shared'\nimport type { MiddlewareManifest } from './webpack/plugins/middleware-plugin'\nimport type { ActionManifest } from './webpack/plugins/flight-client-entry-plugin'\nimport type { CacheControl, Revalidate } from '../server/lib/cache-control'\n\nimport '../lib/setup-exception-listeners'\n\nimport { loadEnvConfig, type LoadedEnvFiles } from '@next/env'\nimport { bold, yellow } from '../lib/picocolors'\nimport { makeRe } from 'next/dist/compiled/picomatch'\nimport { existsSync, promises as fs } from 'fs'\nimport os from 'os'\nimport { Worker } from '../lib/worker'\nimport { defaultConfig } from '../server/config-shared'\nimport devalue from 'next/dist/compiled/devalue'\nimport findUp from 'next/dist/compiled/find-up'\nimport { nanoid } from 'next/dist/compiled/nanoid/index.cjs'\nimport path from 'path'\nimport {\n  STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR,\n  PUBLIC_DIR_MIDDLEWARE_CONFLICT,\n  MIDDLEWARE_FILENAME,\n  PROXY_FILENAME,\n  PAGES_DIR_ALIAS,\n  INSTRUMENTATION_HOOK_FILENAME,\n  RSC_PREFETCH_SUFFIX,\n  RSC_SUFFIX,\n  NEXT_RESUME_HEADER,\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  MATCHED_PATH_HEADER,\n  RSC_SEGMENTS_DIR_SUFFIX,\n  RSC_SEGMENT_SUFFIX,\n} from '../lib/constants'\nimport { FileType, fileExists } from '../lib/file-exists'\nimport { findPagesDir } from '../lib/find-pages-dir'\nimport loadCustomRoutes, {\n  normalizeRouteRegex,\n} from '../lib/load-custom-routes'\nimport type {\n  CustomRoutes,\n  Header,\n  Redirect,\n  Rewrite,\n  RouteHas,\n} from '../lib/load-custom-routes'\nimport { nonNullable } from '../lib/non-nullable'\nimport { recursiveDeleteSyncWithAsyncRetries } from '../lib/recursive-delete'\nimport { verifyPartytownSetup } from '../lib/verify-partytown-setup'\nimport {\n  BUILD_ID_FILE,\n  BUILD_MANIFEST,\n  CLIENT_STATIC_FILES_PATH,\n  EXPORT_DETAIL,\n  EXPORT_MARKER,\n  IMAGES_MANIFEST,\n  PAGES_MANIFEST,\n  PHASE_PRODUCTION_BUILD,\n  PRERENDER_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVER_DIRECTORY,\n  SERVER_FILES_MANIFEST,\n  STATIC_STATUS_PAGES,\n  MIDDLEWARE_MANIFEST,\n  APP_PATHS_MANIFEST,\n  APP_PATH_ROUTES_MANIFEST,\n  RSC_MODULE_TYPES,\n  NEXT_FONT_MANIFEST,\n  SUBRESOURCE_INTEGRITY_MANIFEST,\n  MIDDLEWARE_BUILD_MANIFEST,\n  MIDDLEWARE_REACT_LOADABLE_MANIFEST,\n  SERVER_REFERENCE_MANIFEST,\n  FUNCTIONS_CONFIG_MANIFEST,\n  DYNAMIC_CSS_MANIFEST,\n  TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST,\n} from '../shared/lib/constants'\nimport {\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n  UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY,\n} from '../shared/lib/entry-constants'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { Bundler, finalizeBundlerFromConfig } from '../lib/bundler'\nimport type { __ApiPreviewProps } from '../server/api-utils'\nimport loadConfig from '../server/config'\nimport type { BuildManifest } from '../server/get-page-files'\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'\nimport { getPagePath } from '../server/require'\nimport * as ciEnvironment from '../server/ci-info'\nimport {\n  turborepoTraceAccess,\n  TurborepoAccessTraceResult,\n  writeTurborepoAccessTraceResult,\n} from './turborepo-access-trace'\n\nimport {\n  eventBuildOptimize,\n  eventCliSession,\n  eventBuildFeatureUsage,\n  eventNextPlugins,\n  EVENT_BUILD_FEATURE_USAGE,\n  eventPackageUsedInGetServerSideProps,\n  eventBuildCompleted,\n  eventBuildFailed,\n} from '../telemetry/events'\nimport type { EventBuildFeatureUsage } from '../telemetry/events'\nimport { Telemetry } from '../telemetry/storage'\nimport {\n  createPagesMapping,\n  collectAppFiles,\n  processPageRoutes,\n  processAppRoutes,\n  processLayoutRoutes,\n  extractSlotsFromAppRoutes,\n  extractSlotsFromDefaultFiles,\n  combineSlots,\n  type RouteInfo,\n  type SlotInfo,\n  collectPagesFiles,\n} from './entries'\nimport { sortByPageExts } from './sort-by-page-exts'\nimport { getStaticInfoIncludingLayouts } from './get-static-info-including-layouts'\nimport { PAGE_TYPES } from '../lib/page-types'\nimport { generateBuildId } from './generate-build-id'\nimport { isWriteable } from './is-writeable'\nimport * as Log from './output/log'\nimport createSpinner from './spinner'\nimport { trace, flushAllTraces, setGlobal, type Span } from '../trace'\nimport {\n  detectConflictingPaths,\n  printCustomRoutes,\n  printTreeView,\n  copyTracedFiles,\n  isReservedPage,\n  isAppBuiltinPage,\n  collectRoutesUsingEdgeRuntime,\n  collectMeta,\n} from './utils'\nimport type { PageInfo, PageInfos } from './utils'\nimport type { FallbackRouteParam, PrerenderedRoute } from './static-paths/types'\nimport type { AppSegmentConfig } from './segment-config/app/app-segment-config'\nimport { writeBuildId } from './write-build-id'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport isError from '../lib/is-error'\nimport type { NextError } from '../lib/is-error'\nimport { isEdgeRuntime } from '../lib/is-edge-runtime'\nimport { recursiveCopy } from '../lib/recursive-copy'\nimport { lockfilePatchPromise, teardownTraceSubscriber } from './swc'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getFilesInDir } from '../lib/get-files-in-dir'\nimport { eventSwcPlugins } from '../telemetry/events/swc-plugins'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\nimport {\n  ACTION_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n} from '../client/components/app-router-headers'\nimport { webpackBuild } from './webpack-build'\nimport { NextBuildContext, type MappedPages } from './build-context'\nimport { normalizePathSep } from '../shared/lib/page-path/normalize-path-sep'\nimport { isAppRouteRoute } from '../lib/is-app-route-route'\nimport { createClientRouterFilter } from '../lib/create-client-router-filter'\nimport { createValidFileMatcher } from '../server/lib/find-page-file'\nimport { startTypeChecking } from './type-check'\nimport { generateInterceptionRoutesRewrites } from '../lib/generate-interception-routes-rewrites'\n\nimport { buildDataRoute } from '../server/lib/router-utils/build-data-route'\nimport { collectBuildTraces } from './collect-build-traces'\nimport type { BuildTraceContext } from './webpack/plugins/next-trace-entrypoints-plugin'\nimport { formatManifest } from './manifests/formatter/format-manifest'\nimport {\n  recordFrameworkVersion,\n  updateBuildDiagnostics,\n  recordFetchMetrics,\n} from '../diagnostics/build-diagnostics'\nimport { getStartServerInfo, logStartInfo } from '../server/lib/app-info-log'\nimport type { NextEnabledDirectories } from '../server/base-server'\nimport { hasCustomExportOutput } from '../export/utils'\nimport { buildCustomRoute } from '../lib/build-custom-route'\nimport { traceMemoryUsage } from '../lib/memory/trace'\nimport { generateEncryptionKeyBase64 } from '../server/app-render/encryption-utils-server'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport uploadTrace from '../trace/upload-trace'\nimport {\n  checkIsAppPPREnabled,\n  checkIsRoutePPREnabled,\n} from '../server/lib/experimental/ppr'\nimport { FallbackMode, fallbackModeToFallbackField } from '../lib/fallback'\nimport { RenderingMode } from './rendering-mode'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport { HTML_LIMITED_BOT_UA_RE_STRING } from '../shared/lib/router/utils/is-bot'\nimport type { UseCacheTrackerKey } from './webpack/plugins/telemetry-plugin/use-cache-tracker-utils'\nimport {\n  buildInversePrefetchSegmentDataRoute,\n  buildPrefetchSegmentDataRoute,\n  type PrefetchSegmentDataRoute,\n} from '../server/lib/router-utils/build-prefetch-segment-data-route'\n\nimport { turbopackBuild } from './turbopack-build'\nimport { isFileSystemCacheEnabledForBuild } from '../shared/lib/turbopack/utils'\nimport { inlineStaticEnv } from '../lib/inline-static-env'\nimport { populateStaticEnv } from '../lib/static-env'\nimport { durationToString, hrtimeDurationToString } from './duration-to-string'\nimport { traceGlobals } from '../trace/shared'\nimport { extractNextErrorCode } from '../lib/error-telemetry-utils'\nimport { runAfterProductionCompile } from './after-production-compile'\nimport { generatePreviewKeys } from './preview-key-utils'\nimport { handleBuildComplete } from './adapter/build-complete'\nimport {\n  sortPageObjects,\n  sortPages,\n  sortSortableRouteObjects,\n} from '../shared/lib/router/utils/sortable-routes'\nimport { mkdir } from 'fs/promises'\nimport {\n  createRouteTypesManifest,\n  writeRouteTypesManifest,\n  writeValidatorFile,\n} from '../server/lib/router-utils/route-types-utils'\nimport { Lockfile } from './lockfile'\n\ntype Fallback = null | boolean | string\n\nexport interface PrerenderManifestRoute {\n  dataRoute: string | null\n  experimentalBypassFor?: RouteHas[]\n\n  /**\n   * The headers that should be served along side this prerendered route.\n   */\n  initialHeaders?: Record<string, string>\n\n  /**\n   * The status code that should be served along side this prerendered route.\n   */\n  initialStatus?: number\n\n  /**\n   * The revalidate value for this route. This might be inferred from:\n   * - route segment configs\n   * - fetch calls\n   * - unstable_cache\n   * - \"use cache\"\n   */\n  initialRevalidateSeconds: Revalidate\n\n  /**\n   * The expire value for this route, which is inferred from the \"use cache\"\n   * functions that are used by the route, or the expireTime config.\n   */\n  initialExpireSeconds: number | undefined\n\n  /**\n   * The prefetch data route associated with this page. If not defined, this\n   * page does not support prefetching.\n   */\n  prefetchDataRoute: string | null | undefined\n\n  /**\n   * The dynamic route that this statically prerendered route is based on. If\n   * this is null, then the route was not based on a dynamic route.\n   */\n  srcRoute: string | null\n\n  /**\n   * @deprecated use `renderingMode` instead\n   */\n  experimentalPPR: boolean | undefined\n\n  /**\n   * The rendering mode for this route. Only `undefined` when not an app router\n   * route.\n   */\n  renderingMode: RenderingMode | undefined\n\n  /**\n   * The headers that are allowed to be used when revalidating this route. These\n   * are used internally by Next.js to revalidate routes.\n   */\n  allowHeader: string[]\n}\n\nexport interface DynamicPrerenderManifestRoute {\n  dataRoute: string | null\n  dataRouteRegex: string | null\n  experimentalBypassFor?: RouteHas[]\n  fallback: Fallback\n\n  /**\n   * When defined, it describes the revalidation configuration for the fallback\n   * route.\n   */\n  fallbackRevalidate: Revalidate | undefined\n\n  /**\n   * When defined, it describes the expire configuration for the fallback route.\n   */\n  fallbackExpire: number | undefined\n\n  /**\n   * The headers that should used when serving the fallback.\n   */\n  fallbackHeaders?: Record<string, string>\n\n  /**\n   * The status code that should be used when serving the fallback.\n   */\n  fallbackStatus?: number\n\n  /**\n   * The root params that are unknown for this fallback route.\n   */\n  fallbackRootParams: readonly string[] | undefined\n\n  /**\n   * The fallback route params for this route that were parsed from the loader\n   * tree.\n   */\n  fallbackRouteParams: readonly FallbackRouteParam[] | undefined\n\n  /**\n   * The source route that this fallback route is based on. This is a reference\n   * so that we can associate this dynamic route with the correct source.\n   */\n  fallbackSourceRoute: string | undefined\n\n  prefetchDataRoute: string | null | undefined\n  prefetchDataRouteRegex: string | null | undefined\n  routeRegex: string\n\n  /**\n   * @deprecated use `renderingMode` instead\n   */\n  experimentalPPR: boolean | undefined\n\n  /**\n   * The rendering mode for this route. Only `undefined` when not an app router\n   * route.\n   */\n  renderingMode: RenderingMode | undefined\n\n  /**\n   * The headers that are allowed to be used when revalidating this route. These\n   * are used internally by Next.js to revalidate routes.\n   */\n  allowHeader: string[]\n}\n\n/**\n * The headers that are allowed to be used when revalidating routes. Currently\n * this includes both headers used by the pages and app routers.\n */\nconst ALLOWED_HEADERS: string[] = [\n  'host',\n  MATCHED_PATH_HEADER,\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n]\n\nexport type PrerenderManifest = {\n  version: 4\n  routes: { [route: string]: PrerenderManifestRoute }\n  dynamicRoutes: { [route: string]: DynamicPrerenderManifestRoute }\n  notFoundRoutes: string[]\n  preview: __ApiPreviewProps\n}\n\ntype ManifestBuiltRoute = {\n  /**\n   * The route pattern used to match requests for this route.\n   */\n  regex: string\n}\n\nexport type ManifestRewriteRoute = ManifestBuiltRoute & Rewrite\nexport type ManifestRedirectRoute = ManifestBuiltRoute & Redirect\nexport type ManifestHeaderRoute = ManifestBuiltRoute & Header\n\nexport type ManifestRoute = ManifestBuiltRoute & {\n  page: string\n  namedRegex: string\n  routeKeys: { [key: string]: string }\n\n  /**\n   * If true, this indicates that the route has fallback root params. This is\n   * used to simplify the route regex for matching.\n   */\n  hasFallbackRootParams?: boolean\n\n  /**\n   * The prefetch segment data routes for this route. This is used to rewrite\n   * the prefetch segment data routes (or the inverse) to the correct\n   * destination.\n   */\n  prefetchSegmentDataRoutes?: PrefetchSegmentDataRoute[]\n\n  /**\n   * If true, this indicates that the route should not be considered for routing\n   * for the internal router, and instead has been added to support external\n   * routers.\n   */\n  skipInternalRouting?: boolean\n}\n\ntype DynamicManifestRoute = ManifestRoute & {\n  /**\n   * The source page that this route is based on. This is used to determine the\n   * source page for the route and is only relevant for app pages where PPR is\n   * enabled and the page differs from the source page.\n   */\n  sourcePage: string | undefined\n}\n\ntype ManifestDataRoute = {\n  page: string\n  routeKeys?: { [key: string]: string }\n  dataRouteRegex: string\n  namedDataRouteRegex?: string\n}\n\nexport type RoutesManifest = {\n  version: number\n  pages404: boolean\n  basePath: string\n  redirects: Array<ManifestRedirectRoute>\n  rewrites: {\n    beforeFiles: Array<ManifestRewriteRoute>\n    afterFiles: Array<ManifestRewriteRoute>\n    fallback: Array<ManifestRewriteRoute>\n  }\n  headers: Array<ManifestHeaderRoute>\n  staticRoutes: Array<ManifestRoute>\n  dynamicRoutes: ReadonlyArray<DynamicManifestRoute>\n  dataRoutes: Array<ManifestDataRoute>\n  i18n?: {\n    domains?: ReadonlyArray<{\n      http?: true\n      domain: string\n      locales?: readonly string[]\n      defaultLocale: string\n    }>\n    locales: readonly string[]\n    defaultLocale: string\n    localeDetection?: false\n  }\n  rsc: {\n    header: typeof RSC_HEADER\n    didPostponeHeader: typeof NEXT_DID_POSTPONE_HEADER\n    contentTypeHeader: typeof RSC_CONTENT_TYPE_HEADER\n    varyHeader: string\n    prefetchHeader: typeof NEXT_ROUTER_PREFETCH_HEADER\n    suffix: typeof RSC_SUFFIX\n    prefetchSuffix: typeof RSC_PREFETCH_SUFFIX\n    prefetchSegmentHeader: typeof NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n    prefetchSegmentDirSuffix: typeof RSC_SEGMENTS_DIR_SUFFIX\n    prefetchSegmentSuffix: typeof RSC_SEGMENT_SUFFIX\n\n    /**\n     * Whether the client param parsing is enabled. This is only relevant for\n     * app pages when PPR is enabled.\n     */\n    clientParamParsing: boolean\n\n    /**\n     * The origins that are allowed to write the rewritten headers when\n     * performing a non-relative rewrite. When undefined, no non-relative\n     * rewrites will get the rewrite headers.\n     */\n    clientParamParsingOrigins: string[] | undefined\n    dynamicRSCPrerender: boolean\n  }\n  rewriteHeaders: {\n    pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER\n    queryHeader: typeof NEXT_REWRITTEN_QUERY_HEADER\n  }\n  skipMiddlewareUrlNormalize?: boolean\n  caseSensitive?: boolean\n  /**\n   * Configuration related to Partial Prerendering.\n   */\n  ppr?: {\n    /**\n     * The chained response for the PPR resume.\n     */\n    chain: {\n      /**\n       * The headers that will indicate to Next.js that the request is for a PPR\n       * resume.\n       */\n      headers: Record<string, string>\n    }\n  }\n}\n\n/**\n * Converts a page to a manifest route.\n *\n * @param page The page to convert to a route.\n * @returns A route object.\n */\nfunction pageToRoute(page: string): ManifestRoute\n/**\n * Converts a page to a dynamic manifest route.\n *\n * @param page The page to convert to a route.\n * @param sourcePage The source page that this route is based on. This is used\n * to determine the source page for the route and is only relevant for app\n * pages when PPR is enabled on them.\n * @returns A route object.\n */\nfunction pageToRoute(\n  page: string,\n  sourcePage: string | undefined\n): DynamicManifestRoute\nfunction pageToRoute(\n  page: string,\n  sourcePage?: string\n): DynamicManifestRoute | ManifestRoute {\n  const routeRegex = getNamedRouteRegex(page, {\n    prefixRouteKeys: true,\n  })\n  return {\n    sourcePage,\n    page,\n    regex: normalizeRouteRegex(routeRegex.re.source),\n    routeKeys: routeRegex.routeKeys,\n    namedRegex: routeRegex.namedRegex,\n  }\n}\n\nfunction getCacheDir(distDir: string): string {\n  const cacheDir = path.join(distDir, 'cache')\n  if (ciEnvironment.isCI && !ciEnvironment.hasNextSupport) {\n    const hasCache = existsSync(cacheDir)\n\n    if (!hasCache) {\n      // Intentionally not piping to stderr which is what `Log.warn` does in case people fail in CI when\n      // stderr is detected.\n      console.log(\n        `${Log.prefixes.warn} No build cache found. Please configure build caching for faster rebuilds. Read more: https://nextjs.org/docs/messages/no-cache`\n      )\n    }\n  }\n  return cacheDir\n}\n\nasync function writeFileUtf8(filePath: string, content: string): Promise<void> {\n  await fs.writeFile(filePath, content, 'utf-8')\n}\n\nfunction readFileUtf8(filePath: string): Promise<string> {\n  return fs.readFile(filePath, 'utf8')\n}\n\nasync function writeManifest<T extends object>(\n  filePath: string,\n  manifest: T\n): Promise<void> {\n  await writeFileUtf8(filePath, formatManifest(manifest))\n}\n\nasync function readManifest<T extends object>(filePath: string): Promise<T> {\n  return JSON.parse(await readFileUtf8(filePath))\n}\n\nasync function writePrerenderManifest(\n  distDir: string,\n  manifest: DeepReadonly<PrerenderManifest>\n): Promise<void> {\n  await writeManifest(path.join(distDir, PRERENDER_MANIFEST), manifest)\n}\n\nasync function writeClientSsgManifest(\n  prerenderManifest: DeepReadonly<PrerenderManifest>,\n  {\n    buildId,\n    distDir,\n    locales,\n  }: {\n    buildId: string\n    distDir: string\n    locales: readonly string[] | undefined\n  }\n) {\n  const ssgPages = new Set<string>(\n    [\n      ...Object.entries(prerenderManifest.routes)\n        // Filter out dynamic routes\n        .filter(([, { srcRoute }]) => srcRoute == null)\n        .map(([route]) => normalizeLocalePath(route, locales).pathname),\n      ...Object.keys(prerenderManifest.dynamicRoutes),\n    ].sort()\n  )\n\n  const clientSsgManifestContent = `self.__SSG_MANIFEST=${devalue(\n    ssgPages\n  )};self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()`\n\n  await writeFileUtf8(\n    path.join(distDir, CLIENT_STATIC_FILES_PATH, buildId, '_ssgManifest.js'),\n    clientSsgManifestContent\n  )\n}\n\nexport interface FunctionsConfigManifest {\n  version: number\n  functions: Record<\n    string,\n    {\n      maxDuration?: number | undefined\n      runtime?: 'nodejs'\n      regions?: string[] | string\n      matchers?: Array<{\n        regexp: string\n        originalSource: string\n        has?: Rewrite['has']\n        missing?: Rewrite['has']\n      }>\n    }\n  >\n}\n\nasync function writeFunctionsConfigManifest(\n  distDir: string,\n  manifest: FunctionsConfigManifest\n): Promise<void> {\n  await writeManifest(\n    path.join(distDir, SERVER_DIRECTORY, FUNCTIONS_CONFIG_MANIFEST),\n    manifest\n  )\n}\n\nexport interface RequiredServerFilesManifest {\n  version: number\n  config: NextConfigComplete\n  appDir: string\n  relativeAppDir: string\n  files: string[]\n  ignore: string[]\n}\n\nasync function writeRequiredServerFilesManifest(\n  distDir: string,\n  requiredServerFiles: RequiredServerFilesManifest\n) {\n  await writeManifest(\n    path.join(distDir, SERVER_FILES_MANIFEST),\n    requiredServerFiles\n  )\n}\n\nasync function writeImagesManifest(\n  distDir: string,\n  config: NextConfigComplete\n): Promise<void> {\n  const images = { ...config.images }\n  const { deviceSizes, imageSizes } = images\n  ;(images as any).sizes = [...deviceSizes, ...imageSizes]\n\n  // By default, remotePatterns will allow no remote images ([])\n  images.remotePatterns = (config?.images?.remotePatterns || []).map((p) => ({\n    // Modifying the manifest should also modify matchRemotePattern()\n    protocol: p.protocol?.replace(/:$/, '') as 'http' | 'https' | undefined,\n    hostname: makeRe(p.hostname).source,\n    port: p.port,\n    pathname: makeRe(p.pathname ?? '**', { dot: true }).source,\n    search: p.search,\n  }))\n\n  // By default, localPatterns will allow all local images (undefined)\n  if (config?.images?.localPatterns) {\n    images.localPatterns = config.images.localPatterns.map((p) => ({\n      // Modifying the manifest should also modify matchLocalPattern()\n      pathname: makeRe(p.pathname ?? '**', { dot: true }).source,\n      search: p.search,\n    }))\n  }\n\n  await writeManifest(path.join(distDir, IMAGES_MANIFEST), {\n    version: 1,\n    images,\n  })\n}\n\nconst STANDALONE_DIRECTORY = 'standalone' as const\nasync function writeStandaloneDirectory(\n  nextBuildSpan: Span,\n  distDir: string,\n  pageKeys: { pages: string[]; app: string[] | undefined },\n  denormalizedAppPages: string[] | undefined,\n  outputFileTracingRoot: string,\n  requiredServerFiles: RequiredServerFilesManifest,\n  middlewareManifest: MiddlewareManifest,\n  hasNodeMiddleware: boolean,\n  hasInstrumentationHook: boolean,\n  staticPages: Set<string>,\n  loadedEnvFiles: LoadedEnvFiles,\n  appDir: string | undefined\n) {\n  await nextBuildSpan\n    .traceChild('write-standalone-directory')\n    .traceAsyncFn(async () => {\n      await copyTracedFiles(\n        // requiredServerFiles.appDir Refers to the application directory, not App Router.\n        requiredServerFiles.appDir,\n        distDir,\n        pageKeys.pages,\n        denormalizedAppPages,\n        outputFileTracingRoot,\n        requiredServerFiles.config,\n        middlewareManifest,\n        hasNodeMiddleware,\n        hasInstrumentationHook,\n        staticPages\n      )\n\n      for (const file of [\n        ...requiredServerFiles.files,\n        path.join(requiredServerFiles.config.distDir, SERVER_FILES_MANIFEST),\n        ...loadedEnvFiles.reduce<string[]>((acc, envFile) => {\n          if (['.env', '.env.production'].includes(envFile.path)) {\n            acc.push(envFile.path)\n          }\n          return acc\n        }, []),\n      ]) {\n        // requiredServerFiles.appDir Refers to the application directory, not App Router.\n        const filePath = path.join(requiredServerFiles.appDir, file)\n        const outputPath = path.join(\n          distDir,\n          STANDALONE_DIRECTORY,\n          path.relative(outputFileTracingRoot, filePath)\n        )\n        await fs.mkdir(path.dirname(outputPath), {\n          recursive: true,\n        })\n        await fs.copyFile(filePath, outputPath)\n      }\n\n      if (hasNodeMiddleware) {\n        const middlewareOutput = path.join(\n          distDir,\n          STANDALONE_DIRECTORY,\n          path.relative(outputFileTracingRoot, distDir),\n          SERVER_DIRECTORY,\n          'middleware.js'\n        )\n\n        await fs.mkdir(path.dirname(middlewareOutput), { recursive: true })\n        await fs.copyFile(\n          path.join(distDir, SERVER_DIRECTORY, 'middleware.js'),\n          middlewareOutput\n        )\n      }\n\n      await recursiveCopy(\n        path.join(distDir, SERVER_DIRECTORY, 'pages'),\n        path.join(\n          distDir,\n          STANDALONE_DIRECTORY,\n          path.relative(outputFileTracingRoot, distDir),\n          SERVER_DIRECTORY,\n          'pages'\n        ),\n        { overwrite: true }\n      )\n      if (appDir) {\n        const originalServerApp = path.join(distDir, SERVER_DIRECTORY, 'app')\n        if (existsSync(originalServerApp)) {\n          await recursiveCopy(\n            originalServerApp,\n            path.join(\n              distDir,\n              STANDALONE_DIRECTORY,\n              path.relative(outputFileTracingRoot, distDir),\n              SERVER_DIRECTORY,\n              'app'\n            ),\n            { overwrite: true }\n          )\n        }\n      }\n    })\n}\n\nfunction getNumberOfWorkers(config: NextConfigComplete) {\n  if (\n    config.experimental.cpus &&\n    config.experimental.cpus !== defaultConfig.experimental!.cpus\n  ) {\n    return config.experimental.cpus\n  }\n\n  if (config.experimental.memoryBasedWorkersCount) {\n    return Math.max(\n      Math.min(config.experimental.cpus || 1, Math.floor(os.freemem() / 1e9)),\n      // enforce a minimum of 4 workers\n      4\n    )\n  }\n\n  if (config.experimental.cpus) {\n    return config.experimental.cpus\n  }\n\n  // Fall back to 4 workers if a count is not specified\n  return 4\n}\n\nconst staticWorkerPath = require.resolve('./worker')\nconst staticWorkerExposedMethods = [\n  'hasCustomGetInitialProps',\n  'isPageStatic',\n  'getDefinedNamedExports',\n  'exportPages',\n] as const\nexport type StaticWorker = typeof import('./worker') & Worker\nexport function createStaticWorker(\n  config: NextConfigComplete,\n  options: {\n    debuggerPortOffset: number\n    progress?: {\n      run: () => void\n      clear: () => void\n    }\n  }\n): StaticWorker {\n  const { debuggerPortOffset, progress } = options\n  return new Worker(staticWorkerPath, {\n    logger: Log,\n    numWorkers: getNumberOfWorkers(config),\n    onActivity: () => {\n      progress?.run()\n    },\n    onActivityAbort: () => {\n      progress?.clear()\n    },\n    debuggerPortOffset,\n    enableSourceMaps: config.experimental.enablePrerenderSourceMaps,\n    // remove --max-old-space-size flag as it can cause memory issues.\n    isolatedMemory: true,\n    enableWorkerThreads: config.experimental.workerThreads,\n    exposedMethods: staticWorkerExposedMethods,\n  }) as StaticWorker\n}\n\nasync function writeFullyStaticExport(\n  config: NextConfigComplete,\n  dir: string,\n  enabledDirectories: NextEnabledDirectories,\n  configOutDir: string,\n  nextBuildSpan: Span,\n  appDirOnly: boolean\n): Promise<void> {\n  const exportApp = (require('../export') as typeof import('../export'))\n    .default as typeof import('../export').default\n\n  await exportApp(\n    dir,\n    {\n      buildExport: false,\n      nextConfig: config,\n      enabledDirectories,\n      silent: true,\n      outdir: path.join(dir, configOutDir),\n      numWorkers: getNumberOfWorkers(config),\n      appDirOnly,\n    },\n    nextBuildSpan\n  )\n}\n\nasync function getBuildId(\n  isGenerateMode: boolean,\n  distDir: string,\n  nextBuildSpan: Span,\n  config: NextConfigComplete\n) {\n  if (isGenerateMode) {\n    return await fs.readFile(path.join(distDir, 'BUILD_ID'), 'utf8')\n  }\n  return await nextBuildSpan\n    .traceChild('generate-buildid')\n    .traceAsyncFn(() => generateBuildId(config.generateBuildId, nanoid))\n}\n\nexport default async function build(\n  dir: string,\n  reactProductionProfiling = false,\n  debugOutput = false,\n  debugPrerender = false,\n  noMangling = false,\n  appDirOnly = false,\n  bundler = Bundler.Turbopack,\n  experimentalBuildMode: 'default' | 'compile' | 'generate' | 'generate-env',\n  traceUploadUrl: string | undefined\n): Promise<void> {\n  const isCompileMode = experimentalBuildMode === 'compile'\n  const isGenerateMode = experimentalBuildMode === 'generate'\n  NextBuildContext.isCompileMode = isCompileMode\n  const buildStartTime = Date.now()\n\n  let loadedConfig: NextConfigComplete | undefined\n  try {\n    const nextBuildSpan = trace('next-build', undefined, {\n      buildMode: experimentalBuildMode,\n      version: process.env.__NEXT_VERSION as string,\n    })\n\n    NextBuildContext.nextBuildSpan = nextBuildSpan\n    NextBuildContext.dir = dir\n    NextBuildContext.appDirOnly = appDirOnly\n    NextBuildContext.reactProductionProfiling = reactProductionProfiling\n    NextBuildContext.noMangling = noMangling\n    NextBuildContext.debugPrerender = debugPrerender\n\n    await nextBuildSpan.traceAsyncFn(async () => {\n      // attempt to load global env values so they are available in next.config.js\n      const { loadedEnvFiles } = nextBuildSpan\n        .traceChild('load-dotenv')\n        .traceFn(() => loadEnvConfig(dir, false, Log))\n      NextBuildContext.loadedEnvFiles = loadedEnvFiles\n\n      const turborepoAccessTraceResult = new TurborepoAccessTraceResult()\n      const config: NextConfigComplete = await nextBuildSpan\n        .traceChild('load-next-config')\n        .traceAsyncFn(() =>\n          turborepoTraceAccess(\n            () =>\n              loadConfig(PHASE_PRODUCTION_BUILD, dir, {\n                // Log for next.config loading process\n                silent: false,\n                reactProductionProfiling,\n                debugPrerender,\n              }),\n            turborepoAccessTraceResult\n          )\n        )\n      loadedConfig = config\n\n      // Reading the config can modify environment variables that influence the bundler selection.\n      bundler = finalizeBundlerFromConfig(bundler)\n      nextBuildSpan.setAttribute('bundler', getBundlerForTelemetry(bundler))\n\n      process.env.NEXT_DEPLOYMENT_ID = config.deploymentId || ''\n      NextBuildContext.config = config\n\n      let configOutDir = 'out'\n      if (hasCustomExportOutput(config)) {\n        configOutDir = config.distDir\n        config.distDir = '.next'\n      }\n      const distDir = path.join(dir, config.distDir)\n      NextBuildContext.distDir = distDir\n      setGlobal('phase', PHASE_PRODUCTION_BUILD)\n      setGlobal('distDir', distDir)\n\n      const buildId = await getBuildId(\n        isGenerateMode,\n        distDir,\n        nextBuildSpan,\n        config\n      )\n      NextBuildContext.buildId = buildId\n\n      if (experimentalBuildMode === 'generate-env') {\n        if (bundler === Bundler.Turbopack) {\n          Log.warn('generate-env is not needed with turbopack')\n          process.exit(0)\n        }\n        Log.info('Inlining static env ...')\n        await nextBuildSpan\n          .traceChild('inline-static-env')\n          .traceAsyncFn(async () => {\n            await inlineStaticEnv({\n              distDir,\n              config,\n            })\n          })\n\n        Log.info('Complete')\n        await flushAllTraces()\n        teardownTraceSubscriber()\n        process.exit(0)\n      }\n\n      // when using compile mode static env isn't inlined so we\n      // need to populate in normal runtime env\n      if (isCompileMode || isGenerateMode) {\n        populateStaticEnv(config)\n      }\n\n      const customRoutes: CustomRoutes = await nextBuildSpan\n        .traceChild('load-custom-routes')\n        .traceAsyncFn(() => loadCustomRoutes(config))\n\n      const { headers, rewrites, redirects } = customRoutes\n      const combinedRewrites: Rewrite[] = [\n        ...rewrites.beforeFiles,\n        ...rewrites.afterFiles,\n        ...rewrites.fallback,\n      ]\n      const hasRewrites = combinedRewrites.length > 0\n      NextBuildContext.hasRewrites = hasRewrites\n      NextBuildContext.originalRewrites = config._originalRewrites\n      NextBuildContext.originalRedirects = config._originalRedirects\n\n      const distDirCreated = await nextBuildSpan\n        .traceChild('create-dist-dir')\n        .traceAsyncFn(async () => {\n          try {\n            await fs.mkdir(distDir, { recursive: true })\n            return true\n          } catch (err) {\n            if (isError(err) && err.code === 'EPERM') {\n              return false\n            }\n            throw err\n          }\n        })\n\n      if (!distDirCreated || !(await isWriteable(distDir))) {\n        throw new Error(\n          '> Build directory is not writeable. https://nextjs.org/docs/messages/build-dir-not-writeable'\n        )\n      }\n\n      if (config.experimental.lockDistDir) {\n        // This leaks the lock file descriptor. That's okay, it'll be cleaned up by the OS upon\n        // process exit.\n        await Lockfile.acquireWithRetriesOrExit(\n          path.join(distDir, 'lock'),\n          'next build'\n        )\n      }\n\n      if (config.cleanDistDir && !isGenerateMode) {\n        await nextBuildSpan\n          .traceChild('clean')\n          .traceAsyncFn(() =>\n            recursiveDeleteSyncWithAsyncRetries(distDir, /^(cache|dev|lock)/)\n          )\n      }\n\n      const cacheDir = getCacheDir(distDir)\n\n      const telemetry = new Telemetry({ distDir })\n\n      setGlobal('telemetry', telemetry)\n\n      const publicDir = path.join(dir, 'public')\n      const { pagesDir, appDir } = findPagesDir(dir)\n\n      if (!appDirOnly && !pagesDir) {\n        appDirOnly = true\n      }\n\n      NextBuildContext.pagesDir = pagesDir\n      NextBuildContext.appDir = appDir\n\n      const enabledDirectories: NextEnabledDirectories = {\n        app: typeof appDir === 'string',\n        pages: typeof pagesDir === 'string',\n      }\n\n      // Generate a random encryption key for this build.\n      // This key is used to encrypt cross boundary values and can be used to generate hashes.\n      const encryptionKey = await generateEncryptionKeyBase64({\n        isBuild: true,\n        distDir,\n      })\n      NextBuildContext.encryptionKey = encryptionKey\n\n      const isSrcDir = path\n        .relative(dir, pagesDir || appDir || '')\n        .startsWith('src')\n      const hasPublicDir = existsSync(publicDir)\n\n      telemetry.record(\n        eventCliSession(config, {\n          webpackVersion: 5,\n          cliCommand: 'build',\n          isSrcDir,\n          hasNowJson: !!(await findUp('now.json', { cwd: dir })),\n          isCustomServer: null,\n          turboFlag: false,\n          pagesDir: !!pagesDir,\n          appDir: !!appDir,\n        })\n      )\n\n      eventNextPlugins(path.resolve(dir)).then((events) =>\n        telemetry.record(events)\n      )\n\n      eventSwcPlugins(path.resolve(dir), config).then((events) =>\n        telemetry.record(events)\n      )\n\n      // Always log next version first then start rest jobs\n      const { envInfo, experimentalFeatures } = await getStartServerInfo({\n        dir,\n        dev: false,\n        debugPrerender,\n      })\n\n      logStartInfo({\n        networkUrl: null,\n        appUrl: null,\n        envInfo,\n        experimentalFeatures,\n        logBundler: true,\n      })\n\n      const typeCheckingOptions: Parameters<typeof startTypeChecking>[0] = {\n        dir,\n        appDir,\n        pagesDir,\n        telemetry,\n        nextBuildSpan,\n        config,\n        cacheDir,\n      }\n\n      if (appDir && 'exportPathMap' in config) {\n        Log.error(\n          'The \"exportPathMap\" configuration cannot be used with the \"app\" directory. Please use generateStaticParams() instead.'\n        )\n        await telemetry.flush()\n        process.exit(1)\n      }\n\n      const validFileMatcher = createValidFileMatcher(\n        config.pageExtensions,\n        appDir\n      )\n\n      const providedPagePaths: string[] = JSON.parse(\n        process.env.NEXT_PRIVATE_PAGE_PATHS || '[]'\n      )\n\n      let pagesPaths = Boolean(process.env.NEXT_PRIVATE_PAGE_PATHS)\n        ? providedPagePaths\n        : !appDirOnly && pagesDir\n          ? await nextBuildSpan\n              .traceChild('collect-pages')\n              .traceAsyncFn(() => collectPagesFiles(pagesDir, validFileMatcher))\n          : []\n\n      const middlewareDetectionRegExp = new RegExp(\n        `^${MIDDLEWARE_FILENAME}\\\\.(?:${config.pageExtensions.join('|')})$`\n      )\n\n      const proxyDetectionRegExp = new RegExp(\n        `^${PROXY_FILENAME}\\\\.(?:${config.pageExtensions.join('|')})$`\n      )\n\n      const instrumentationHookDetectionRegExp = new RegExp(\n        `^${INSTRUMENTATION_HOOK_FILENAME}\\\\.(?:${config.pageExtensions.join(\n          '|'\n        )})$`\n      )\n\n      const rootDir = path.join((pagesDir || appDir)!, '..')\n      const includes = [\n        middlewareDetectionRegExp,\n        proxyDetectionRegExp,\n        instrumentationHookDetectionRegExp,\n      ]\n\n      const rootPaths = Array.from(await getFilesInDir(rootDir))\n        .filter((file) => includes.some((include) => include.test(file)))\n        .sort(sortByPageExts(config.pageExtensions))\n        .map((file) => path.join(rootDir, file).replace(dir, ''))\n\n      const hasInstrumentationHook = rootPaths.some((p) =>\n        p.includes(INSTRUMENTATION_HOOK_FILENAME)\n      )\n      const hasMiddlewareFile = rootPaths.some((p) =>\n        p.includes(MIDDLEWARE_FILENAME)\n      )\n      const hasProxyFile = rootPaths.some((p) => p.includes(PROXY_FILENAME))\n      if (hasMiddlewareFile) {\n        if (hasProxyFile) {\n          throw new Error(\n            `Both \"${MIDDLEWARE_FILENAME}\" and \"${PROXY_FILENAME}\" files are detected. Please use \"${PROXY_FILENAME}\" instead.`\n          )\n        }\n        Log.warn(\n          `The \"${MIDDLEWARE_FILENAME}\" file convention is deprecated. Please use \"${PROXY_FILENAME}\" instead.`\n        )\n      }\n\n      NextBuildContext.hasInstrumentationHook = hasInstrumentationHook\n\n      const previewProps: __ApiPreviewProps = await generatePreviewKeys({\n        isBuild: true,\n        distDir,\n      })\n      NextBuildContext.previewProps = previewProps\n\n      const mappedPages = await nextBuildSpan\n        .traceChild('create-pages-mapping')\n        .traceAsyncFn(() =>\n          createPagesMapping({\n            isDev: false,\n            pageExtensions: config.pageExtensions,\n            pagesType: PAGE_TYPES.PAGES,\n            pagePaths: pagesPaths,\n            pagesDir,\n            appDir,\n            appDirOnly,\n          })\n        )\n      NextBuildContext.mappedPages = mappedPages\n\n      let mappedAppPages: MappedPages | undefined\n      let mappedAppLayouts: MappedPages | undefined\n      let denormalizedAppPages: string[] | undefined\n\n      if (appDir) {\n        const providedAppPaths: string[] = JSON.parse(\n          process.env.NEXT_PRIVATE_APP_PATHS || '[]'\n        )\n\n        let appPaths: string[]\n        let layoutPaths: string[]\n\n        if (Boolean(process.env.NEXT_PRIVATE_APP_PATHS)) {\n          // used for testing?\n          appPaths = providedAppPaths\n          layoutPaths = []\n        } else {\n          // Collect app pages, layouts, and default files in a single directory traversal\n          const result = await nextBuildSpan\n            .traceChild('collect-app-files')\n            .traceAsyncFn(() => collectAppFiles(appDir, validFileMatcher))\n\n          appPaths = result.appPaths\n          layoutPaths = result.layoutPaths\n          // Note: defaultPaths are not used in the build process, only for slot detection in generating route types\n        }\n\n        mappedAppPages = await nextBuildSpan\n          .traceChild('create-app-mapping')\n          .traceAsyncFn(() =>\n            createPagesMapping({\n              pagePaths: appPaths,\n              isDev: false,\n              pagesType: PAGE_TYPES.APP,\n              pageExtensions: config.pageExtensions,\n              pagesDir,\n              appDir,\n              appDirOnly,\n            })\n          )\n\n        mappedAppLayouts = await nextBuildSpan\n          .traceChild('create-app-layouts')\n          .traceAsyncFn(() =>\n            createPagesMapping({\n              pagePaths: layoutPaths,\n              isDev: false,\n              pagesType: PAGE_TYPES.APP,\n              pageExtensions: config.pageExtensions,\n              pagesDir,\n              appDir,\n              appDirOnly,\n            })\n          )\n\n        NextBuildContext.mappedAppPages = mappedAppPages\n      }\n\n      const mappedRootPaths = await createPagesMapping({\n        isDev: false,\n        pageExtensions: config.pageExtensions,\n        pagePaths: rootPaths,\n        pagesType: PAGE_TYPES.ROOT,\n        pagesDir: pagesDir,\n        appDir,\n        appDirOnly,\n      })\n      NextBuildContext.mappedRootPaths = mappedRootPaths\n\n      const pagesPageKeys = Object.keys(mappedPages)\n\n      const conflictingAppPagePaths: [pagePath: string, appPath: string][] = []\n      const appPageKeys = new Set<string>()\n      if (mappedAppPages) {\n        denormalizedAppPages = Object.keys(mappedAppPages)\n        for (const appKey of denormalizedAppPages) {\n          const normalizedAppPageKey = normalizeAppPath(appKey)\n          const pagePath = mappedPages[normalizedAppPageKey]\n          if (pagePath) {\n            const appPath = mappedAppPages[appKey]\n            conflictingAppPagePaths.push([\n              pagePath.replace(/^private-next-pages/, 'pages'),\n              appPath.replace(/^private-next-app-dir/, 'app'),\n            ])\n          }\n          appPageKeys.add(normalizedAppPageKey)\n        }\n      }\n\n      const appPaths = Array.from(appPageKeys)\n      // Interception routes are modelled as beforeFiles rewrites\n      rewrites.beforeFiles.push(\n        ...generateInterceptionRoutesRewrites(appPaths, config.basePath)\n      )\n\n      NextBuildContext.rewrites = rewrites\n\n      const totalAppPagesCount = appPaths.length\n\n      const pageKeys = {\n        pages: pagesPageKeys,\n        app: appPaths.length > 0 ? appPaths : undefined,\n      }\n\n      await nextBuildSpan\n        .traceChild('generate-route-types')\n        .traceAsyncFn(async () => {\n          const routeTypesFilePath = path.join(distDir, 'types', 'routes.d.ts')\n          const validatorFilePath = path.join(distDir, 'types', 'validator.ts')\n          await mkdir(path.dirname(routeTypesFilePath), { recursive: true })\n\n          let appRoutes: RouteInfo[] = []\n          let appRouteHandlers: RouteInfo[] = []\n          let layoutRoutes: RouteInfo[] = []\n          let slots: SlotInfo[] = []\n\n          const { pageRoutes, pageApiRoutes } = processPageRoutes(\n            mappedPages,\n            dir,\n            isSrcDir\n          )\n\n          // Build app routes\n          if (appDir && mappedAppPages) {\n            // Extract slots from both pages and default files\n            const slotsFromPages = extractSlotsFromAppRoutes(mappedAppPages)\n            let slotsFromDefaults: SlotInfo[] = []\n\n            // Collect and map default files for slot extraction\n            const { defaultPaths } = await nextBuildSpan\n              .traceChild('collect-default-files')\n              .traceAsyncFn(() => collectAppFiles(appDir, validFileMatcher))\n\n            if (defaultPaths.length > 0) {\n              const mappedDefaultFiles = await nextBuildSpan\n                .traceChild('create-default-mapping')\n                .traceAsyncFn(() =>\n                  createPagesMapping({\n                    pagePaths: defaultPaths,\n                    isDev: false,\n                    pagesType: PAGE_TYPES.APP,\n                    pageExtensions: config.pageExtensions,\n                    pagesDir,\n                    appDir,\n                    appDirOnly,\n                  })\n                )\n              slotsFromDefaults =\n                extractSlotsFromDefaultFiles(mappedDefaultFiles)\n            }\n\n            // Combine slots and deduplicate using Set\n            slots = combineSlots(slotsFromPages, slotsFromDefaults)\n\n            const result = processAppRoutes(\n              mappedAppPages,\n              validFileMatcher,\n              dir,\n              isSrcDir\n            )\n            appRoutes = result.appRoutes\n            appRouteHandlers = result.appRouteHandlers\n          }\n\n          // Build app layouts\n          if (appDir && mappedAppLayouts) {\n            layoutRoutes = processLayoutRoutes(mappedAppLayouts, dir, isSrcDir)\n          }\n\n          const routeTypesManifest = await createRouteTypesManifest({\n            dir,\n            pageRoutes,\n            appRoutes,\n            appRouteHandlers,\n            pageApiRoutes,\n            layoutRoutes,\n            slots,\n            redirects: config.redirects,\n            rewrites: config.rewrites,\n            validatorFilePath,\n          })\n\n          await writeRouteTypesManifest(\n            routeTypesManifest,\n            routeTypesFilePath,\n            config\n          )\n          await writeValidatorFile(routeTypesManifest, validatorFilePath)\n        })\n\n      // Turbopack already handles conflicting app and page routes.\n      if (bundler !== Bundler.Turbopack) {\n        const numConflictingAppPaths = conflictingAppPagePaths.length\n        if (mappedAppPages && numConflictingAppPaths > 0) {\n          Log.error(\n            `Conflicting app and page file${\n              numConflictingAppPaths === 1 ? ' was' : 's were'\n            } found, please remove the conflicting files to continue:`\n          )\n          for (const [pagePath, appPath] of conflictingAppPagePaths) {\n            Log.error(`  \"${pagePath}\" - \"${appPath}\"`)\n          }\n          await telemetry.flush()\n          process.exit(1)\n        }\n      }\n\n      const conflictingPublicFiles: string[] = []\n      const hasPages404 = mappedPages['/404']?.startsWith(PAGES_DIR_ALIAS)\n      const hasApp404 = !!mappedAppPages?.[UNDERSCORE_NOT_FOUND_ROUTE_ENTRY]\n      const hasAppGlobalError =\n        !!mappedAppPages?.[UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY]\n      const hasCustomErrorPage =\n        mappedPages['/_error']?.startsWith(PAGES_DIR_ALIAS)\n\n      // Check if there are any user pages (non-reserved pages) in the pages router\n      const hasUserPagesRoutes = Object.keys(mappedPages).some(\n        (route) => !isReservedPage(route)\n      )\n\n      if (hasPublicDir) {\n        const hasPublicUnderScoreNextDir = existsSync(\n          path.join(publicDir, '_next')\n        )\n        if (hasPublicUnderScoreNextDir) {\n          throw new Error(PUBLIC_DIR_MIDDLEWARE_CONFLICT)\n        }\n      }\n\n      await nextBuildSpan\n        .traceChild('public-dir-conflict-check')\n        .traceAsyncFn(async () => {\n          // Check if pages conflict with files in `public`\n          // Only a page of public file can be served, not both.\n          for (const page in mappedPages) {\n            const hasPublicPageFile = await fileExists(\n              path.join(publicDir, page === '/' ? '/index' : page),\n              FileType.File\n            )\n            if (hasPublicPageFile) {\n              conflictingPublicFiles.push(page)\n            }\n          }\n\n          const numConflicting = conflictingPublicFiles.length\n\n          if (numConflicting) {\n            throw new Error(\n              `Conflicting public and page file${\n                numConflicting === 1 ? ' was' : 's were'\n              } found. https://nextjs.org/docs/messages/conflicting-public-file-page\\n${conflictingPublicFiles.join(\n                '\\n'\n              )}`\n            )\n          }\n        })\n\n      const nestedReservedPages = pageKeys.pages.filter((page) => {\n        return (\n          page.match(/\\/(_app|_document|_error)$/) && path.dirname(page) !== '/'\n        )\n      })\n\n      if (nestedReservedPages.length) {\n        Log.warn(\n          `The following reserved Next.js pages were detected not directly under the pages directory:\\n` +\n            nestedReservedPages.join('\\n') +\n            `\\nSee more info here: https://nextjs.org/docs/messages/nested-reserved-page\\n`\n        )\n      }\n\n      const restrictedRedirectPaths = ['/_next'].map((p) =>\n        config.basePath ? `${config.basePath}${p}` : p\n      )\n\n      const isAppCacheComponentsEnabled = Boolean(\n        config.experimental.cacheComponents\n      )\n      const isAuthInterruptsEnabled = Boolean(\n        config.experimental.authInterrupts\n      )\n      const isAppPPREnabled = checkIsAppPPREnabled(config.experimental.ppr)\n\n      const routesManifestPath = path.join(distDir, ROUTES_MANIFEST)\n      const dynamicRoutes: Array<DynamicManifestRoute> = []\n\n      /**\n       * A map of all the pages to their sourcePage value. This is only used for\n       * routes that have PPR enabled and clientSegmentEnabled is true.\n       */\n      const sourcePages = new Map<string, string>()\n      const routesManifest: RoutesManifest = nextBuildSpan\n        .traceChild('generate-routes-manifest')\n        .traceFn(() => {\n          const sortedRoutes = sortPages([\n            ...pageKeys.pages,\n            ...(pageKeys.app ?? []),\n          ])\n          const staticRoutes: Array<ManifestRoute> = []\n\n          for (const route of sortedRoutes) {\n            if (isDynamicRoute(route)) {\n              dynamicRoutes.push(\n                pageToRoute(\n                  route,\n                  // This property is only relevant when PPR is enabled.\n                  undefined\n                )\n              )\n            } else if (!isReservedPage(route)) {\n              staticRoutes.push(pageToRoute(route))\n            }\n          }\n\n          return {\n            version: 3,\n            pages404: true,\n            caseSensitive: !!config.experimental.caseSensitiveRoutes,\n            basePath: config.basePath,\n            redirects: redirects.map((r) =>\n              buildCustomRoute('redirect', r, restrictedRedirectPaths)\n            ),\n            headers: headers.map((r) => buildCustomRoute('header', r)),\n            rewrites: {\n              beforeFiles: rewrites.beforeFiles.map((r) =>\n                buildCustomRoute('rewrite', r)\n              ),\n              afterFiles: rewrites.afterFiles.map((r) =>\n                buildCustomRoute('rewrite', r)\n              ),\n              fallback: rewrites.fallback.map((r) =>\n                buildCustomRoute('rewrite', r)\n              ),\n            },\n            dynamicRoutes,\n            staticRoutes,\n            dataRoutes: [],\n            i18n: config.i18n || undefined,\n            rsc: {\n              header: RSC_HEADER,\n              // This vary header is used as a default. It is technically re-assigned in `base-server`,\n              // and may include an additional Vary option for `Next-URL`.\n              varyHeader: `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`,\n              prefetchHeader: NEXT_ROUTER_PREFETCH_HEADER,\n              didPostponeHeader: NEXT_DID_POSTPONE_HEADER,\n              contentTypeHeader: RSC_CONTENT_TYPE_HEADER,\n              suffix: RSC_SUFFIX,\n              prefetchSuffix: RSC_PREFETCH_SUFFIX,\n              prefetchSegmentHeader: NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n              prefetchSegmentSuffix: RSC_SEGMENT_SUFFIX,\n              prefetchSegmentDirSuffix: RSC_SEGMENTS_DIR_SUFFIX,\n              clientParamParsing:\n                // NOTE: once this is the default for `clientSegmentCache`, this\n                // should exclusively be based on the `clientSegmentCache` flag.\n                config.experimental.clientParamParsing ?? false,\n              clientParamParsingOrigins: config.experimental.clientParamParsing\n                ? config.experimental.clientParamParsingOrigins\n                : undefined,\n              dynamicRSCPrerender:\n                // Only enable RDC for Navigations if the feature is enabled.\n                // Once we've made RDC for Navigations the default for PPR, we\n                // can remove the check for `config.experimental.rdcForNavigations`.\n                isAppPPREnabled &&\n                config.experimental.rdcForNavigations === true &&\n                // Temporarily we require that clientParamParsing is enabled for\n                // RDC for Navigations. This is due to a builder configuration\n                // bug that manifests as invalid query params being passed to\n                // the resume lambdas.\n                config.experimental.clientParamParsing === true,\n            },\n            rewriteHeaders: {\n              pathHeader: NEXT_REWRITTEN_PATH_HEADER,\n              queryHeader: NEXT_REWRITTEN_QUERY_HEADER,\n            },\n            skipMiddlewareUrlNormalize: config.skipMiddlewareUrlNormalize,\n            ppr: isAppPPREnabled\n              ? {\n                  chain: {\n                    headers: {\n                      [NEXT_RESUME_HEADER]: '1',\n                    },\n                  },\n                }\n              : undefined,\n          } satisfies RoutesManifest\n        })\n\n      // For pages directory, we run type checking after route collection but before build.\n      if (!appDir && !isCompileMode) {\n        await startTypeChecking(typeCheckingOptions)\n      }\n\n      let clientRouterFilters:\n        | undefined\n        | ReturnType<typeof createClientRouterFilter>\n\n      if (config.experimental.clientRouterFilter) {\n        const nonInternalRedirects = (config._originalRedirects || []).filter(\n          (r: any) => !r.internal\n        )\n        clientRouterFilters = createClientRouterFilter(\n          [...appPaths],\n          config.experimental.clientRouterFilterRedirects\n            ? nonInternalRedirects\n            : [],\n          config.experimental.clientRouterFilterAllowedRate\n        )\n        NextBuildContext.clientRouterFilters = clientRouterFilters\n      }\n\n      // Ensure commonjs handling is used for files in the distDir (generally .next)\n      // Files outside of the distDir can be \"type\": \"module\"\n      await writeFileUtf8(\n        path.join(distDir, 'package.json'),\n        '{\"type\": \"commonjs\"}'\n      )\n\n      // These are written to distDir, so they need to come after creating and cleaning distDr.\n      await recordFrameworkVersion(process.env.__NEXT_VERSION as string)\n      await updateBuildDiagnostics({\n        buildStage: 'start',\n      })\n\n      const outputFileTracingRoot = config.outputFileTracingRoot || dir\n\n      const pagesManifestPath = path.join(\n        distDir,\n        SERVER_DIRECTORY,\n        PAGES_MANIFEST\n      )\n\n      let buildTraceContext: undefined | BuildTraceContext\n      let buildTracesPromise: Promise<any> | undefined = undefined\n\n      // If there's has a custom webpack config and disable the build worker.\n      // Otherwise respect the option if it's set.\n      const useBuildWorker =\n        config.experimental.webpackBuildWorker ||\n        (config.experimental.webpackBuildWorker === undefined &&\n          !config.webpack)\n      const runServerAndEdgeInParallel =\n        config.experimental.parallelServerCompiles\n      const collectServerBuildTracesInParallel =\n        config.experimental.parallelServerBuildTraces ||\n        (config.experimental.parallelServerBuildTraces === undefined &&\n          isCompileMode)\n\n      nextBuildSpan.setAttribute(\n        'has-custom-webpack-config',\n        String(!!config.webpack)\n      )\n      nextBuildSpan.setAttribute('use-build-worker', String(useBuildWorker))\n\n      if (\n        !useBuildWorker &&\n        (runServerAndEdgeInParallel || collectServerBuildTracesInParallel)\n      ) {\n        throw new Error(\n          'The \"parallelServerBuildTraces\" and \"parallelServerCompiles\" options may only be used when build workers can be used. Read more: https://nextjs.org/docs/messages/parallel-build-without-worker'\n        )\n      }\n\n      Log.info('Creating an optimized production build ...')\n      traceMemoryUsage('Starting build', nextBuildSpan)\n\n      await updateBuildDiagnostics({\n        buildStage: 'compile',\n        buildOptions: {\n          useBuildWorker: String(useBuildWorker),\n        },\n      })\n\n      let shutdownPromise = Promise.resolve()\n      if (!isGenerateMode) {\n        if (bundler === Bundler.Turbopack) {\n          const {\n            duration: compilerDuration,\n            shutdownPromise: p,\n            ...rest\n          } = await turbopackBuild(\n            process.env.NEXT_TURBOPACK_USE_WORKER === undefined ||\n              process.env.NEXT_TURBOPACK_USE_WORKER !== '0'\n          )\n          shutdownPromise = p\n          traceMemoryUsage('Finished build', nextBuildSpan)\n\n          buildTraceContext = rest.buildTraceContext\n\n          const durationString = durationToString(compilerDuration)\n          Log.event(`Compiled successfully in ${durationString}`)\n\n          telemetry.record(\n            eventBuildCompleted(pagesPaths, {\n              bundler: 'turbopack',\n              durationInSeconds: Math.round(compilerDuration),\n              totalAppPagesCount,\n            })\n          )\n        } else {\n          if (\n            runServerAndEdgeInParallel ||\n            collectServerBuildTracesInParallel\n          ) {\n            let durationInSeconds = 0\n\n            await updateBuildDiagnostics({\n              buildStage: 'compile-server',\n            })\n\n            const serverBuildPromise = webpackBuild(useBuildWorker, [\n              'server',\n            ]).then((res) => {\n              traceMemoryUsage('Finished server compilation', nextBuildSpan)\n              buildTraceContext = res.buildTraceContext\n              durationInSeconds += res.duration\n\n              if (collectServerBuildTracesInParallel) {\n                const buildTraceWorker = new Worker(\n                  require.resolve('./collect-build-traces'),\n                  {\n                    debuggerPortOffset: -1,\n                    isolatedMemory: false,\n                    numWorkers: 1,\n                    exposedMethods: ['collectBuildTraces'],\n                  }\n                ) as Worker & typeof import('./collect-build-traces')\n\n                buildTracesPromise = nextBuildSpan\n                  .traceChild('collect-build-traces')\n                  .traceAsyncFn(() => {\n                    return buildTraceWorker\n                      .collectBuildTraces({\n                        dir,\n                        config,\n                        distDir,\n                        // Serialize Map as this is sent to the worker.\n                        edgeRuntimeRoutes: collectRoutesUsingEdgeRuntime(\n                          new Map()\n                        ),\n                        staticPages: [],\n                        buildTraceContext,\n                        outputFileTracingRoot,\n                      })\n                      .catch((err) => {\n                        console.error(err)\n                        process.exit(1)\n                      })\n                  })\n              }\n            })\n            if (!runServerAndEdgeInParallel) {\n              await serverBuildPromise\n              await updateBuildDiagnostics({\n                buildStage: 'webpack-compile-edge-server',\n              })\n            }\n\n            const edgeBuildPromise = webpackBuild(useBuildWorker, [\n              'edge-server',\n            ]).then((res) => {\n              durationInSeconds += res.duration\n              traceMemoryUsage(\n                'Finished edge-server compilation',\n                nextBuildSpan\n              )\n            })\n            if (runServerAndEdgeInParallel) {\n              await serverBuildPromise\n              await updateBuildDiagnostics({\n                buildStage: 'webpack-compile-edge-server',\n              })\n            }\n            await edgeBuildPromise\n\n            await updateBuildDiagnostics({\n              buildStage: 'webpack-compile-client',\n            })\n\n            await webpackBuild(useBuildWorker, ['client']).then((res) => {\n              durationInSeconds += res.duration\n              traceMemoryUsage('Finished client compilation', nextBuildSpan)\n            })\n\n            const durationString = durationToString(durationInSeconds)\n            Log.event(`Compiled successfully in ${durationString}`)\n\n            telemetry.record(\n              eventBuildCompleted(pagesPaths, {\n                bundler: getBundlerForTelemetry(bundler),\n                durationInSeconds,\n                totalAppPagesCount,\n              })\n            )\n          } else {\n            const { duration: compilerDuration, ...rest } = await webpackBuild(\n              useBuildWorker,\n              null\n            )\n            traceMemoryUsage('Finished build', nextBuildSpan)\n\n            buildTraceContext = rest.buildTraceContext\n\n            telemetry.record(\n              eventBuildCompleted(pagesPaths, {\n                bundler: getBundlerForTelemetry(bundler),\n                durationInSeconds: compilerDuration,\n                totalAppPagesCount,\n              })\n            )\n          }\n        }\n        await runAfterProductionCompile({\n          config,\n          buildSpan: nextBuildSpan,\n          telemetry,\n          metadata: {\n            projectDir: dir,\n            distDir,\n          },\n        })\n      }\n\n      // For app directory, we run type checking after build.\n      if (appDir && !isCompileMode && !isGenerateMode) {\n        await updateBuildDiagnostics({\n          buildStage: 'type-checking',\n        })\n        await startTypeChecking(typeCheckingOptions)\n        traceMemoryUsage('Finished type checking', nextBuildSpan)\n      }\n\n      const collectingPageDataStart = process.hrtime()\n      const postCompileSpinner = createSpinner('Collecting page data')\n\n      const buildManifestPath = path.join(distDir, BUILD_MANIFEST)\n\n      let staticAppPagesCount = 0\n      let serverAppPagesCount = 0\n      let edgeRuntimeAppCount = 0\n      let edgeRuntimePagesCount = 0\n      const ssgPages = new Set<string>()\n      const ssgStaticFallbackPages = new Set<string>()\n      const ssgBlockingFallbackPages = new Set<string>()\n      const staticPages = new Set<string>()\n      const invalidPages = new Set<string>()\n      const serverPropsPages = new Set<string>()\n      const additionalPaths = new Map<string, PrerenderedRoute[]>()\n      const staticPaths = new Map<string, PrerenderedRoute[]>()\n      const appNormalizedPaths = new Map<string, string>()\n      const fallbackModes = new Map<string, FallbackMode>()\n      const appDefaultConfigs = new Map<string, AppSegmentConfig>()\n      const pageInfos: PageInfos = new Map<string, PageInfo>()\n      let pagesManifest = await readManifest<PagesManifest>(pagesManifestPath)\n      const buildManifest = await readManifest<BuildManifest>(buildManifestPath)\n\n      const appPathRoutes: Record<string, string> = {}\n\n      if (appDir) {\n        const appPathsManifest = await readManifest<Record<string, string>>(\n          path.join(distDir, SERVER_DIRECTORY, APP_PATHS_MANIFEST)\n        )\n\n        for (const key in appPathsManifest) {\n          appPathRoutes[key] = normalizeAppPath(key)\n        }\n\n        await writeManifest(\n          path.join(distDir, APP_PATH_ROUTES_MANIFEST),\n          appPathRoutes\n        )\n      }\n\n      process.env.NEXT_PHASE = PHASE_PRODUCTION_BUILD\n\n      const worker = createStaticWorker(config, { debuggerPortOffset: -1 })\n\n      const analysisBegin = process.hrtime()\n      const staticCheckSpan = nextBuildSpan.traceChild('static-check')\n\n      const functionsConfigManifest: FunctionsConfigManifest = {\n        version: 1,\n        functions: {},\n      }\n\n      const {\n        customAppGetInitialProps,\n        namedExports,\n        isNextImageImported,\n        hasNonStaticErrorPage,\n      } = await staticCheckSpan.traceAsyncFn(async () => {\n        if (isCompileMode) {\n          return {\n            customAppGetInitialProps: false,\n            namedExports: [],\n            isNextImageImported: true,\n            hasNonStaticErrorPage: hasUserPagesRoutes,\n          }\n        }\n\n        const { configFileName } = config\n        const sriEnabled = Boolean(config.experimental.sri?.algorithm)\n\n        const nonStaticErrorPageSpan = staticCheckSpan.traceChild(\n          'check-static-error-page'\n        )\n        const errorPageHasCustomGetInitialProps =\n          nonStaticErrorPageSpan.traceAsyncFn(\n            async () =>\n              hasCustomErrorPage &&\n              (await worker.hasCustomGetInitialProps({\n                page: '/_error',\n                distDir,\n                checkingApp: false,\n                sriEnabled,\n              }))\n          )\n\n        const errorPageStaticResult = nonStaticErrorPageSpan.traceAsyncFn(\n          async () =>\n            hasCustomErrorPage &&\n            worker.isPageStatic({\n              dir,\n              page: '/_error',\n              distDir,\n              configFileName,\n              cacheComponents: isAppCacheComponentsEnabled,\n              authInterrupts: isAuthInterruptsEnabled,\n              httpAgentOptions: config.httpAgentOptions,\n              locales: config.i18n?.locales,\n              defaultLocale: config.i18n?.defaultLocale,\n              nextConfigOutput: config.output,\n              pprConfig: config.experimental.ppr,\n              cacheLifeProfiles: config.experimental.cacheLife,\n              buildId,\n              sriEnabled,\n            })\n        )\n\n        const appPageToCheck = '/_app'\n\n        const customAppGetInitialPropsPromise = hasUserPagesRoutes\n          ? worker.hasCustomGetInitialProps({\n              page: appPageToCheck,\n              distDir,\n              checkingApp: true,\n              sriEnabled,\n            })\n          : Promise.resolve(false)\n\n        const namedExportsPromise = hasUserPagesRoutes\n          ? worker.getDefinedNamedExports({\n              page: appPageToCheck,\n              distDir,\n              sriEnabled,\n            })\n          : Promise.resolve([])\n\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        let isNextImageImported: boolean | undefined\n\n        const middlewareManifest: MiddlewareManifest = require(\n          path.join(distDir, SERVER_DIRECTORY, MIDDLEWARE_MANIFEST)\n        )\n\n        const actionManifest = appDir\n          ? (require(\n              path.join(\n                distDir,\n                SERVER_DIRECTORY,\n                SERVER_REFERENCE_MANIFEST + '.json'\n              )\n            ) as ActionManifest)\n          : null\n        const entriesWithAction = actionManifest ? new Set() : null\n        if (actionManifest && entriesWithAction) {\n          for (const id in actionManifest.node) {\n            for (const entry in actionManifest.node[id].workers) {\n              entriesWithAction.add(entry)\n            }\n          }\n          for (const id in actionManifest.edge) {\n            for (const entry in actionManifest.edge[id].workers) {\n              entriesWithAction.add(entry)\n            }\n          }\n        }\n\n        for (const key of Object.keys(middlewareManifest?.functions)) {\n          if (key.startsWith('/api')) {\n            edgeRuntimePagesCount++\n          }\n        }\n\n        await Promise.all(\n          Object.entries(pageKeys)\n            .reduce<Array<{ pageType: keyof typeof pageKeys; page: string }>>(\n              (acc, [key, files]) => {\n                if (!files) {\n                  return acc\n                }\n\n                const pageType = key as keyof typeof pageKeys\n\n                for (const page of files) {\n                  acc.push({ pageType, page })\n                }\n\n                return acc\n              },\n              []\n            )\n            .map(({ pageType, page }) => {\n              const checkPageSpan = staticCheckSpan.traceChild('check-page', {\n                page,\n              })\n              return checkPageSpan.traceAsyncFn(async () => {\n                const actualPage = normalizePagePath(page)\n\n                let isRoutePPREnabled = false\n                let isSSG = false\n                let isStatic = false\n                let isServerComponent = false\n                let ssgPageRoutes: string[] | null = null\n                let pagePath = ''\n\n                if (pageType === 'pages') {\n                  pagePath =\n                    pagesPaths.find((p) => {\n                      p = normalizePathSep(p)\n                      return (\n                        p.startsWith(actualPage + '.') ||\n                        p.startsWith(actualPage + '/index.')\n                      )\n                    }) || ''\n                }\n                let originalAppPath: string | undefined\n\n                if (pageType === 'app' && mappedAppPages) {\n                  for (const [originalPath, normalizedPath] of Object.entries(\n                    appPathRoutes\n                  )) {\n                    if (normalizedPath === page) {\n                      pagePath = mappedAppPages[originalPath].replace(\n                        /^private-next-app-dir/,\n                        ''\n                      )\n                      originalAppPath = originalPath\n                      break\n                    }\n                  }\n                }\n\n                const pageFilePath = isAppBuiltinPage(pagePath)\n                  ? pagePath\n                  : path.join(\n                      (pageType === 'pages' ? pagesDir : appDir) || '',\n                      pagePath\n                    )\n\n                const isInsideAppDir = pageType === 'app'\n                const staticInfo = pagePath\n                  ? await getStaticInfoIncludingLayouts({\n                      isInsideAppDir,\n                      pageFilePath,\n                      pageExtensions: config.pageExtensions,\n                      appDir,\n                      config,\n                      isDev: false,\n                      // If this route is an App Router page route, inherit the\n                      // route segment configs (e.g. `runtime`) from the layout by\n                      // passing the `originalAppPath`, which should end with `/page`.\n                      page: isInsideAppDir ? originalAppPath! : page,\n                    })\n                  : undefined\n\n                if (staticInfo?.hadUnsupportedValue) {\n                  errorFromUnsupportedSegmentConfig()\n                }\n\n                // If there's any thing that would contribute to the functions\n                // configuration, we need to add it to the manifest.\n                if (\n                  typeof staticInfo?.runtime !== 'undefined' ||\n                  typeof staticInfo?.maxDuration !== 'undefined' ||\n                  typeof staticInfo?.preferredRegion !== 'undefined'\n                ) {\n                  const regions = staticInfo?.preferredRegion\n                    ? typeof staticInfo.preferredRegion === 'string'\n                      ? [staticInfo.preferredRegion]\n                      : staticInfo.preferredRegion\n                    : undefined\n\n                  functionsConfigManifest.functions[page] = {\n                    maxDuration: staticInfo?.maxDuration,\n                    ...(regions && { regions }),\n                  }\n                }\n\n                const pageRuntime = middlewareManifest.functions[\n                  originalAppPath || page\n                ]\n                  ? 'edge'\n                  : staticInfo?.runtime\n\n                if (!isCompileMode) {\n                  isServerComponent =\n                    pageType === 'app' &&\n                    staticInfo?.rsc !== RSC_MODULE_TYPES.client\n\n                  if (pageType === 'app' || !isReservedPage(page)) {\n                    try {\n                      let edgeInfo: any\n\n                      if (isEdgeRuntime(pageRuntime)) {\n                        if (pageType === 'app') {\n                          edgeRuntimeAppCount++\n                        } else {\n                          edgeRuntimePagesCount++\n                        }\n\n                        const manifestKey =\n                          pageType === 'pages' ? page : originalAppPath || ''\n\n                        edgeInfo = middlewareManifest.functions[manifestKey]\n                      }\n\n                      let isPageStaticSpan =\n                        checkPageSpan.traceChild('is-page-static')\n                      let workerResult = await isPageStaticSpan.traceAsyncFn(\n                        () => {\n                          return worker.isPageStatic({\n                            dir,\n                            page,\n                            originalAppPath,\n                            distDir,\n                            configFileName,\n                            httpAgentOptions: config.httpAgentOptions,\n                            locales: config.i18n?.locales,\n                            defaultLocale: config.i18n?.defaultLocale,\n                            parentId: isPageStaticSpan.getId(),\n                            pageRuntime,\n                            edgeInfo,\n                            pageType,\n                            cacheComponents: isAppCacheComponentsEnabled,\n                            authInterrupts: isAuthInterruptsEnabled,\n                            cacheHandler: config.cacheHandler,\n                            cacheHandlers: config.experimental.cacheHandlers,\n                            isrFlushToDisk: ciEnvironment.hasNextSupport\n                              ? false\n                              : config.experimental.isrFlushToDisk,\n                            maxMemoryCacheSize: config.cacheMaxMemorySize,\n                            nextConfigOutput: config.output,\n                            pprConfig: config.experimental.ppr,\n                            cacheLifeProfiles: config.experimental.cacheLife,\n                            buildId,\n                            sriEnabled,\n                          })\n                        }\n                      )\n\n                      if (pageType === 'app' && originalAppPath) {\n                        appNormalizedPaths.set(originalAppPath, page)\n                        // TODO-APP: handle prerendering with edge\n                        if (isEdgeRuntime(pageRuntime)) {\n                          isStatic = false\n                          isSSG = false\n\n                          Log.warnOnce(\n                            `Using edge runtime on a page currently disables static generation for that page`\n                          )\n                        } else {\n                          const isDynamic = isDynamicRoute(page)\n\n                          if (\n                            typeof workerResult.isRoutePPREnabled === 'boolean'\n                          ) {\n                            isRoutePPREnabled = workerResult.isRoutePPREnabled\n                          }\n\n                          // If this route can be partially pre-rendered, then\n                          // mark it as such and mark that it can be\n                          // generated server-side.\n                          if (workerResult.isRoutePPREnabled) {\n                            isSSG = true\n                            isStatic = true\n\n                            staticPaths.set(originalAppPath, [])\n                          }\n\n                          if (workerResult.prerenderedRoutes) {\n                            staticPaths.set(\n                              originalAppPath,\n                              workerResult.prerenderedRoutes\n                            )\n                            ssgPageRoutes = workerResult.prerenderedRoutes.map(\n                              (route) => route.pathname\n                            )\n                            isSSG = true\n                          }\n\n                          const appConfig = workerResult.appConfig || {}\n                          if (appConfig.revalidate !== 0) {\n                            const hasGenerateStaticParams =\n                              workerResult.prerenderedRoutes &&\n                              workerResult.prerenderedRoutes.length > 0\n\n                            if (\n                              config.output === 'export' &&\n                              isDynamic &&\n                              !hasGenerateStaticParams\n                            ) {\n                              throw new Error(\n                                `Page \"${page}\" is missing \"generateStaticParams()\" so it cannot be used with \"output: export\" config.`\n                              )\n                            }\n\n                            // Mark the app as static if:\n                            // - It has no dynamic param\n                            // - It doesn't have generateStaticParams but `dynamic` is set to\n                            //   `error` or `force-static`\n                            if (!isDynamic) {\n                              staticPaths.set(originalAppPath, [\n                                {\n                                  params: {},\n                                  pathname: page,\n                                  encodedPathname: page,\n                                  fallbackRouteParams: [],\n                                  fallbackMode:\n                                    workerResult.prerenderFallbackMode,\n                                  fallbackRootParams: [],\n                                  throwOnEmptyStaticShell: true,\n                                },\n                              ])\n                              isStatic = true\n                            } else if (\n                              !hasGenerateStaticParams &&\n                              (appConfig.dynamic === 'error' ||\n                                appConfig.dynamic === 'force-static')\n                            ) {\n                              staticPaths.set(originalAppPath, [])\n                              isStatic = true\n                              isRoutePPREnabled = false\n                            }\n                          }\n\n                          if (workerResult.prerenderFallbackMode) {\n                            fallbackModes.set(\n                              originalAppPath,\n                              workerResult.prerenderFallbackMode\n                            )\n                          }\n\n                          appDefaultConfigs.set(originalAppPath, appConfig)\n                        }\n                      } else {\n                        if (isEdgeRuntime(pageRuntime)) {\n                          if (workerResult.hasStaticProps) {\n                            console.warn(\n                              `\"getStaticProps\" is not yet supported fully with \"experimental-edge\", detected on ${page}`\n                            )\n                          }\n                          workerResult.isStatic = false\n                          workerResult.hasStaticProps = false\n                        }\n\n                        if (workerResult.isNextImageImported) {\n                          isNextImageImported = true\n                        }\n\n                        if (workerResult.hasStaticProps) {\n                          ssgPages.add(page)\n                          isSSG = true\n\n                          if (\n                            workerResult.prerenderedRoutes &&\n                            workerResult.prerenderedRoutes.length > 0\n                          ) {\n                            additionalPaths.set(\n                              page,\n                              workerResult.prerenderedRoutes\n                            )\n                            ssgPageRoutes = workerResult.prerenderedRoutes.map(\n                              (route) => route.pathname\n                            )\n                          }\n\n                          if (\n                            workerResult.prerenderFallbackMode ===\n                            FallbackMode.BLOCKING_STATIC_RENDER\n                          ) {\n                            ssgBlockingFallbackPages.add(page)\n                          } else if (\n                            workerResult.prerenderFallbackMode ===\n                            FallbackMode.PRERENDER\n                          ) {\n                            ssgStaticFallbackPages.add(page)\n                          }\n                        } else if (workerResult.hasServerProps) {\n                          serverPropsPages.add(page)\n                        } else if (\n                          workerResult.isStatic &&\n                          !isServerComponent &&\n                          (await customAppGetInitialPropsPromise) === false\n                        ) {\n                          staticPages.add(page)\n                          isStatic = true\n                        } else if (isServerComponent) {\n                          // This is a static server component page that doesn't have\n                          // gSP or gSSP. We still treat it as a SSG page.\n                          ssgPages.add(page)\n                          isSSG = true\n                        }\n\n                        if (hasPages404 && page === '/404') {\n                          if (\n                            !workerResult.isStatic &&\n                            !workerResult.hasStaticProps\n                          ) {\n                            throw new Error(\n                              `\\`pages/404\\` ${STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`\n                            )\n                          }\n                          // we need to ensure the 404 lambda is present since we use\n                          // it when _app has getInitialProps\n                          if (\n                            (await customAppGetInitialPropsPromise) &&\n                            !workerResult.hasStaticProps\n                          ) {\n                            staticPages.delete(page)\n                          }\n                        }\n\n                        if (\n                          STATIC_STATUS_PAGES.includes(page) &&\n                          !workerResult.isStatic &&\n                          !workerResult.hasStaticProps\n                        ) {\n                          throw new Error(\n                            `\\`pages${page}\\` ${STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`\n                          )\n                        }\n                      }\n                    } catch (err) {\n                      if (\n                        !isError(err) ||\n                        err.message !== 'INVALID_DEFAULT_EXPORT'\n                      )\n                        throw err\n                      invalidPages.add(page)\n                    }\n                  }\n\n                  if (pageType === 'app') {\n                    if (isSSG || isStatic) {\n                      staticAppPagesCount++\n                    } else {\n                      serverAppPagesCount++\n                    }\n                  }\n                }\n\n                pageInfos.set(page, {\n                  originalAppPath,\n                  isStatic,\n                  isSSG,\n                  isRoutePPREnabled,\n                  ssgPageRoutes,\n                  initialCacheControl: undefined,\n                  runtime: pageRuntime,\n                  pageDuration: undefined,\n                  ssgPageDurations: undefined,\n                  hasEmptyStaticShell: undefined,\n                })\n              })\n            })\n        )\n\n        const errorPageResult = await errorPageStaticResult\n        const nonStaticErrorPage =\n          (await errorPageHasCustomGetInitialProps) ||\n          (errorPageResult && errorPageResult.hasServerProps)\n\n        const returnValue = {\n          customAppGetInitialProps: await customAppGetInitialPropsPromise,\n          namedExports: await namedExportsPromise,\n          isNextImageImported,\n          hasNonStaticErrorPage: nonStaticErrorPage,\n        }\n\n        return returnValue\n      })\n\n      if (postCompileSpinner) {\n        const collectingPageDataEnd = process.hrtime(collectingPageDataStart)\n        postCompileSpinner.setText(\n          `Collecting page data in ${hrtimeDurationToString(collectingPageDataEnd)}`\n        )\n        postCompileSpinner.stopAndPersist()\n      }\n      traceMemoryUsage('Finished collecting page data', nextBuildSpan)\n\n      if (customAppGetInitialProps) {\n        console.warn(\n          bold(yellow(`Warning: `)) +\n            yellow(\n              `You have opted-out of Automatic Static Optimization due to \\`getInitialProps\\` in \\`pages/_app\\`. This does not opt-out pages with \\`getStaticProps\\``\n            )\n        )\n        console.warn(\n          'Read more: https://nextjs.org/docs/messages/opt-out-auto-static-optimization\\n'\n        )\n      }\n\n      const { cacheHandler } = config\n\n      const instrumentationHookEntryFiles: string[] = []\n      if (hasInstrumentationHook) {\n        instrumentationHookEntryFiles.push(\n          path.join(SERVER_DIRECTORY, `${INSTRUMENTATION_HOOK_FILENAME}.js`)\n        )\n        // If there's edge routes, append the edge instrumentation hook\n        // Turbopack generates this chunk with a hashed name and references it in middleware-manifest.\n        if (\n          bundler !== Bundler.Turbopack &&\n          (edgeRuntimeAppCount || edgeRuntimePagesCount)\n        ) {\n          instrumentationHookEntryFiles.push(\n            path.join(\n              SERVER_DIRECTORY,\n              `edge-${INSTRUMENTATION_HOOK_FILENAME}.js`\n            )\n          )\n        }\n      }\n\n      const requiredServerFilesManifest = nextBuildSpan\n        .traceChild('generate-required-server-files')\n        .traceFn(() => {\n          const normalizedCacheHandlers: Record<string, string> = {}\n\n          for (const [key, value] of Object.entries(\n            config.experimental.cacheHandlers || {}\n          )) {\n            if (key && value) {\n              normalizedCacheHandlers[key] = path.relative(distDir, value)\n            }\n          }\n\n          const serverFilesManifest: RequiredServerFilesManifest = {\n            version: 1,\n            config: {\n              ...config,\n              configFile: undefined,\n              ...(ciEnvironment.hasNextSupport\n                ? {\n                    compress: false,\n                  }\n                : {}),\n              cacheHandler: cacheHandler\n                ? path.relative(distDir, cacheHandler)\n                : config.cacheHandler,\n              experimental: {\n                ...config.experimental,\n                cacheHandlers: normalizedCacheHandlers,\n                trustHostHeader: ciEnvironment.hasNextSupport,\n                isExperimentalCompile: isCompileMode,\n              },\n            },\n            appDir: dir,\n            relativeAppDir: path.relative(outputFileTracingRoot, dir),\n            files: [\n              ROUTES_MANIFEST,\n              path.relative(distDir, pagesManifestPath),\n              BUILD_MANIFEST,\n              PRERENDER_MANIFEST,\n              path.join(SERVER_DIRECTORY, FUNCTIONS_CONFIG_MANIFEST),\n              path.join(SERVER_DIRECTORY, MIDDLEWARE_MANIFEST),\n              path.join(SERVER_DIRECTORY, MIDDLEWARE_BUILD_MANIFEST + '.js'),\n              ...(bundler !== Bundler.Turbopack\n                ? [\n                    path.join(\n                      SERVER_DIRECTORY,\n                      MIDDLEWARE_REACT_LOADABLE_MANIFEST + '.js'\n                    ),\n                    REACT_LOADABLE_MANIFEST,\n                  ]\n                : []),\n              ...(appDir\n                ? [\n                    ...(config.experimental.sri\n                      ? [\n                          path.join(\n                            SERVER_DIRECTORY,\n                            SUBRESOURCE_INTEGRITY_MANIFEST + '.js'\n                          ),\n                          path.join(\n                            SERVER_DIRECTORY,\n                            SUBRESOURCE_INTEGRITY_MANIFEST + '.json'\n                          ),\n                        ]\n                      : []),\n                    path.join(SERVER_DIRECTORY, APP_PATHS_MANIFEST),\n                    path.join(APP_PATH_ROUTES_MANIFEST),\n                    path.join(\n                      SERVER_DIRECTORY,\n                      SERVER_REFERENCE_MANIFEST + '.js'\n                    ),\n                    path.join(\n                      SERVER_DIRECTORY,\n                      SERVER_REFERENCE_MANIFEST + '.json'\n                    ),\n                  ]\n                : []),\n              ...(pagesDir && bundler !== Bundler.Turbopack\n                ? [\n                    DYNAMIC_CSS_MANIFEST + '.json',\n                    path.join(SERVER_DIRECTORY, DYNAMIC_CSS_MANIFEST + '.js'),\n                  ]\n                : []),\n              BUILD_ID_FILE,\n              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.js'),\n              path.join(SERVER_DIRECTORY, NEXT_FONT_MANIFEST + '.json'),\n              SERVER_FILES_MANIFEST,\n              ...instrumentationHookEntryFiles,\n            ]\n              .filter(nonNullable)\n              .map((file) => path.join(config.distDir, file)),\n            ignore: [] as string[],\n          }\n\n          return serverFilesManifest\n        })\n\n      const middlewareFile = rootPaths.find(\n        (p) => p.includes(MIDDLEWARE_FILENAME) || p.includes(PROXY_FILENAME)\n      )\n      let hasNodeMiddleware = false\n\n      if (middlewareFile) {\n        const staticInfo = await getStaticInfoIncludingLayouts({\n          isInsideAppDir: false,\n          pageFilePath: path.join(dir, middlewareFile),\n          config,\n          appDir,\n          pageExtensions: config.pageExtensions,\n          isDev: false,\n          page: 'middleware',\n        })\n\n        if (staticInfo.hadUnsupportedValue) {\n          errorFromUnsupportedSegmentConfig()\n        }\n\n        if (staticInfo.runtime === 'nodejs') {\n          hasNodeMiddleware = true\n          functionsConfigManifest.functions['/_middleware'] = {\n            runtime: staticInfo.runtime,\n            matchers: staticInfo.middleware?.matchers ?? [\n              {\n                regexp: '^.*$',\n                originalSource: '/:path*',\n              },\n            ],\n          }\n\n          if (bundler === Bundler.Turbopack) {\n            await writeManifest(\n              path.join(\n                distDir,\n                'static',\n                buildId,\n                TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST\n              ),\n              functionsConfigManifest.functions['/_middleware'].matchers || []\n            )\n          }\n        }\n      }\n\n      await writeFunctionsConfigManifest(distDir, functionsConfigManifest)\n\n      if (\n        bundler !== Bundler.Turbopack &&\n        !isGenerateMode &&\n        !buildTracesPromise\n      ) {\n        buildTracesPromise = nextBuildSpan\n          .traceChild('collect-build-traces')\n          .traceAsyncFn(() => {\n            return collectBuildTraces({\n              dir,\n              config,\n              distDir,\n              edgeRuntimeRoutes: collectRoutesUsingEdgeRuntime(pageInfos),\n              staticPages: [...staticPages],\n              nextBuildSpan,\n              buildTraceContext,\n              outputFileTracingRoot,\n            }).catch((err) => {\n              console.error(err)\n              process.exit(1)\n            })\n          })\n      }\n\n      if (serverPropsPages.size > 0 || ssgPages.size > 0) {\n        // We update the routes manifest after the build with the\n        // data routes since we can't determine these until after build\n        routesManifest.dataRoutes = sortPages([\n          ...serverPropsPages,\n          ...ssgPages,\n        ]).map((page) => {\n          return buildDataRoute(page, buildId)\n        })\n      }\n\n      // We need to write the manifest with rewrites before build\n      await nextBuildSpan\n        .traceChild('write-routes-manifest')\n        .traceAsyncFn(() => writeManifest(routesManifestPath, routesManifest))\n\n      // Since custom _app.js can wrap the 404 page we have to opt-out of static optimization if it has getInitialProps\n      // Only export the static 404 when there is no /_error present\n      const useStaticPages404 =\n        !customAppGetInitialProps && (!hasNonStaticErrorPage || hasPages404)\n\n      if (invalidPages.size > 0) {\n        const err = new Error(\n          `Build optimization failed: found page${\n            invalidPages.size === 1 ? '' : 's'\n          } without a React Component as default export in \\n${[...invalidPages]\n            .map((pg) => `pages${pg}`)\n            .join(\n              '\\n'\n            )}\\n\\nSee https://nextjs.org/docs/messages/page-without-valid-component for more info.\\n`\n        ) as NextError\n        err.code = 'BUILD_OPTIMIZATION_FAILED'\n        throw err\n      }\n\n      await writeBuildId(distDir, buildId)\n\n      if (config.experimental.optimizeCss) {\n        const globOrig =\n          require('next/dist/compiled/glob') as typeof import('next/dist/compiled/glob')\n\n        const cssFilePaths = await new Promise<string[]>((resolve, reject) => {\n          globOrig(\n            '**/*.css',\n            { cwd: path.join(distDir, 'static') },\n            (err, files) => {\n              if (err) {\n                return reject(err)\n              }\n              resolve(files)\n            }\n          )\n        })\n\n        requiredServerFilesManifest.files.push(\n          ...cssFilePaths.map((filePath) =>\n            path.join(config.distDir, 'static', filePath)\n          )\n        )\n      }\n\n      // Under standalone mode, we need to ensure that the cache entry debug\n      // handler is copied so that it can be used in the test. This is required\n      // for the turbopack test to run as it's more strict about the build\n      // directories. This is only used for testing and is not used in\n      // production.\n      if (\n        process.env.__NEXT_TEST_MODE &&\n        process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n      ) {\n        requiredServerFilesManifest.files.push(\n          path.relative(\n            dir,\n            path.isAbsolute(process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS)\n              ? process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n              : path.join(\n                  dir,\n                  process.env.NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS\n                )\n          )\n        )\n      }\n\n      const features: EventBuildFeatureUsage[] = [\n        {\n          featureName: 'experimental/cacheComponents',\n          invocationCount: config.experimental.cacheComponents ? 1 : 0,\n        },\n        {\n          featureName: 'experimental/optimizeCss',\n          invocationCount: config.experimental.optimizeCss ? 1 : 0,\n        },\n        {\n          featureName: 'experimental/nextScriptWorkers',\n          invocationCount: config.experimental.nextScriptWorkers ? 1 : 0,\n        },\n        {\n          featureName: 'experimental/ppr',\n          invocationCount: config.experimental.ppr ? 1 : 0,\n        },\n        {\n          featureName: 'experimental/isolatedDevBuild',\n          invocationCount: config.experimental.isolatedDevBuild ? 1 : 0,\n        },\n        {\n          featureName: 'turbopackFileSystemCache',\n          invocationCount: isFileSystemCacheEnabledForBuild(config) ? 1 : 0,\n        },\n      ]\n      telemetry.record(\n        features.map((feature) => {\n          return {\n            eventName: EVENT_BUILD_FEATURE_USAGE,\n            payload: feature,\n          }\n        })\n      )\n\n      await writeRequiredServerFilesManifest(\n        distDir,\n        requiredServerFilesManifest\n      )\n\n      // we don't need to inline for turbopack build as\n      // it will handle it's own caching separate of compile\n      if (isGenerateMode && bundler !== Bundler.Turbopack) {\n        Log.info('Inlining static env ...')\n\n        await nextBuildSpan\n          .traceChild('inline-static-env')\n          .traceAsyncFn(async () => {\n            await inlineStaticEnv({\n              distDir,\n              config,\n            })\n          })\n      }\n\n      const middlewareManifest: MiddlewareManifest = await readManifest(\n        path.join(distDir, SERVER_DIRECTORY, MIDDLEWARE_MANIFEST)\n      )\n\n      const prerenderManifest: PrerenderManifest = {\n        version: 4,\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: previewProps,\n      }\n\n      const tbdPrerenderRoutes: string[] = []\n\n      const { i18n } = config\n\n      const usedStaticStatusPages = STATIC_STATUS_PAGES.filter(\n        (page) =>\n          mappedPages[page] &&\n          mappedPages[page].startsWith('private-next-pages')\n      )\n      usedStaticStatusPages.forEach((page) => {\n        if (!ssgPages.has(page) && !customAppGetInitialProps) {\n          staticPages.add(page)\n        }\n      })\n\n      const hasPages500 = !appDirOnly && usedStaticStatusPages.includes('/500')\n      const useDefaultStatic500 =\n        !hasPages500 && !hasNonStaticErrorPage && !customAppGetInitialProps\n\n      const combinedPages = [...staticPages, ...ssgPages]\n      const isApp404Static = staticPaths.has(UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)\n      const hasStaticApp404 = hasApp404 && isApp404Static\n      const isAppGlobalErrorStatic = staticPaths.has(\n        UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY\n      )\n      const hasStaticAppGlobalError =\n        hasAppGlobalError && isAppGlobalErrorStatic\n\n      await updateBuildDiagnostics({\n        buildStage: 'static-generation',\n      })\n\n      const hasGSPAndRevalidateZero = new Set<string>()\n\n      // we need to trigger automatic exporting when we have\n      // - static 404/500\n      // - getStaticProps paths\n      // - experimental app is enabled\n      if (\n        !isCompileMode &&\n        (combinedPages.length > 0 ||\n          useStaticPages404 ||\n          useDefaultStatic500 ||\n          appDir)\n      ) {\n        const staticGenerationSpan =\n          nextBuildSpan.traceChild('static-generation')\n        await staticGenerationSpan.traceAsyncFn(async () => {\n          detectConflictingPaths(\n            [\n              ...combinedPages,\n              ...pageKeys.pages.filter((page) => !combinedPages.includes(page)),\n            ],\n            ssgPages,\n            new Map(\n              Array.from(additionalPaths.entries()).map(\n                ([page, routes]): [string, string[]] => {\n                  return [page, routes.map((route) => route.pathname)]\n                }\n              )\n            )\n          )\n\n          const sortedStaticPaths = Array.from(staticPaths.entries()).sort(\n            ([a], [b]) => a.localeCompare(b)\n          )\n\n          const exportApp = (require('../export') as typeof import('../export'))\n            .default as typeof import('../export').default\n\n          const exportConfig: NextConfigComplete = {\n            ...config,\n            // Default map will be the collection of automatic statically exported\n            // pages and incremental pages.\n            // n.b. we cannot handle this above in combinedPages because the dynamic\n            // page must be in the `pages` array, but not in the mapping.\n            exportPathMap: (defaultMap: ExportPathMap) => {\n              // Dynamically routed pages should be prerendered to be used as\n              // a client-side skeleton (fallback) while data is being fetched.\n              // This ensures the end-user never sees a 500 or slow response from the\n              // server.\n              //\n              // Note: prerendering disables automatic static optimization.\n              ssgPages.forEach((page) => {\n                if (isDynamicRoute(page)) {\n                  tbdPrerenderRoutes.push(page)\n\n                  if (ssgStaticFallbackPages.has(page)) {\n                    // Override the rendering for the dynamic page to be treated as a\n                    // fallback render.\n                    if (i18n) {\n                      defaultMap[`/${i18n.defaultLocale}${page}`] = {\n                        page,\n                        _pagesFallback: true,\n                      }\n                    } else {\n                      defaultMap[page] = {\n                        page,\n                        _pagesFallback: true,\n                      }\n                    }\n                  } else {\n                    // Remove dynamically routed pages from the default path map when\n                    // fallback behavior is disabled.\n                    delete defaultMap[page]\n                  }\n                }\n              })\n\n              // Append the \"well-known\" routes we should prerender for, e.g. blog\n              // post slugs.\n              additionalPaths.forEach((routes, page) => {\n                routes.forEach((route) => {\n                  defaultMap[route.pathname] = {\n                    page,\n                    _ssgPath: route.encodedPathname,\n                  }\n                })\n              })\n\n              if (useStaticPages404 && !appDirOnly) {\n                defaultMap['/404'] = {\n                  page: hasPages404 ? '/404' : '/_error',\n                }\n              }\n\n              if (useDefaultStatic500 && !appDirOnly) {\n                defaultMap['/500'] = {\n                  page: '/_error',\n                }\n              }\n\n              // TODO: output manifest specific to app paths and their\n              // revalidate periods and dynamicParams settings\n              sortedStaticPaths.forEach(([originalAppPath, routes]) => {\n                const appConfig = appDefaultConfigs.get(originalAppPath)\n                const isDynamicError = appConfig?.dynamic === 'error'\n\n                const isRoutePPREnabled: boolean = appConfig\n                  ? checkIsRoutePPREnabled(config.experimental.ppr, appConfig)\n                  : false\n\n                routes.forEach((route) => {\n                  // If the route has any dynamic root segments, we need to skip\n                  // rendering the route. This is because we don't support\n                  // revalidating the shells without the parameters present.\n                  // Note that we only have fallback root params if we also have\n                  // PPR enabled for this route/app already.\n                  if (\n                    route.fallbackRootParams &&\n                    route.fallbackRootParams.length > 0 &&\n                    // We don't skip rendering the route if we have the\n                    // following enabled. This is because the flight data now\n                    // does not contain any of the route params and is instead\n                    // completely static.\n                    !(\n                      config.experimental.clientSegmentCache &&\n                      config.experimental.clientParamParsing\n                    )\n                  ) {\n                    return\n                  }\n\n                  defaultMap[route.pathname] = {\n                    page: originalAppPath,\n                    _ssgPath: route.encodedPathname,\n                    _fallbackRouteParams: route.fallbackRouteParams,\n                    _isDynamicError: isDynamicError,\n                    _isAppDir: true,\n                    _isRoutePPREnabled: isRoutePPREnabled,\n                    _allowEmptyStaticShell: !route.throwOnEmptyStaticShell,\n                  }\n                })\n              })\n\n              if (i18n) {\n                for (const page of [\n                  ...staticPages,\n                  ...ssgPages,\n                  ...(useStaticPages404 ? ['/404'] : []),\n                  ...(useDefaultStatic500 ? ['/500'] : []),\n                ]) {\n                  const isSsg = ssgPages.has(page)\n                  const isDynamic = isDynamicRoute(page)\n                  const isFallback = isSsg && ssgStaticFallbackPages.has(page)\n\n                  for (const locale of i18n.locales) {\n                    // skip fallback generation for SSG pages without fallback mode\n                    if (isSsg && isDynamic && !isFallback) continue\n                    const outputPath = `/${locale}${page === '/' ? '' : page}`\n\n                    defaultMap[outputPath] = {\n                      page: defaultMap[page]?.page || page,\n                      _locale: locale,\n                      _pagesFallback: isFallback,\n                    }\n                  }\n\n                  if (isSsg) {\n                    // remove non-locale prefixed variant from defaultMap\n                    delete defaultMap[page]\n                  }\n                }\n              }\n\n              return defaultMap\n            },\n          }\n\n          const outdir = path.join(distDir, 'export')\n          const exportResult = await exportApp(\n            dir,\n            {\n              nextConfig: exportConfig,\n              enabledDirectories,\n              silent: true,\n              buildExport: true,\n              debugOutput,\n              debugPrerender,\n              pages: combinedPages,\n              outdir,\n              statusMessage: 'Generating static pages',\n              numWorkers: getNumberOfWorkers(exportConfig),\n              appDirOnly,\n            },\n            nextBuildSpan\n          )\n\n          // If there was no result, there's nothing more to do.\n          if (!exportResult) return\n\n          const getFallbackMode = (route: PrerenderedRoute) => {\n            const hasEmptyStaticShell = exportResult.byPath.get(\n              route.pathname\n            )?.hasEmptyStaticShell\n\n            // If the route has an empty static shell and is not configured to\n            // throw on empty static shell, then we should use the blocking\n            // static render mode.\n            if (\n              hasEmptyStaticShell &&\n              !route.throwOnEmptyStaticShell &&\n              route.fallbackMode === FallbackMode.PRERENDER\n            ) {\n              return FallbackMode.BLOCKING_STATIC_RENDER\n            }\n\n            // If the route has no fallback mode, then we should use the\n            // `NOT_FOUND` fallback mode.\n            if (!route.fallbackMode) {\n              return FallbackMode.NOT_FOUND\n            }\n\n            return route.fallbackMode\n          }\n\n          const getCacheControl = (\n            exportPath: string,\n            defaultRevalidate: Revalidate = false\n          ): CacheControl => {\n            const cacheControl =\n              exportResult.byPath.get(exportPath)?.cacheControl\n\n            if (!cacheControl) {\n              return { revalidate: defaultRevalidate, expire: undefined }\n            }\n\n            if (\n              cacheControl.revalidate !== false &&\n              cacheControl.revalidate > 0 &&\n              cacheControl.expire === undefined\n            ) {\n              return {\n                revalidate: cacheControl.revalidate,\n                expire: config.expireTime,\n              }\n            }\n\n            return cacheControl\n          }\n\n          if (debugOutput || process.env.NEXT_SSG_FETCH_METRICS === '1') {\n            recordFetchMetrics(exportResult)\n          }\n\n          writeTurborepoAccessTraceResult({\n            distDir: config.distDir,\n            traces: [\n              turborepoAccessTraceResult,\n              ...exportResult.turborepoAccessTraceResults.values(),\n            ],\n          })\n\n          prerenderManifest.notFoundRoutes = Array.from(\n            exportResult.ssgNotFoundPaths\n          )\n\n          // remove server bundles that were exported\n          for (const page of staticPages) {\n            const serverBundle = getPagePath(page, distDir, undefined, false)\n            await fs.unlink(serverBundle)\n          }\n\n          sortedStaticPaths.forEach(([originalAppPath, prerenderedRoutes]) => {\n            const page = appNormalizedPaths.get(originalAppPath)\n            if (!page) throw new InvariantError('Page not found')\n\n            const appConfig = appDefaultConfigs.get(originalAppPath)\n            if (!appConfig) throw new InvariantError('App config not found')\n\n            const ssgPageRoutesSet = new Set(pageInfos.get(page)?.ssgPageRoutes)\n\n            let hasRevalidateZero =\n              appConfig.revalidate === 0 ||\n              getCacheControl(page).revalidate === 0\n\n            if (hasRevalidateZero && pageInfos.get(page)?.isStatic) {\n              // if the page was marked as being static, but it contains dynamic data\n              // (ie, in the case of a static generation bailout), then it should be marked dynamic\n              pageInfos.set(page, {\n                ...(pageInfos.get(page) as PageInfo),\n                isStatic: false,\n                isSSG: false,\n              })\n            }\n\n            const isAppRouteHandler = isAppRouteRoute(originalAppPath)\n\n            // When this is an app page and PPR is enabled, the route supports\n            // partial pre-rendering.\n            const isRoutePPREnabled: true | undefined =\n              !isAppRouteHandler &&\n              checkIsRoutePPREnabled(config.experimental.ppr, appConfig)\n                ? true\n                : undefined\n\n            const htmlBotsRegexString =\n              // The htmlLimitedBots has been converted to a string during loadConfig\n              config.htmlLimitedBots || HTML_LIMITED_BOT_UA_RE_STRING\n\n            // this flag is used to selectively bypass the static cache and invoke the lambda directly\n            // to enable server actions on static routes\n            const bypassFor: RouteHas[] = [\n              { type: 'header', key: ACTION_HEADER },\n              {\n                type: 'header',\n                key: 'content-type',\n                value: 'multipart/form-data;.*',\n              },\n              // If it's PPR rendered non-static page, bypass the PPR cache when streaming metadata is enabled.\n              // This will skip the postpone data for those bots requests and instead produce a dynamic render.\n              ...(isRoutePPREnabled\n                ? [\n                    {\n                      type: 'header',\n                      key: 'user-agent',\n                      value: htmlBotsRegexString,\n                    },\n                  ]\n                : []),\n            ]\n\n            // We should collect all the dynamic routes into a single array for\n            // this page. Including the full fallback route (the original\n            // route), any routes that were generated with unknown route params\n            // should be collected and included in the dynamic routes part\n            // of the manifest instead.\n            const staticPrerenderedRoutes: PrerenderedRoute[] = []\n            const dynamicPrerenderedRoutes: PrerenderedRoute[] = []\n\n            // Sort the outputted routes to ensure consistent output. Any route\n            // though that has unknown route params will be pulled and sorted\n            // independently. This is because the routes with unknown route\n            // params will contain the dynamic path parameters, some of which\n            // may conflict with the actual prerendered routes.\n            const unsortedUnknownPrerenderRoutes: PrerenderedRoute[] = []\n            const unsortedKnownPrerenderRoutes: PrerenderedRoute[] = []\n            for (const prerenderedRoute of prerenderedRoutes) {\n              if (\n                prerenderedRoute.fallbackRouteParams &&\n                prerenderedRoute.fallbackRouteParams.length > 0\n              ) {\n                unsortedUnknownPrerenderRoutes.push(prerenderedRoute)\n              } else {\n                unsortedKnownPrerenderRoutes.push(prerenderedRoute)\n              }\n            }\n\n            const sortedUnknownPrerenderRoutes = sortPageObjects(\n              unsortedUnknownPrerenderRoutes,\n              (prerenderedRoute) => prerenderedRoute.pathname\n            )\n            const sortedKnownPrerenderRoutes = sortPageObjects(\n              unsortedKnownPrerenderRoutes,\n              (prerenderedRoute) => prerenderedRoute.pathname\n            )\n\n            prerenderedRoutes = [\n              ...sortedKnownPrerenderRoutes,\n              ...sortedUnknownPrerenderRoutes,\n            ]\n\n            for (const prerenderedRoute of prerenderedRoutes) {\n              if (\n                isRoutePPREnabled &&\n                prerenderedRoute.fallbackRouteParams &&\n                prerenderedRoute.fallbackRouteParams.length > 0\n              ) {\n                // If the route has unknown params, then we need to add it to\n                // the list of dynamic routes.\n                dynamicPrerenderedRoutes.push(prerenderedRoute)\n              } else {\n                // If the route doesn't have unknown params, then we need to\n                // add it to the list of static routes.\n                staticPrerenderedRoutes.push(prerenderedRoute)\n              }\n            }\n\n            // Handle all the static routes.\n            for (const route of staticPrerenderedRoutes) {\n              if (isDynamicRoute(page) && route.pathname === page) continue\n\n              const {\n                metadata = {},\n                hasEmptyStaticShell,\n                hasPostponed,\n              } = exportResult.byPath.get(route.pathname) ?? {}\n\n              const cacheControl = getCacheControl(\n                route.pathname,\n                appConfig.revalidate\n              )\n\n              pageInfos.set(route.pathname, {\n                ...(pageInfos.get(route.pathname) as PageInfo),\n                hasPostponed,\n                hasEmptyStaticShell,\n                initialCacheControl: cacheControl,\n              })\n\n              // update the page (eg /blog/[slug]) to also have the postpone metadata\n              pageInfos.set(page, {\n                ...(pageInfos.get(page) as PageInfo),\n                hasPostponed,\n                hasEmptyStaticShell,\n                initialCacheControl: cacheControl,\n              })\n\n              if (cacheControl.revalidate !== 0) {\n                const normalizedRoute = normalizePagePath(route.pathname)\n\n                let dataRoute: string | null\n                if (isAppRouteHandler) {\n                  dataRoute = null\n                } else {\n                  dataRoute = path.posix.join(`${normalizedRoute}${RSC_SUFFIX}`)\n                }\n\n                let prefetchDataRoute: string | null = null\n                // While we may only write the `.rsc` when the route does not\n                // have PPR enabled, we still want to generate the route when\n                // deployed so it doesn't 404. If the app has PPR enabled, we\n                // should add this key.\n                if (\n                  !isAppRouteHandler &&\n                  isAppPPREnabled &&\n                  // Don't add a prefetch data route if we have both\n                  // clientSegmentCache and clientParamParsing enabled. This is\n                  // because we don't actually use the prefetch data route in\n                  // this case. This only applies if we have PPR enabled for\n                  // this route.\n                  !(\n                    config.experimental.clientSegmentCache &&\n                    config.experimental.clientParamParsing &&\n                    isRoutePPREnabled\n                  )\n                ) {\n                  prefetchDataRoute = path.posix.join(\n                    `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n                  )\n                }\n\n                const meta = collectMeta(metadata)\n                const status =\n                  route.pathname === UNDERSCORE_NOT_FOUND_ROUTE\n                    ? 404\n                    : meta.status\n\n                prerenderManifest.routes[route.pathname] = {\n                  initialStatus: status,\n                  initialHeaders: meta.headers,\n                  renderingMode: isAppPPREnabled\n                    ? isRoutePPREnabled\n                      ? RenderingMode.PARTIALLY_STATIC\n                      : RenderingMode.STATIC\n                    : undefined,\n                  experimentalPPR: isRoutePPREnabled,\n                  experimentalBypassFor: bypassFor,\n                  initialRevalidateSeconds: cacheControl.revalidate,\n                  initialExpireSeconds: cacheControl.expire,\n                  srcRoute: page,\n                  dataRoute,\n                  prefetchDataRoute,\n                  allowHeader: ALLOWED_HEADERS,\n                }\n              } else {\n                hasRevalidateZero = true\n\n                if (ssgPageRoutesSet.has(route.pathname)) {\n                  const pageInfo = pageInfos.get(page) as PageInfo\n                  // Remove the route from the SSG page routes if it bailed out\n                  // during prerendering.\n                  ssgPageRoutesSet.delete(route.pathname)\n\n                  // Mark the route as having a GSP and revalidate zero.\n                  if (ssgPageRoutesSet.size === 0) {\n                    hasGSPAndRevalidateZero.delete(page)\n                  } else {\n                    hasGSPAndRevalidateZero.add(page)\n                  }\n\n                  pageInfos.set(page, {\n                    ...pageInfo,\n                    ssgPageRoutes: Array.from(ssgPageRoutesSet),\n                    // If there are no SSG page routes left, then the page is not SSG.\n                    isSSG: ssgPageRoutesSet.size === 0 ? false : pageInfo.isSSG,\n                  })\n                } else {\n                  // we might have determined during prerendering that this page\n                  // used dynamic data\n                  pageInfos.set(route.pathname, {\n                    ...(pageInfos.get(route.pathname) as PageInfo),\n                    isSSG: false,\n                    isStatic: false,\n                  })\n                }\n              }\n            }\n\n            if (!hasRevalidateZero && isDynamicRoute(page)) {\n              // When PPR fallbacks aren't used, we need to include it here. If\n              // they are enabled, then it'll already be included in the\n              // prerendered routes.\n              if (!isRoutePPREnabled) {\n                dynamicPrerenderedRoutes.push({\n                  params: {},\n                  pathname: page,\n                  encodedPathname: page,\n                  fallbackRouteParams: [],\n                  fallbackMode:\n                    fallbackModes.get(originalAppPath) ??\n                    FallbackMode.NOT_FOUND,\n                  fallbackRootParams: [],\n                  throwOnEmptyStaticShell: true,\n                })\n              }\n\n              for (const route of dynamicPrerenderedRoutes) {\n                const normalizedRoute = normalizePagePath(route.pathname)\n\n                const metadata = exportResult.byPath.get(\n                  route.pathname\n                )?.metadata\n\n                const cacheControl = getCacheControl(route.pathname)\n\n                let dataRoute: string | null = null\n                if (!isAppRouteHandler) {\n                  dataRoute = path.posix.join(`${normalizedRoute}${RSC_SUFFIX}`)\n                }\n\n                let prefetchDataRoute: string | null = null\n                let dynamicRoute = routesManifest.dynamicRoutes.find(\n                  (r) => r.page === route.pathname\n                )\n                if (!isAppRouteHandler && isAppPPREnabled) {\n                  if (\n                    // Don't add a prefetch data route if we have both\n                    // clientSegmentCache and clientParamParsing enabled. This is\n                    // because we don't actually use the prefetch data route in\n                    // this case. This only applies if we have PPR enabled for\n                    // this route.\n                    !config.experimental.clientSegmentCache ||\n                    !config.experimental.clientParamParsing ||\n                    !isRoutePPREnabled\n                  ) {\n                    prefetchDataRoute = path.posix.join(\n                      `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n                    )\n                  }\n\n                  // If the dynamic route wasn't found, then we need to create\n                  // it. This ensures that for each fallback shell there's an\n                  // entry in the app routes manifest which enables routing for\n                  // this fallback shell.\n                  if (!dynamicRoute) {\n                    dynamicRoute = pageToRoute(route.pathname, page)\n                    sourcePages.set(route.pathname, page)\n\n                    // This route is not for the internal router, but instead\n                    // for external routers.\n                    dynamicRoute.skipInternalRouting = true\n\n                    // Push this to the end of the array. The dynamic routes are\n                    // sorted by page later.\n                    dynamicRoutes.push(dynamicRoute)\n                  }\n                }\n\n                if (\n                  !isAppRouteHandler &&\n                  (metadata?.segmentPaths ||\n                    (route.fallbackRootParams &&\n                      route.fallbackRootParams.length > 0))\n                ) {\n                  // If PPR isn't enabled, then we might not find the dynamic\n                  // route by pathname. If that's the case, we need to find the\n                  // route by page.\n                  if (!dynamicRoute) {\n                    dynamicRoute = dynamicRoutes.find((r) => r.page === page)\n\n                    // If it can't be found by page, we must throw an error.\n                    if (!dynamicRoute) {\n                      throw new InvariantError('Dynamic route not found')\n                    }\n                  }\n\n                  if (metadata?.segmentPaths) {\n                    const pageSegmentPath = metadata.segmentPaths.find((item) =>\n                      item.endsWith('__PAGE__')\n                    )\n                    if (!pageSegmentPath) {\n                      throw new Error(`Invariant: missing __PAGE__ segmentPath`)\n                    }\n\n                    // We build a combined segment data route from the\n                    // page segment as we need to limit the number of\n                    // routes we output and they can be shared\n                    const builtSegmentDataRoute = buildPrefetchSegmentDataRoute(\n                      route.pathname,\n                      pageSegmentPath\n                    )\n\n                    builtSegmentDataRoute.source =\n                      builtSegmentDataRoute.source.replace(\n                        '/__PAGE__\\\\.segment\\\\.rsc$',\n                        `(?<segment>/__PAGE__\\\\.segment\\\\.rsc|\\\\.segment\\\\.rsc)(?:/)?$`\n                      )\n                    builtSegmentDataRoute.destination =\n                      builtSegmentDataRoute.destination.replace(\n                        '/__PAGE__.segment.rsc',\n                        '$segment'\n                      )\n                    dynamicRoute.prefetchSegmentDataRoutes ??= []\n                    dynamicRoute.prefetchSegmentDataRoutes.push(\n                      builtSegmentDataRoute\n                    )\n                  }\n                  // If the route has fallback root params, and we don't have\n                  // any segment paths, we need to write the inverse prefetch\n                  // segment data route so that it can first rewrite the /_tree\n                  // request to the prefetch RSC route. We also need to set the\n                  // `hasFallbackRootParams` flag so that we can simplify the\n                  // route regex for matching.\n                  else if (\n                    route.fallbackRootParams &&\n                    route.fallbackRootParams.length > 0\n                  ) {\n                    dynamicRoute.hasFallbackRootParams = true\n                    dynamicRoute.prefetchSegmentDataRoutes = [\n                      buildInversePrefetchSegmentDataRoute(\n                        dynamicRoute.page,\n                        // We use the special segment path of `/_tree` because it's\n                        // the first one sent by the client router so it's the only\n                        // one we need to rewrite to the regular prefetch RSC route.\n                        '/_tree'\n                      ),\n                    ]\n                  }\n                }\n\n                pageInfos.set(route.pathname, {\n                  ...(pageInfos.get(route.pathname) as PageInfo),\n                  isDynamicAppRoute: true,\n                  // if PPR is turned on and the route contains a dynamic segment,\n                  // we assume it'll be partially prerendered\n                  hasPostponed: isRoutePPREnabled,\n                })\n\n                const fallbackMode = getFallbackMode(route)\n\n                // When the route is configured to serve a prerender, we should\n                // use the cache control from the export result. If it can't be\n                // found, mark that we should keep the shell forever\n                // (revalidate: `false` via `getCacheControl()`).\n                const fallbackCacheControl =\n                  isRoutePPREnabled && fallbackMode === FallbackMode.PRERENDER\n                    ? cacheControl\n                    : undefined\n\n                const fallback: Fallback = fallbackModeToFallbackField(\n                  fallbackMode,\n                  route.pathname\n                )\n\n                const meta =\n                  metadata &&\n                  isRoutePPREnabled &&\n                  fallbackMode === FallbackMode.PRERENDER\n                    ? collectMeta(metadata)\n                    : {}\n\n                prerenderManifest.dynamicRoutes[route.pathname] = {\n                  experimentalPPR: isRoutePPREnabled,\n                  renderingMode: isAppPPREnabled\n                    ? isRoutePPREnabled\n                      ? RenderingMode.PARTIALLY_STATIC\n                      : RenderingMode.STATIC\n                    : undefined,\n                  experimentalBypassFor: bypassFor,\n                  routeRegex: normalizeRouteRegex(\n                    getNamedRouteRegex(route.pathname, {\n                      prefixRouteKeys: false,\n                    }).re.source\n                  ),\n                  dataRoute,\n                  fallback,\n                  fallbackRevalidate: fallbackCacheControl?.revalidate,\n                  fallbackExpire: fallbackCacheControl?.expire,\n                  fallbackStatus: meta.status,\n                  fallbackHeaders: meta.headers,\n                  fallbackRootParams: fallback\n                    ? route.fallbackRootParams\n                    : undefined,\n                  fallbackSourceRoute:\n                    route.fallbackRouteParams &&\n                    route.fallbackRouteParams.length > 0\n                      ? page\n                      : undefined,\n                  fallbackRouteParams: route.fallbackRouteParams,\n                  dataRouteRegex: !dataRoute\n                    ? null\n                    : normalizeRouteRegex(\n                        getNamedRouteRegex(dataRoute, {\n                          prefixRouteKeys: false,\n                          includeSuffix: true,\n                          excludeOptionalTrailingSlash: true,\n                        }).re.source\n                      ),\n                  prefetchDataRoute,\n                  prefetchDataRouteRegex: !prefetchDataRoute\n                    ? undefined\n                    : normalizeRouteRegex(\n                        getNamedRouteRegex(prefetchDataRoute, {\n                          prefixRouteKeys: false,\n                          includeSuffix: true,\n                          excludeOptionalTrailingSlash: true,\n                        }).re.source\n                      ),\n                  allowHeader: ALLOWED_HEADERS,\n                }\n              }\n            }\n          })\n\n          const moveExportedPage = async (\n            originPage: string,\n            page: string,\n            file: string,\n            isSsg: boolean,\n            ext: 'html' | 'json',\n            additionalSsgFile = false\n          ) => {\n            return staticGenerationSpan\n              .traceChild('move-exported-page')\n              .traceAsyncFn(async () => {\n                file = `${file}.${ext}`\n                const orig = path.join(outdir, file)\n                const pagePath = getPagePath(\n                  originPage,\n                  distDir,\n                  undefined,\n                  false\n                )\n\n                const relativeDest = path\n                  .relative(\n                    path.join(distDir, SERVER_DIRECTORY),\n                    path.join(\n                      path.join(\n                        pagePath,\n                        // strip leading / and then recurse number of nested dirs\n                        // to place from base folder\n                        originPage\n                          .slice(1)\n                          .split('/')\n                          .map(() => '..')\n                          .join('/')\n                      ),\n                      file\n                    )\n                  )\n                  .replace(/\\\\/g, '/')\n\n                if (\n                  !isSsg &&\n                  !(\n                    // don't add static status page to manifest if it's\n                    // the default generated version e.g. no pages/500\n                    (\n                      STATIC_STATUS_PAGES.includes(page) &&\n                      !usedStaticStatusPages.includes(page)\n                    )\n                  )\n                ) {\n                  pagesManifest[page] = relativeDest\n                }\n\n                const dest = path.join(distDir, SERVER_DIRECTORY, relativeDest)\n                const isNotFound =\n                  prerenderManifest.notFoundRoutes.includes(page)\n\n                // for SSG files with i18n the non-prerendered variants are\n                // output with the locale prefixed so don't attempt moving\n                // without the prefix\n                if ((!i18n || additionalSsgFile) && !isNotFound) {\n                  await fs.mkdir(path.dirname(dest), { recursive: true })\n                  await fs.rename(orig, dest)\n                } else if (i18n && !isSsg) {\n                  // this will be updated with the locale prefixed variant\n                  // since all files are output with the locale prefix\n                  delete pagesManifest[page]\n                }\n\n                if (i18n) {\n                  if (additionalSsgFile) return\n\n                  const localeExt = page === '/' ? path.extname(file) : ''\n                  const relativeDestNoPages = relativeDest.slice(\n                    'pages/'.length\n                  )\n\n                  for (const locale of i18n.locales) {\n                    const curPath = `/${locale}${page === '/' ? '' : page}`\n\n                    if (\n                      isSsg &&\n                      prerenderManifest.notFoundRoutes.includes(curPath)\n                    ) {\n                      continue\n                    }\n\n                    const updatedRelativeDest = path\n                      .join(\n                        'pages',\n                        locale + localeExt,\n                        // if it's the top-most index page we want it to be locale.EXT\n                        // instead of locale/index.html\n                        page === '/' ? '' : relativeDestNoPages\n                      )\n                      .replace(/\\\\/g, '/')\n\n                    const updatedOrig = path.join(\n                      outdir,\n                      locale + localeExt,\n                      page === '/' ? '' : file\n                    )\n                    const updatedDest = path.join(\n                      distDir,\n                      SERVER_DIRECTORY,\n                      updatedRelativeDest\n                    )\n\n                    if (!isSsg) {\n                      pagesManifest[curPath] = updatedRelativeDest\n                    }\n                    await fs.mkdir(path.dirname(updatedDest), {\n                      recursive: true,\n                    })\n                    await fs.rename(updatedOrig, updatedDest)\n                  }\n                }\n              })\n          }\n\n          async function moveExportedAppNotFoundTo404() {\n            return staticGenerationSpan\n              .traceChild('move-exported-app-not-found-')\n              .traceAsyncFn(async () => {\n                const orig = path.join(\n                  distDir,\n                  'server',\n                  'app',\n                  '_not-found.html'\n                )\n                const updatedRelativeDest = path\n                  .join('pages', '404.html')\n                  .replace(/\\\\/g, '/')\n\n                if (existsSync(orig)) {\n                  // if 404.html folder doesn't exist, create it\n                  await fs.mkdir(\n                    path.dirname(\n                      path.join(distDir, 'server', updatedRelativeDest)\n                    ),\n                    { recursive: true }\n                  )\n                  await fs.copyFile(\n                    orig,\n                    path.join(distDir, 'server', updatedRelativeDest)\n                  )\n\n                  // since the app router not found is prioritized over pages router,\n                  // we have to ensure the app router entries are available for all locales\n                  if (i18n) {\n                    for (const locale of i18n.locales) {\n                      const curPath = `/${locale}/404`\n                      pagesManifest[curPath] = updatedRelativeDest\n                    }\n                  }\n\n                  pagesManifest['/404'] = updatedRelativeDest\n                }\n              })\n          }\n\n          async function moveExportedAppGlobalErrorTo500() {\n            return staticGenerationSpan\n              .traceChild('move-exported-app-global-error-')\n              .traceAsyncFn(async () => {\n                // If static 500.html exists in pages router, don't move it\n                if (\n                  existsSync(path.join(distDir, 'server', 'pages', '500.html'))\n                ) {\n                  return\n                }\n\n                // Only handle 500.html generation for static export\n                const orig = path.join(\n                  distDir,\n                  'server',\n                  'app',\n                  '_global-error.html'\n                )\n                if (existsSync(orig)) {\n                  const error500Html = path.join(\n                    distDir,\n                    'server',\n                    'pages',\n                    '500.html'\n                  )\n\n                  // if 500.html folder doesn't exist, create it\n                  await fs.mkdir(path.dirname(error500Html), {\n                    recursive: true,\n                  })\n                  await fs.copyFile(orig, error500Html)\n\n                  pagesManifest['/500'] = path\n                    .join('pages', '500.html')\n                    .replace(/\\\\/g, '/')\n                }\n              })\n          }\n\n          // If there's /not-found inside app, we prefer it over the pages 404\n          if (hasStaticApp404) {\n            await moveExportedAppNotFoundTo404()\n          } else {\n            // Only move /404 to /404 when there is no custom 404 as in that case we don't know about the 404 page\n            if (\n              !hasPages404 &&\n              !hasApp404 &&\n              useStaticPages404 &&\n              !appDirOnly\n            ) {\n              await moveExportedPage('/_error', '/404', '/404', false, 'html')\n            }\n          }\n\n          if (useDefaultStatic500 && !appDirOnly) {\n            await moveExportedPage('/_error', '/500', '/500', false, 'html')\n          }\n\n          // If there's app router and no pages router, use app router built-in 500.html\n          if (\n            hasStaticAppGlobalError &&\n            mappedAppPages &&\n            Object.keys(mappedAppPages).length > 0\n          ) {\n            await moveExportedAppGlobalErrorTo500()\n          }\n\n          for (const page of combinedPages) {\n            const isSsg = ssgPages.has(page)\n            const isStaticSsgFallback = ssgStaticFallbackPages.has(page)\n            const isDynamic = isDynamicRoute(page)\n            const file = normalizePagePath(page)\n\n            const pageInfo = pageInfos.get(page)\n            const durationInfo = exportResult.byPage.get(page)\n            if (pageInfo && durationInfo) {\n              // Set Build Duration\n              if (pageInfo.ssgPageRoutes) {\n                pageInfo.ssgPageDurations = pageInfo.ssgPageRoutes.map(\n                  (pagePath) => {\n                    const duration = durationInfo.durationsByPath.get(pagePath)\n                    if (typeof duration === 'undefined') {\n                      throw new Error(\"Invariant: page wasn't built\")\n                    }\n\n                    return duration\n                  }\n                )\n              }\n              pageInfo.pageDuration = durationInfo.durationsByPath.get(page)\n            }\n\n            // The dynamic version of SSG pages are only prerendered if the\n            // fallback is enabled. Below, we handle the specific prerenders\n            // of these.\n            const hasHtmlOutput = !(isSsg && isDynamic && !isStaticSsgFallback)\n\n            if (hasHtmlOutput) {\n              await moveExportedPage(page, page, file, isSsg, 'html')\n            }\n\n            if (isSsg) {\n              // For a non-dynamic SSG page, we must copy its data file\n              // from export, we already moved the HTML file above\n              if (!isDynamic) {\n                await moveExportedPage(page, page, file, isSsg, 'json')\n\n                if (i18n) {\n                  // TODO: do we want to show all locale variants in build output\n                  for (const locale of i18n.locales) {\n                    const localePage = `/${locale}${page === '/' ? '' : page}`\n\n                    const cacheControl = getCacheControl(localePage)\n\n                    prerenderManifest.routes[localePage] = {\n                      initialRevalidateSeconds: cacheControl.revalidate,\n                      initialExpireSeconds: cacheControl.expire,\n                      experimentalPPR: undefined,\n                      renderingMode: undefined,\n                      srcRoute: null,\n                      dataRoute: path.posix.join(\n                        '/_next/data',\n                        buildId,\n                        `${localePage}.json`\n                      ),\n                      prefetchDataRoute: undefined,\n                      allowHeader: ALLOWED_HEADERS,\n                    }\n                  }\n                } else {\n                  const cacheControl = getCacheControl(page)\n\n                  prerenderManifest.routes[page] = {\n                    initialRevalidateSeconds: cacheControl.revalidate,\n                    initialExpireSeconds: cacheControl.expire,\n                    experimentalPPR: undefined,\n                    renderingMode: undefined,\n                    srcRoute: null,\n                    dataRoute: path.posix.join(\n                      '/_next/data',\n                      buildId,\n                      `${file}.json`\n                    ),\n                    // Pages does not have a prefetch data route.\n                    prefetchDataRoute: undefined,\n                    allowHeader: ALLOWED_HEADERS,\n                  }\n                }\n                if (pageInfo) {\n                  pageInfo.initialCacheControl = getCacheControl(page)\n                }\n              } else {\n                // For a dynamic SSG page, we did not copy its data exports and only\n                // copy the fallback HTML file (if present).\n                // We must also copy specific versions of this page as defined by\n                // `getStaticPaths` (additionalSsgPaths).\n                for (const route of additionalPaths.get(page) ?? []) {\n                  const pageFile = normalizePagePath(route.pathname)\n                  await moveExportedPage(\n                    page,\n                    route.pathname,\n                    pageFile,\n                    isSsg,\n                    'html',\n                    true\n                  )\n                  await moveExportedPage(\n                    page,\n                    route.pathname,\n                    pageFile,\n                    isSsg,\n                    'json',\n                    true\n                  )\n\n                  const cacheControl = getCacheControl(route.pathname)\n\n                  prerenderManifest.routes[route.pathname] = {\n                    initialRevalidateSeconds: cacheControl.revalidate,\n                    initialExpireSeconds: cacheControl.expire,\n                    experimentalPPR: undefined,\n                    renderingMode: undefined,\n                    srcRoute: page,\n                    dataRoute: path.posix.join(\n                      '/_next/data',\n                      buildId,\n                      `${normalizePagePath(route.pathname)}.json`\n                    ),\n                    // Pages does not have a prefetch data route.\n                    prefetchDataRoute: undefined,\n                    allowHeader: ALLOWED_HEADERS,\n                  }\n\n                  if (pageInfo) {\n                    pageInfo.initialCacheControl = cacheControl\n                  }\n                }\n              }\n            }\n          }\n\n          // remove temporary export folder\n          await fs.rm(outdir, { recursive: true, force: true })\n          await writeManifest(pagesManifestPath, pagesManifest)\n        })\n\n        // As we may have modified the dynamicRoutes, we need to sort the\n        // dynamic routes by page.\n        routesManifest.dynamicRoutes = sortSortableRouteObjects(\n          dynamicRoutes,\n          (route) => ({\n            // If the route is PPR enabled, and has an associated source page,\n            // use it. Otherwise fallback to the page which should be the same.\n            sourcePage: sourcePages.get(route.page) ?? route.page,\n            page: route.page,\n          })\n        )\n\n        // Now write the routes manifest out.\n        await nextBuildSpan\n          .traceChild('write-routes-manifest')\n          .traceAsyncFn(() => writeManifest(routesManifestPath, routesManifest))\n      }\n\n      const finalizingPageOptimizationStart = process.hrtime()\n      const postBuildSpinner = createSpinner('Finalizing page optimization')\n      let buildTracesSpinner\n      let buildTracesStart\n      if (buildTracesPromise) {\n        buildTracesStart = process.hrtime()\n        buildTracesSpinner = createSpinner('Collecting build traces')\n      }\n\n      // ensure the worker is not left hanging\n      worker.end()\n\n      const analysisEnd = process.hrtime(analysisBegin)\n      telemetry.record(\n        eventBuildOptimize(pagesPaths, {\n          durationInSeconds: analysisEnd[0],\n          staticPageCount: staticPages.size,\n          staticPropsPageCount: ssgPages.size,\n          serverPropsPageCount: serverPropsPages.size,\n          ssrPageCount:\n            pagesPaths.length -\n            (staticPages.size + ssgPages.size + serverPropsPages.size),\n          hasStatic404: useStaticPages404,\n          hasReportWebVitals:\n            namedExports?.includes('reportWebVitals') ?? false,\n          rewritesCount: combinedRewrites.length,\n          headersCount: headers.length,\n          redirectsCount: redirects.length - 1, // reduce one for trailing slash\n          headersWithHasCount: headers.filter((r: any) => !!r.has).length,\n          rewritesWithHasCount: combinedRewrites.filter((r: any) => !!r.has)\n            .length,\n          redirectsWithHasCount: redirects.filter((r: any) => !!r.has).length,\n          middlewareCount: hasMiddlewareFile || hasProxyFile ? 1 : 0,\n          totalAppPagesCount,\n          staticAppPagesCount,\n          serverAppPagesCount,\n          edgeRuntimeAppCount,\n          edgeRuntimePagesCount,\n        })\n      )\n\n      if (NextBuildContext.telemetryState) {\n        const events = eventBuildFeatureUsage(\n          NextBuildContext.telemetryState.usages\n        )\n        telemetry.record(events)\n        telemetry.record(\n          eventPackageUsedInGetServerSideProps(\n            NextBuildContext.telemetryState.packagesUsedInServerSideProps\n          )\n        )\n        const useCacheTracker = NextBuildContext.telemetryState.useCacheTracker\n\n        for (const [key, value] of Object.entries(useCacheTracker)) {\n          telemetry.record(\n            eventBuildFeatureUsage([\n              {\n                featureName: key as UseCacheTrackerKey,\n                invocationCount: value,\n              },\n            ])\n          )\n        }\n      }\n\n      if (ssgPages.size > 0 || appDir) {\n        tbdPrerenderRoutes.forEach((tbdRoute) => {\n          const normalizedRoute = normalizePagePath(tbdRoute)\n          const dataRoute = path.posix.join(\n            '/_next/data',\n            buildId,\n            `${normalizedRoute}.json`\n          )\n\n          prerenderManifest.dynamicRoutes[tbdRoute] = {\n            routeRegex: normalizeRouteRegex(\n              getNamedRouteRegex(tbdRoute, {\n                prefixRouteKeys: false,\n              }).re.source\n            ),\n            experimentalPPR: undefined,\n            renderingMode: undefined,\n            dataRoute,\n            fallback: ssgBlockingFallbackPages.has(tbdRoute)\n              ? null\n              : ssgStaticFallbackPages.has(tbdRoute)\n                ? `${normalizedRoute}.html`\n                : false,\n            fallbackRevalidate: undefined,\n            fallbackExpire: undefined,\n            fallbackSourceRoute: undefined,\n            fallbackRootParams: undefined,\n            fallbackRouteParams: undefined,\n            dataRouteRegex: normalizeRouteRegex(\n              getNamedRouteRegex(dataRoute, {\n                prefixRouteKeys: true,\n                includeSuffix: true,\n                excludeOptionalTrailingSlash: true,\n              }).re.source\n            ),\n            // Pages does not have a prefetch data route.\n            prefetchDataRoute: undefined,\n            prefetchDataRouteRegex: undefined,\n            allowHeader: ALLOWED_HEADERS,\n          }\n        })\n\n        NextBuildContext.previewModeId = previewProps.previewModeId\n        NextBuildContext.fetchCacheKeyPrefix =\n          config.experimental.fetchCacheKeyPrefix\n        NextBuildContext.allowedRevalidateHeaderKeys =\n          config.experimental.allowedRevalidateHeaderKeys\n\n        await writePrerenderManifest(distDir, prerenderManifest)\n        await writeClientSsgManifest(prerenderManifest, {\n          distDir,\n          buildId,\n          locales: config.i18n?.locales,\n        })\n      } else {\n        await writePrerenderManifest(distDir, {\n          version: 4,\n          routes: {},\n          dynamicRoutes: {},\n          preview: previewProps,\n          notFoundRoutes: [],\n        })\n      }\n\n      await writeImagesManifest(distDir, config)\n      await writeManifest(path.join(distDir, EXPORT_MARKER), {\n        version: 1,\n        hasExportPathMap: typeof config.exportPathMap === 'function',\n        exportTrailingSlash: config.trailingSlash === true,\n        isNextImageImported: isNextImageImported === true,\n      })\n      await fs.unlink(path.join(distDir, EXPORT_DETAIL)).catch((err) => {\n        if (err.code === 'ENOENT') {\n          return Promise.resolve()\n        }\n        return Promise.reject(err)\n      })\n\n      if (Boolean(config.experimental.nextScriptWorkers)) {\n        await nextBuildSpan\n          .traceChild('verify-partytown-setup')\n          .traceAsyncFn(async () => {\n            await verifyPartytownSetup(\n              dir,\n              path.join(distDir, CLIENT_STATIC_FILES_PATH)\n            )\n          })\n      }\n\n      await buildTracesPromise\n\n      if (buildTracesSpinner) {\n        if (buildTracesStart) {\n          const buildTracesEnd = process.hrtime(buildTracesStart)\n          buildTracesSpinner.setText(\n            `Collecting build traces in ${hrtimeDurationToString(buildTracesEnd)}`\n          )\n        }\n        buildTracesSpinner.stopAndPersist()\n        buildTracesSpinner = undefined\n      }\n\n      if (isCompileMode) {\n        Log.info(\n          `Build ran with \"compile\" mode, to finalize the build run either \"generate\" or \"generate-env\" mode as well`\n        )\n      }\n\n      if (config.output === 'export') {\n        await nextBuildSpan\n          .traceChild('output-export-full-static-export')\n          .traceAsyncFn(async () => {\n            await writeFullyStaticExport(\n              config,\n              dir,\n              enabledDirectories,\n              configOutDir,\n              nextBuildSpan,\n              appDirOnly\n            )\n          })\n      }\n\n      // This should come after output: export handling but before\n      // output: standalone, in the future output: standalone might\n      // not be allowed if an adapter with onBuildComplete is configured\n      const adapterPath = config.experimental.adapterPath\n      if (adapterPath) {\n        await nextBuildSpan\n          .traceChild('adapter-handle-build-complete')\n          .traceAsyncFn(async () => {\n            await handleBuildComplete({\n              dir,\n              distDir,\n              config,\n              configOutDir: path.join(dir, configOutDir),\n              staticPages,\n              nextVersion: process.env.__NEXT_VERSION as string,\n              tracingRoot: outputFileTracingRoot,\n              hasNodeMiddleware,\n              hasInstrumentationHook,\n              adapterPath,\n              pageKeys: pageKeys.pages,\n              appPageKeys: denormalizedAppPages,\n              routesManifest,\n              prerenderManifest,\n              middlewareManifest,\n              functionsConfigManifest,\n              hasStatic404: useStaticPages404,\n              requiredServerFiles: requiredServerFilesManifest.files,\n            })\n          })\n      }\n\n      if (config.output === 'standalone') {\n        await nextBuildSpan\n          .traceChild('output-standalone')\n          .traceAsyncFn(async () => {\n            await writeStandaloneDirectory(\n              nextBuildSpan,\n              distDir,\n              pageKeys,\n              denormalizedAppPages,\n              outputFileTracingRoot,\n              requiredServerFilesManifest,\n              middlewareManifest,\n              hasNodeMiddleware,\n              hasInstrumentationHook,\n              staticPages,\n              loadedEnvFiles,\n              appDir\n            )\n          })\n      }\n\n      if (postBuildSpinner) {\n        const finalizingPageOptimizationEnd = process.hrtime(\n          finalizingPageOptimizationStart\n        )\n        postBuildSpinner.setText(\n          `Finalizing page optimization in ${hrtimeDurationToString(finalizingPageOptimizationEnd)}`\n        )\n        postBuildSpinner.stopAndPersist()\n      }\n      console.log()\n\n      if (debugOutput) {\n        nextBuildSpan\n          .traceChild('print-custom-routes')\n          .traceFn(() => printCustomRoutes({ redirects, rewrites, headers }))\n      }\n\n      await nextBuildSpan.traceChild('print-tree-view').traceAsyncFn(() =>\n        printTreeView(pageKeys, pageInfos, {\n          pagesDir,\n          useStaticPages404,\n          pageExtensions: config.pageExtensions,\n          buildManifest,\n          middlewareManifest,\n          hasGSPAndRevalidateZero,\n        })\n      )\n\n      await nextBuildSpan\n        .traceChild('telemetry-flush')\n        .traceAsyncFn(() => telemetry.flush())\n\n      await shutdownPromise\n    })\n  } catch (e) {\n    const telemetry: Telemetry | undefined = traceGlobals.get('telemetry')\n    if (telemetry) {\n      telemetry.record(\n        eventBuildFailed({\n          bundler: getBundlerForTelemetry(bundler),\n          errorCode: getErrorCodeForTelemetry(e),\n          durationInSeconds: Math.floor((Date.now() - buildStartTime) / 1000),\n        })\n      )\n    }\n    throw e\n  } finally {\n    // Ensure we wait for lockfile patching if present\n    await lockfilePatchPromise.cur\n\n    // Ensure all traces are flushed before finishing the command\n    await flushAllTraces()\n    teardownTraceSubscriber()\n\n    if (traceUploadUrl && loadedConfig) {\n      uploadTrace({\n        traceUploadUrl,\n        mode: 'build',\n        projectDir: dir,\n        distDir: loadedConfig.distDir,\n        isTurboSession: bundler === Bundler.Turbopack,\n        sync: true,\n      })\n    }\n  }\n}\n\nfunction errorFromUnsupportedSegmentConfig(): never {\n  Log.error(\n    `Invalid segment configuration export detected. This can cause unexpected behavior from the configs not being applied. You should see the relevant failures in the logs above. Please fix them to continue.`\n  )\n  process.exit(1)\n}\n\nfunction getBundlerForTelemetry(bundler: Bundler) {\n  switch (bundler) {\n    case Bundler.Turbopack:\n      return 'turbopack'\n    case Bundler.Rspack:\n      return 'rspack'\n    case Bundler.Webpack:\n      return 'webpack'\n    default:\n      throw new Error(`unknown bundler: ${bundler}`)\n  }\n}\n\nfunction getErrorCodeForTelemetry(err: unknown) {\n  const code = extractNextErrorCode(err)\n  if (code != null) {\n    return code\n  }\n\n  if (err instanceof Error && 'code' in err && typeof err.code === 'string') {\n    return err.code\n  }\n\n  if (err instanceof Error) {\n    return err.name\n  }\n\n  return 'Unknown'\n}\n"],"names":["loadEnvConfig","bold","yellow","makeRe","existsSync","promises","fs","os","Worker","defaultConfig","devalue","findUp","nanoid","path","STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR","PUBLIC_DIR_MIDDLEWARE_CONFLICT","MIDDLEWARE_FILENAME","PROXY_FILENAME","PAGES_DIR_ALIAS","INSTRUMENTATION_HOOK_FILENAME","RSC_PREFETCH_SUFFIX","RSC_SUFFIX","NEXT_RESUME_HEADER","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","NEXT_CACHE_REVALIDATED_TAGS_HEADER","MATCHED_PATH_HEADER","RSC_SEGMENTS_DIR_SUFFIX","RSC_SEGMENT_SUFFIX","FileType","fileExists","findPagesDir","loadCustomRoutes","normalizeRouteRegex","nonNullable","recursiveDeleteSyncWithAsyncRetries","verifyPartytownSetup","BUILD_ID_FILE","BUILD_MANIFEST","CLIENT_STATIC_FILES_PATH","EXPORT_DETAIL","EXPORT_MARKER","IMAGES_MANIFEST","PAGES_MANIFEST","PHASE_PRODUCTION_BUILD","PRERENDER_MANIFEST","REACT_LOADABLE_MANIFEST","ROUTES_MANIFEST","SERVER_DIRECTORY","SERVER_FILES_MANIFEST","STATIC_STATUS_PAGES","MIDDLEWARE_MANIFEST","APP_PATHS_MANIFEST","APP_PATH_ROUTES_MANIFEST","RSC_MODULE_TYPES","NEXT_FONT_MANIFEST","SUBRESOURCE_INTEGRITY_MANIFEST","MIDDLEWARE_BUILD_MANIFEST","MIDDLEWARE_REACT_LOADABLE_MANIFEST","SERVER_REFERENCE_MANIFEST","FUNCTIONS_CONFIG_MANIFEST","DYNAMIC_CSS_MANIFEST","TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST","UNDERSCORE_NOT_FOUND_ROUTE","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY","isDynamicRoute","Bundler","finalizeBundlerFromConfig","loadConfig","normalizePagePath","getPagePath","ciEnvironment","turborepoTraceAccess","TurborepoAccessTraceResult","writeTurborepoAccessTraceResult","eventBuildOptimize","eventCliSession","eventBuildFeatureUsage","eventNextPlugins","EVENT_BUILD_FEATURE_USAGE","eventPackageUsedInGetServerSideProps","eventBuildCompleted","eventBuildFailed","Telemetry","createPagesMapping","collectAppFiles","processPageRoutes","processAppRoutes","processLayoutRoutes","extractSlotsFromAppRoutes","extractSlotsFromDefaultFiles","combineSlots","collectPagesFiles","sortByPageExts","getStaticInfoIncludingLayouts","PAGE_TYPES","generateBuildId","isWriteable","Log","createSpinner","trace","flushAllTraces","setGlobal","detectConflictingPaths","printCustomRoutes","printTreeView","copyTracedFiles","isReservedPage","isAppBuiltinPage","collectRoutesUsingEdgeRuntime","collectMeta","writeBuildId","normalizeLocalePath","isError","isEdgeRuntime","recursiveCopy","lockfilePatchPromise","teardownTraceSubscriber","getNamedRouteRegex","getFilesInDir","eventSwcPlugins","normalizeAppPath","ACTION_HEADER","NEXT_ROUTER_PREFETCH_HEADER","RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","webpackBuild","NextBuildContext","normalizePathSep","isAppRouteRoute","createClientRouterFilter","createValidFileMatcher","startTypeChecking","generateInterceptionRoutesRewrites","buildDataRoute","collectBuildTraces","formatManifest","recordFrameworkVersion","updateBuildDiagnostics","recordFetchMetrics","getStartServerInfo","logStartInfo","hasCustomExportOutput","buildCustomRoute","traceMemoryUsage","generateEncryptionKeyBase64","uploadTrace","checkIsAppPPREnabled","checkIsRoutePPREnabled","FallbackMode","fallbackModeToFallbackField","RenderingMode","InvariantError","HTML_LIMITED_BOT_UA_RE_STRING","buildInversePrefetchSegmentDataRoute","buildPrefetchSegmentDataRoute","turbopackBuild","isFileSystemCacheEnabledForBuild","inlineStaticEnv","populateStaticEnv","durationToString","hrtimeDurationToString","traceGlobals","extractNextErrorCode","runAfterProductionCompile","generatePreviewKeys","handleBuildComplete","sortPageObjects","sortPages","sortSortableRouteObjects","mkdir","createRouteTypesManifest","writeRouteTypesManifest","writeValidatorFile","Lockfile","ALLOWED_HEADERS","pageToRoute","page","sourcePage","routeRegex","prefixRouteKeys","regex","re","source","routeKeys","namedRegex","getCacheDir","distDir","cacheDir","join","isCI","hasNextSupport","hasCache","console","log","prefixes","warn","writeFileUtf8","filePath","content","writeFile","readFileUtf8","readFile","writeManifest","manifest","readManifest","JSON","parse","writePrerenderManifest","writeClientSsgManifest","prerenderManifest","buildId","locales","ssgPages","Set","Object","entries","routes","filter","srcRoute","map","route","pathname","keys","dynamicRoutes","sort","clientSsgManifestContent","writeFunctionsConfigManifest","writeRequiredServerFilesManifest","requiredServerFiles","writeImagesManifest","config","images","deviceSizes","imageSizes","sizes","remotePatterns","p","protocol","replace","hostname","port","dot","search","localPatterns","version","STANDALONE_DIRECTORY","writeStandaloneDirectory","nextBuildSpan","pageKeys","denormalizedAppPages","outputFileTracingRoot","middlewareManifest","hasNodeMiddleware","hasInstrumentationHook","staticPages","loadedEnvFiles","appDir","traceChild","traceAsyncFn","pages","file","files","reduce","acc","envFile","includes","push","outputPath","relative","dirname","recursive","copyFile","middlewareOutput","overwrite","originalServerApp","getNumberOfWorkers","experimental","cpus","memoryBasedWorkersCount","Math","max","min","floor","freemem","staticWorkerPath","require","resolve","staticWorkerExposedMethods","createStaticWorker","options","debuggerPortOffset","progress","logger","numWorkers","onActivity","run","onActivityAbort","clear","enableSourceMaps","enablePrerenderSourceMaps","isolatedMemory","enableWorkerThreads","workerThreads","exposedMethods","writeFullyStaticExport","dir","enabledDirectories","configOutDir","appDirOnly","exportApp","default","buildExport","nextConfig","silent","outdir","getBuildId","isGenerateMode","build","reactProductionProfiling","debugOutput","debugPrerender","noMangling","bundler","Turbopack","experimentalBuildMode","traceUploadUrl","isCompileMode","buildStartTime","Date","now","loadedConfig","undefined","buildMode","process","env","__NEXT_VERSION","mappedPages","traceFn","turborepoAccessTraceResult","setAttribute","getBundlerForTelemetry","NEXT_DEPLOYMENT_ID","deploymentId","exit","info","customRoutes","headers","rewrites","redirects","combinedRewrites","beforeFiles","afterFiles","fallback","hasRewrites","length","originalRewrites","_originalRewrites","originalRedirects","_originalRedirects","distDirCreated","err","code","Error","lockDistDir","acquireWithRetriesOrExit","cleanDistDir","telemetry","publicDir","pagesDir","app","encryptionKey","isBuild","isSrcDir","startsWith","hasPublicDir","record","webpackVersion","cliCommand","hasNowJson","cwd","isCustomServer","turboFlag","then","events","envInfo","experimentalFeatures","dev","networkUrl","appUrl","logBundler","typeCheckingOptions","error","flush","validFileMatcher","pageExtensions","providedPagePaths","NEXT_PRIVATE_PAGE_PATHS","pagesPaths","Boolean","middlewareDetectionRegExp","RegExp","proxyDetectionRegExp","instrumentationHookDetectionRegExp","rootDir","rootPaths","Array","from","some","include","test","hasMiddlewareFile","hasProxyFile","previewProps","isDev","pagesType","PAGES","pagePaths","mappedAppPages","mappedAppLayouts","providedAppPaths","NEXT_PRIVATE_APP_PATHS","appPaths","layoutPaths","result","APP","mappedRootPaths","ROOT","pagesPageKeys","conflictingAppPagePaths","appPageKeys","appKey","normalizedAppPageKey","pagePath","appPath","add","basePath","totalAppPagesCount","routeTypesFilePath","validatorFilePath","appRoutes","appRouteHandlers","layoutRoutes","slots","pageRoutes","pageApiRoutes","slotsFromPages","slotsFromDefaults","defaultPaths","mappedDefaultFiles","routeTypesManifest","numConflictingAppPaths","conflictingPublicFiles","hasPages404","hasApp404","hasAppGlobalError","hasCustomErrorPage","hasUserPagesRoutes","hasPublicUnderScoreNextDir","hasPublicPageFile","File","numConflicting","nestedReservedPages","match","restrictedRedirectPaths","isAppCacheComponentsEnabled","cacheComponents","isAuthInterruptsEnabled","authInterrupts","isAppPPREnabled","ppr","routesManifestPath","sourcePages","Map","routesManifest","sortedRoutes","staticRoutes","pages404","caseSensitive","caseSensitiveRoutes","r","dataRoutes","i18n","rsc","header","varyHeader","prefetchHeader","didPostponeHeader","contentTypeHeader","suffix","prefetchSuffix","prefetchSegmentHeader","prefetchSegmentSuffix","prefetchSegmentDirSuffix","clientParamParsing","clientParamParsingOrigins","dynamicRSCPrerender","rdcForNavigations","rewriteHeaders","pathHeader","queryHeader","skipMiddlewareUrlNormalize","chain","clientRouterFilters","clientRouterFilter","nonInternalRedirects","internal","clientRouterFilterRedirects","clientRouterFilterAllowedRate","buildStage","pagesManifestPath","buildTraceContext","buildTracesPromise","useBuildWorker","webpackBuildWorker","webpack","runServerAndEdgeInParallel","parallelServerCompiles","collectServerBuildTracesInParallel","parallelServerBuildTraces","String","buildOptions","shutdownPromise","Promise","duration","compilerDuration","rest","NEXT_TURBOPACK_USE_WORKER","durationString","event","durationInSeconds","round","serverBuildPromise","res","buildTraceWorker","edgeRuntimeRoutes","catch","edgeBuildPromise","buildSpan","metadata","projectDir","collectingPageDataStart","hrtime","postCompileSpinner","buildManifestPath","staticAppPagesCount","serverAppPagesCount","edgeRuntimeAppCount","edgeRuntimePagesCount","ssgStaticFallbackPages","ssgBlockingFallbackPages","invalidPages","serverPropsPages","additionalPaths","staticPaths","appNormalizedPaths","fallbackModes","appDefaultConfigs","pageInfos","pagesManifest","buildManifest","appPathRoutes","appPathsManifest","key","NEXT_PHASE","worker","analysisBegin","staticCheckSpan","functionsConfigManifest","functions","customAppGetInitialProps","namedExports","isNextImageImported","hasNonStaticErrorPage","configFileName","sriEnabled","sri","algorithm","nonStaticErrorPageSpan","errorPageHasCustomGetInitialProps","hasCustomGetInitialProps","checkingApp","errorPageStaticResult","isPageStatic","httpAgentOptions","defaultLocale","nextConfigOutput","output","pprConfig","cacheLifeProfiles","cacheLife","appPageToCheck","customAppGetInitialPropsPromise","namedExportsPromise","getDefinedNamedExports","actionManifest","entriesWithAction","id","node","entry","workers","edge","all","pageType","checkPageSpan","actualPage","isRoutePPREnabled","isSSG","isStatic","isServerComponent","ssgPageRoutes","find","originalAppPath","originalPath","normalizedPath","pageFilePath","isInsideAppDir","staticInfo","hadUnsupportedValue","errorFromUnsupportedSegmentConfig","runtime","maxDuration","preferredRegion","regions","pageRuntime","client","edgeInfo","manifestKey","isPageStaticSpan","workerResult","parentId","getId","cacheHandler","cacheHandlers","isrFlushToDisk","maxMemoryCacheSize","cacheMaxMemorySize","set","warnOnce","isDynamic","prerenderedRoutes","appConfig","revalidate","hasGenerateStaticParams","params","encodedPathname","fallbackRouteParams","fallbackMode","prerenderFallbackMode","fallbackRootParams","throwOnEmptyStaticShell","dynamic","hasStaticProps","BLOCKING_STATIC_RENDER","PRERENDER","hasServerProps","delete","message","initialCacheControl","pageDuration","ssgPageDurations","hasEmptyStaticShell","errorPageResult","nonStaticErrorPage","returnValue","collectingPageDataEnd","setText","stopAndPersist","instrumentationHookEntryFiles","requiredServerFilesManifest","normalizedCacheHandlers","value","serverFilesManifest","configFile","compress","trustHostHeader","isExperimentalCompile","relativeAppDir","ignore","middlewareFile","matchers","middleware","regexp","originalSource","size","useStaticPages404","pg","optimizeCss","globOrig","cssFilePaths","reject","__NEXT_TEST_MODE","NEXT_PRIVATE_DEBUG_CACHE_ENTRY_HANDLERS","isAbsolute","features","featureName","invocationCount","nextScriptWorkers","isolatedDevBuild","feature","eventName","payload","notFoundRoutes","preview","tbdPrerenderRoutes","usedStaticStatusPages","forEach","has","hasPages500","useDefaultStatic500","combinedPages","isApp404Static","hasStaticApp404","isAppGlobalErrorStatic","hasStaticAppGlobalError","hasGSPAndRevalidateZero","staticGenerationSpan","sortedStaticPaths","a","b","localeCompare","exportConfig","exportPathMap","defaultMap","_pagesFallback","_ssgPath","get","isDynamicError","clientSegmentCache","_fallbackRouteParams","_isDynamicError","_isAppDir","_isRoutePPREnabled","_allowEmptyStaticShell","isSsg","isFallback","locale","_locale","exportResult","statusMessage","getFallbackMode","byPath","NOT_FOUND","getCacheControl","exportPath","defaultRevalidate","cacheControl","expire","expireTime","NEXT_SSG_FETCH_METRICS","traces","turborepoAccessTraceResults","values","ssgNotFoundPaths","serverBundle","unlink","ssgPageRoutesSet","hasRevalidateZero","isAppRouteHandler","htmlBotsRegexString","htmlLimitedBots","bypassFor","type","staticPrerenderedRoutes","dynamicPrerenderedRoutes","unsortedUnknownPrerenderRoutes","unsortedKnownPrerenderRoutes","prerenderedRoute","sortedUnknownPrerenderRoutes","sortedKnownPrerenderRoutes","hasPostponed","normalizedRoute","dataRoute","posix","prefetchDataRoute","meta","status","initialStatus","initialHeaders","renderingMode","PARTIALLY_STATIC","STATIC","experimentalPPR","experimentalBypassFor","initialRevalidateSeconds","initialExpireSeconds","allowHeader","pageInfo","dynamicRoute","skipInternalRouting","segmentPaths","pageSegmentPath","item","endsWith","builtSegmentDataRoute","destination","prefetchSegmentDataRoutes","hasFallbackRootParams","isDynamicAppRoute","fallbackCacheControl","fallbackRevalidate","fallbackExpire","fallbackStatus","fallbackHeaders","fallbackSourceRoute","dataRouteRegex","includeSuffix","excludeOptionalTrailingSlash","prefetchDataRouteRegex","moveExportedPage","originPage","ext","additionalSsgFile","orig","relativeDest","slice","split","dest","isNotFound","rename","localeExt","extname","relativeDestNoPages","curPath","updatedRelativeDest","updatedOrig","updatedDest","moveExportedAppNotFoundTo404","moveExportedAppGlobalErrorTo500","error500Html","isStaticSsgFallback","durationInfo","byPage","durationsByPath","hasHtmlOutput","localePage","pageFile","rm","force","finalizingPageOptimizationStart","postBuildSpinner","buildTracesSpinner","buildTracesStart","end","analysisEnd","staticPageCount","staticPropsPageCount","serverPropsPageCount","ssrPageCount","hasStatic404","hasReportWebVitals","rewritesCount","headersCount","redirectsCount","headersWithHasCount","rewritesWithHasCount","redirectsWithHasCount","middlewareCount","telemetryState","usages","packagesUsedInServerSideProps","useCacheTracker","tbdRoute","previewModeId","fetchCacheKeyPrefix","allowedRevalidateHeaderKeys","hasExportPathMap","exportTrailingSlash","trailingSlash","buildTracesEnd","adapterPath","nextVersion","tracingRoot","finalizingPageOptimizationEnd","e","errorCode","getErrorCodeForTelemetry","cur","mode","isTurboSession","sync","Rspack","Webpack","name"],"mappings":"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","ignoreList":[0]}