{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n  workStore: WorkStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n\n  return makeDynamicallyTrackedParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringParams(\n  underlyingParams: Params,\n  fallbackParams: OpaqueFallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(underlyingParams)\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForSyncAccess(store.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n"],"names":["workAsyncStorage","ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","delayUntilRuntimeStage","workUnitAsyncStorage","throwInvariantForMissingStore","InvariantError","describeStringPropertyAccess","wellKnownProperties","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","dynamicAccessAsyncStorage","createParamsFromClient","underlyingParams","workStore","workUnitStore","getStore","type","createStaticPrerenderParams","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createRuntimePrerenderParams","createPrerenderParamsForClientSegment","fallbackParams","fallbackRouteParams","key","has","renderSignal","route","Promise","resolve","prerenderStore","makeHangingParams","makeErroringParams","makeUntrackedParams","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Error","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","Object","keys","forEach","defineProperty","expression","dynamicTracking","enumerable","proxiedProperties","Set","add","proxiedPromise","warnForSyncAccess","value","delete","ownKeys","Reflect","createParamsAccessError","prefix"],"mappings":"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","ignoreList":[0]}