{"version":3,"sources":["../../../../src/server/lib/cache-handlers/default.external.ts"],"sourcesContent":["/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  areTagsExpired,\n  areTagsStale,\n  tagsManifest,\n  type TagManifestEntry,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\n// LRU cache default to max 50 MB but in future track\nconst memoryCache = new LRUCache<PrivateCacheEntry>(\n  50 * 1024 * 1024,\n  (entry) => entry.size\n)\nconst pendingSets = new Map<string, Promise<void>>()\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'DefaultCacheHandler:')\n  : undefined\n\nconst DefaultCacheHandler: CacheHandler = {\n  async get(cacheKey) {\n    const pendingPromise = pendingSets.get(cacheKey)\n\n    if (pendingPromise) {\n      debug?.('get', cacheKey, 'pending')\n      await pendingPromise\n    }\n\n    const privateEntry = memoryCache.get(cacheKey)\n\n    if (!privateEntry) {\n      debug?.('get', cacheKey, 'not found')\n      return undefined\n    }\n\n    const entry = privateEntry.entry\n    if (\n      performance.timeOrigin + performance.now() >\n      entry.timestamp + entry.revalidate * 1000\n    ) {\n      // In-memory caches should expire after revalidate time because it is\n      // unlikely that a new entry will be able to be used before it is dropped\n      // from the cache.\n      debug?.('get', cacheKey, 'expired')\n\n      return undefined\n    }\n\n    let revalidate = entry.revalidate\n\n    if (areTagsExpired(entry.tags, entry.timestamp)) {\n      debug?.('get', cacheKey, 'had expired tag')\n      return undefined\n    }\n\n    if (areTagsStale(entry.tags, entry.timestamp)) {\n      debug?.('get', cacheKey, 'had stale tag')\n      revalidate = -1\n    }\n\n    const [returnStream, newSaved] = entry.value.tee()\n    entry.value = newSaved\n\n    debug?.('get', cacheKey, 'found', {\n      tags: entry.tags,\n      timestamp: entry.timestamp,\n      expire: entry.expire,\n      revalidate,\n    })\n\n    return {\n      ...entry,\n      revalidate,\n      value: returnStream,\n    }\n  },\n\n  async set(cacheKey, pendingEntry) {\n    debug?.('set', cacheKey, 'start')\n\n    let resolvePending: () => void = () => {}\n    const pendingPromise = new Promise<void>((resolve) => {\n      resolvePending = resolve\n    })\n    pendingSets.set(cacheKey, pendingPromise)\n\n    const entry = await pendingEntry\n\n    let size = 0\n\n    try {\n      const [value, clonedValue] = entry.value.tee()\n      entry.value = value\n      const reader = clonedValue.getReader()\n\n      for (let chunk; !(chunk = await reader.read()).done; ) {\n        size += Buffer.from(chunk.value).byteLength\n      }\n\n      memoryCache.set(cacheKey, {\n        entry,\n        isErrored: false,\n        errorRetryCount: 0,\n        size,\n      })\n\n      debug?.('set', cacheKey, 'done')\n    } catch (err) {\n      // TODO: store partial buffer with error after we retry 3 times\n      debug?.('set', cacheKey, 'failed', err)\n    } finally {\n      resolvePending()\n      pendingSets.delete(cacheKey)\n    }\n  },\n\n  async refreshTags() {\n    // Nothing to do for an in-memory cache handler.\n  },\n\n  async getExpiration(tags) {\n    const expirations = tags.map((tag) => {\n      const entry = tagsManifest.get(tag)\n      if (!entry) return 0\n      // Return the most recent timestamp (either expired or stale)\n      return entry.expired || 0\n    })\n\n    const expiration = Math.max(...expirations, 0)\n\n    debug?.('getExpiration', { tags, expiration })\n\n    return expiration\n  },\n\n  async updateTags(tags, durations) {\n    const now = Math.round(performance.timeOrigin + performance.now())\n    debug?.('updateTags', { tags, timestamp: now })\n\n    for (const tag of tags) {\n      // TODO: update file-system-cache?\n      const existingEntry = tagsManifest.get(tag) || {}\n\n      if (durations) {\n        // Use provided durations directly\n        const updates: TagManifestEntry = { ...existingEntry }\n\n        // mark as stale immediately\n        updates.stale = now\n\n        if (durations.expire !== undefined) {\n          updates.expired = now + durations.expire * 1000 // Convert seconds to ms\n        }\n\n        tagsManifest.set(tag, updates)\n      } else {\n        // Update expired field for immediate expiration (default behavior when no durations provided)\n        tagsManifest.set(tag, { ...existingEntry, expired: now })\n      }\n    }\n  },\n}\n\nexport default DefaultCacheHandler\n"],"names":["LRUCache","areTagsExpired","areTagsStale","tagsManifest","memoryCache","entry","size","pendingSets","Map","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","console","bind","undefined","DefaultCacheHandler","get","cacheKey","pendingPromise","privateEntry","performance","timeOrigin","now","timestamp","revalidate","tags","returnStream","newSaved","value","tee","expire","set","pendingEntry","resolvePending","Promise","resolve","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","err","delete","refreshTags","getExpiration","expirations","map","tag","expired","expiration","Math","max","updateTags","durations","round","existingEntry","updates","stale"],"mappings":"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","ignoreList":[0]}